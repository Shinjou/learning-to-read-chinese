// File: ./test/widget_test.dart

// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:ltrc/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

// End of file: ./test/widget_test.dart
//----------------------

// File: ./lib/contants/routes.dart

import 'package:flutter/material.dart';
import 'package:ltrc/data/models/word_status_model.dart';
import 'package:ltrc/views/acknowledge.dart';
import 'package:ltrc/views/check_zhuyin_view.dart';
import 'package:ltrc/views/bopomo_quiz.dart';
import 'package:ltrc/views/bopomo_quiz_finish.dart';
import 'package:ltrc/views/bopomos_view.dart';
import 'package:ltrc/views/duoyinzi_view.dart';
import 'package:ltrc/views/log_in_view.dart';
import 'package:ltrc/views/main_page_view.dart';
import 'package:ltrc/views/register_account_view.dart';
import 'package:ltrc/views/register_view.dart';
import 'package:ltrc/views/reset_password.dart';
import 'package:ltrc/views/reset_pwd_account.dart';
import 'package:ltrc/views/safety_hint_register_view.dart';
import 'package:ltrc/views/safety_hint_verify_view.dart';
import 'package:ltrc/views/setting_view.dart';
import 'package:ltrc/views/sw_version_view.dart';
import 'package:ltrc/views/teach_word_view.dart';
import 'package:ltrc/views/units_view.dart';
import 'package:ltrc/views/words_view.dart';


class AppRoutes {
  AppRoutes._();
  static const String acknowledge = '/acknowledge';
  static const String bopomos = '/bopomos';
  static const String bopomoQuiz = '/bopomoQuiz';
  static const String bopomoQuizFinish = '/bopomoQuizFinish';
  static const String login = '/login';
  static const String mainPage = '/mainPage';
  static const String register = '/register';
  static const String registerAccount = '/registerAccount';
  static const String resetPwdAccount = '/resetPwdAccount';
  static const String safetyHintRegister = '/safetyHintRegister';
  static const String safetyHintVerify = '/safetyHintVerify';
  static const String setNewPwd = '/setNewPwd';
  static const String setting = '/setting';
  static const String swversion = '/swversion';
  static const String teachWord = '/teachWord';
  static const String units = '/units';
  static const String words = '/words';
  static const String duoyinzi = '/duoyinzi';
  static const String checkzhuyin = '/checkzhuyin';  // To test zhuyin


  static Map<String, WidgetBuilder> define() {
    return {
      acknowledge: (context) => const AcknowledgeView(),
      bopomos: (context) => const BopomosView(),
      bopomoQuiz: (context) => const BopomoQuizView(),
      bopomoQuizFinish: (context) => const BopomoQuizFinishView(),
      login: (context) => const LogInView(),
      mainPage: (context) => const MainPageView(),
      register: (context) => const RegisterView(),
      registerAccount: (context) => const RegisterAccountView(),
      resetPwdAccount: (context) => const ResetPwdAccountView(),
      safetyHintRegister: (context) => const SafetyHintRegisterView(),
      safetyHintVerify: (context) => const SafetyHintVerifyView(),
      setNewPwd: (context) => const ResetPwdView(),
      setting: (context) => const SettingView(),
      swversion: (context) => const SwVersionView(),
      units: (context) => const UnitsView(),
      words: (context) => const WordsView(),
      duoyinzi: (context) => const DuoyinziView(),
      checkzhuyin: (context) => const CheckZhuyinView(), // To test zhuyin
      teachWord: (context) {
        final args = ModalRoute.of(context)!.settings.arguments as Map<String, dynamic>;
        return TeachWordView(
          unitId: args['unitId'] as int,
          unitTitle: args['unitTitle'] as String,
          wordsStatus: (args['wordsStatus'] as List).cast<WordStatus>(),
          wordsPhrase: args['wordsPhrase'] as List<Map>,
          wordIndex: args['wordIndex'] as int,
        );
      },      
    };
  }
}

// End of file: ./lib/contants/routes.dart
//----------------------

// File: ./lib/contants/semester_code.dart

Map<int, String> semesterCodeTable = {
  0: "上",
  1: "下",
};

// End of file: ./lib/contants/semester_code.dart
//----------------------

// File: ./lib/contants/publisher_code.dart

Map<int, String> publisherCodeTable = {
  0: "翰林",
  1: "南一",
  2: "康軒"
};
// End of file: ./lib/contants/publisher_code.dart
//----------------------

// File: ./lib/contants/arabic_numerals_to_chinese.dart

Map<int, String> numeralToChinese = {
  1: "一",
  2:"二",
  3:"三",
  4:"四",
  5:"五",
  6:"六",
  7:"七",
  8:"八",
  9:"九",
  10:"十",
  11:"十一",
  12:"十二",
  13:"十三",
  14:"十四",
  15:"十五",
  16:"十六",
};
// End of file: ./lib/contants/arabic_numerals_to_chinese.dart
//----------------------

// File: ./lib/contants/bopomos.dart

const List<String> tones = ['ˊ', 'ˇ', 'ˋ', '˙'];
const List<String> initials = ['ㄅ', 'ㄆ', 'ㄇ', 'ㄈ', 'ㄉ', 'ㄊ', 'ㄋ', 'ㄌ', 'ㄍ', 'ㄎ', 'ㄏ', 'ㄐ', 'ㄑ', 'ㄒ', 'ㄓ', 'ㄔ', 'ㄕ', 'ㄖ', 'ㄗ', 'ㄘ', 'ㄙ'];
const List<String> prenuclear =['ㄧ', 'ㄨ', 'ㄩ'];
const List<String> finals = ['ㄚ', 'ㄛ', 'ㄜ', 'ㄝ', 'ㄞ', 'ㄟ', 'ㄠ', 'ㄡ', 'ㄢ', 'ㄣ', 'ㄤ', 'ㄥ', 'ㄦ'];
const Map<String, int> toneToInt = {
  '' : 1,
  'ˊ': 2,
  'ˇ': 3,
  'ˋ': 4,
  '˙': 5,
};
// End of file: ./lib/contants/bopomos.dart
//----------------------

// File: ./lib/contants/register_question_label.dart

enum RegisterQuestionLabel {
  initial(0, ""),
  pet(1, "你最喜歡的寵物名稱"),
  name(2, "你外婆的名字"),
  color(3, "你最愛的顏色"),
  fruit(4, "你最愛的水果"),
  people(5, "你的家中有幾個人"),
  telephone(6, "家中電話號碼")
  ;

  const RegisterQuestionLabel(this.value, this.question);
  final int value;
  final String question;
}

List<String> registerQuestions = RegisterQuestionLabel.values.map((e) => e.question).toList();
// End of file: ./lib/contants/register_question_label.dart
//----------------------

// File: ./lib/contants/bopomo_spelling_problem.dart

const List<String> bopomoSpellingWords = ['山', '木', '人', '你', '他', '我',
  '王', '坐', '來', '丟', '走', '想', '說', '叫', '吹', '抱', '挖', '指', '民',
  '遊', '耳', '鞋', '請', '草', '方', '怕', '光', '國', '喝', '月'];
// 把 掃、看換成民、國，以避免多音字問題
// End of file: ./lib/contants/bopomo_spelling_problem.dart
//----------------------

// File: ./lib/extensions.dart

import 'package:flutter/material.dart';

extension ColorExtension on String {
  toColor() {
    var hexString = this;
    final buffer = StringBuffer();
    if (hexString.length == 6 || hexString.length == 7) buffer.write('ff');
    buffer.write(hexString.replaceFirst('#', ''));
    return Color(int.parse(buffer.toString(), radix: 16));
  }
}

// End of file: ./lib/extensions.dart
//----------------------

// File: ./lib/main.dart

// main.dart 

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/views/view_utils.dart';
import 'package:path_provider/path_provider.dart';
import 'package:logger/logger.dart';
import 'dart:io';

import 'package:ltrc/providers.dart';
import 'package:ltrc/data/providers/all_provider.dart';
import 'package:ltrc/data/providers/user_provider.dart';
import 'package:ltrc/views/log_in_view.dart';
import 'package:ltrc/views/polyphonic_processor.dart';
import 'package:ltrc/contants/routes.dart';
// import 'package:ltrc/extensions.dart';

Future<void> main() async {
  try {
    WidgetsFlutterBinding.ensureInitialized();
    setupLogger();
    await AllProvider.database;
    await UserProvider.database;
    await PolyphonicProcessor.instance.loadPolyphonicData();

    runApp(const ProviderScope(child: MyApp()));
  } catch (e) {
    debugPrint('Failed to init the database: $e');
  }
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final grade = ref.watch(gradeProvider);

    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: '學國語',
      theme: _buildThemeData(grade),
      routes: AppRoutes.define(),
      home: const ScreenInfoInitializer(child: HomePage()),
      builder: (context, child) {
        return MediaQuery(
          data: MediaQuery.of(context).copyWith(textScaler: const TextScaler.linear(1.0)),
          child: child!,
        );
      },
    );
  }

  ThemeData _buildThemeData(int grade) {
    return ThemeData(
      appBarTheme: const AppBarTheme(
        iconTheme: IconThemeData(color: beige),
        foregroundColor: beige,
        color: darkBrown,
      ),
      scaffoldBackgroundColor: darkBrown,
      useMaterial3: true,
      fontFamily: grade < 5 ? 'BpmfIansui' : 'Iansui',
      textTheme: const TextTheme(
        bodyMedium: TextStyle(),
        bodyLarge: TextStyle(),
      ).apply(
        bodyColor: beige,
      ),
    );
  }
}

class ScreenInfoInitializer extends ConsumerStatefulWidget {
  final Widget child;
  const ScreenInfoInitializer({super.key, required this.child});

  @override
  ScreenInfoInitializerState createState() => ScreenInfoInitializerState();
}

class ScreenInfoInitializerState extends ConsumerState<ScreenInfoInitializer> with WidgetsBindingObserver {
  late Future<void> _initFuture;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initFuture = _initializeScreenInfo();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeMetrics() {
    _updateScreenInfo();
  }

  Future<void> _initializeScreenInfo() async {
    // Wait for the first frame to ensure we have valid metrics
    await WidgetsBinding.instance.endOfFrame;
    if (mounted) {
      _updateScreenInfo();
    }
  }

  void _updateScreenInfo() {
    if (mounted) {
      ref.read(screenInfoProvider.notifier).init(context);
    }
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<void>(
      future: _initFuture,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());  // Show a loading spinner until the screen info is ready
        }

        final screenInfo = ref.watch(screenInfoProvider);
        if (screenInfo.screenHeight == 0 || screenInfo.screenWidth == 0) {
          return const Center(child: CircularProgressIndicator());  // Show a spinner while screen info is zero
        }

        return widget.child;
      },
    );
  }
}

class HomePage extends ConsumerWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final screenInfo = ref.watch(screenInfoProvider);
    debugPrint("HomePage build: H: ${screenInfo.screenHeight}, W: ${screenInfo.screenWidth}, F: ${screenInfo.fontSize}, ${screenInfo.orientation}, T: ${screenInfo.isTablet}");

    if (screenInfo.screenHeight == 0 || screenInfo.screenWidth == 0) {
      return const Center(child: CircularProgressIndicator());  // Show a spinner if screen info is still not ready
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(
          '學國語',
          style: TextStyle(fontSize: screenInfo.fontSize),
        ),
      ),
      body: const LogInView(),
    );
  }
}


class FileLogger extends LogOutput {
  final File file;

  FileLogger(this.file);

  @override
  void output(OutputEvent event) {
    for (var line in event.lines) {
      file.writeAsString('$line\n', mode: FileMode.append, flush: true).catchError((e) {
        debugPrint('Error writing to log file: $e');
        return file;
      });
    }
  }
}

Future<File> _getLogFile() async {
  final directory = await getApplicationDocumentsDirectory();
  return File('${directory.path}/app_logs.txt');
}

void setupLogger() async {
  final file = await _getLogFile();
  var logger = Logger(
    output: FileLogger(file),
  );

  logger.d("This is a debug message");
}

// End of file: ./lib/main.dart
//----------------------

// File: ./lib/providers.dart

// import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/views/view_utils.dart';

final soundSpeedProvider = StateProvider<double>((ref) => 0.5);
final zhuyinOnProvider = StateProvider<bool>((ref) => true);

final gradeProvider = StateProvider<int>((ref) => 1);
final publisherCodeProvider = StateProvider<int>((ref) => 0);
final semesterCodeProvider = StateProvider<int>((ref) => 0); // was 上 0: 上, 1: 下
final accountProvider = StateProvider<String>((ref) => "");
final pwdProvider = StateProvider<String>((ref) => "");
final teachWordViewProvider = StateProvider<int>((ref) => 0);
final userNameProvider = StateProvider<String>((ref) => "");
final totalWordCountProvider = StateProvider<int>((ref) => 186);
final learnedWordCountProvider = StateProvider<int>((ref) => 0);

final screenInfoProvider = StateNotifierProvider<ScreenInfoNotifier, ScreenInfo>((ref) {
  return ScreenInfoNotifier();
});
// End of file: ./lib/providers.dart
//----------------------

// File: ./lib/data/providers/word_provider.dart

import 'dart:async';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:ltrc/data/providers/all_provider.dart';

import '../models/word_model.dart';

class WordProvider {
  static Database? database;
  static Future<Database> getDBConnect() async {
    database ??= await AllProvider.getDBConnect();
    return database!;
  }

  static String tableName = 'Words';
  
  // Define constants for database
  static const String databaseId = 'id';
  static const String databaseWord = 'word';
  static const String databasePhoneticTone = 'phonetic_tone';
  static const String databasePhonetic = 'phonetic';
  static const String databaseTone = 'tone';
  static const String databaseShapeSymbol = 'shape_symbol';
  static const String databaseSoundSymbol = 'sound_symbol';
  static const String databaseStrokes = 'strokes';
  static const String databaseCommon = 'common';


  static Future<void> addWord(Word word) async {
    final Database db = await getDBConnect();
    await db.insert(
      tableName,
      word.toMap(),
      conflictAlgorithm: ConflictAlgorithm.ignore,
    );
  }

  static Future<Word> getWord({required String inputWord}) async {
    final Database db = await getDBConnect();
    final List<Map<String, dynamic>> maps = await db.query(tableName,
      columns: ["*"],
      where: "$databaseWord=?",
      whereArgs: [inputWord]
    );
    return Word(
      id: maps[0][databaseId],
      word: maps[0][databaseWord],
      phoneticTone: maps[0][databasePhoneticTone],
      phonetic: maps[0][databasePhonetic],
      tone: maps[0][databaseTone],
      shapeSymbol: maps[0][databaseShapeSymbol],
      soundSymbol: maps[0][databaseSoundSymbol],
      strokes: (maps[0][databaseStrokes].runtimeType == String) ? 0 : maps[0][databaseStrokes],
      common: (maps[0][databaseCommon].runtimeType == String) ? 0 : maps[0][databaseCommon],
    );
  }

  static Future<void> closeDb() async{
    database = null;
    await deleteDatabase(
      join(await getDatabasesPath(), 'all.sqlite')
    );
  }
}

// End of file: ./lib/data/providers/word_provider.dart
//----------------------

// File: ./lib/data/providers/all_provider.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:path/path.dart';
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:sqflite/sqflite.dart';

class AllProvider {
  static Database? _database;
  static bool dbExists = false;  

  static const String _dbName = 'all.sqlite';  
  static const int _dbNewVersion = 10;  // Always upgrade to the latest version

  /// Gets the database instance, initializing if necessary.
  static Future<Database> get database async {
    _database ??= await _initDatabase();
    return _database!;
  }

  static Future<Database> getDBConnect() async {
    if (!dbExists){
      _database ??= await _initDatabase();
    }
    return _database!;
  } 

  /// Initializes the database if it doesn't exist or has the wrong version.
  static Future<Database> _initDatabase() async {
    try {
      String dbPath = join(await getDatabasesPath(), _dbName);
      debugPrint('Path to $_dbName: $dbPath');

      dbExists = await databaseExists(dbPath);
      if (!dbExists) {
        await _copyDbFromAssets(dbPath);
        dbExists = true;
        debugPrint('$_dbName copied from assets.');
      } 

      // Open the database
      _database = await openDatabase(dbPath);

      // Check and potentially upgrade the database version
      int currentVersion = await _database!.getVersion();
      debugPrint('$_dbName: New version $_dbNewVersion, Current: $currentVersion');
      if (currentVersion < _dbNewVersion) {
        debugPrint('Upgrading $_dbName from version $currentVersion to $_dbNewVersion ...');
        // If an upgrade is needed, copy the DB from assets
        await closeDb();
        await _copyDbFromAssets(dbPath);
        _database = await openDatabase(dbPath);
        debugPrint('Upgrade $_dbName successfully to version $_dbNewVersion');
      }
      
      return _database!;
    } catch (e) {
      debugPrint('Error initializing $_dbName: $e');
      rethrow;
    }
  }

  /// Copies the database from the assets folder into the device's app directory.
  static Future<void> _copyDbFromAssets(String dbPath) async {
    try {
      debugPrint('Copying $_dbName from assets/data_files/...');
      ByteData data = await rootBundle.load(join('assets/data_files/', _dbName));
      List<int> bytes = data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
      await File(dbPath).writeAsBytes(bytes, flush: true);
      debugPrint('Copy of $_dbName to $dbPath completed successfully.');
    } catch (e) {
      debugPrint('Failed to copy $_dbName from assets to $dbPath. Error: $e');
      rethrow;
    }
  }

  /// Closes the database if it's open.
  static Future<void> closeDb() async {
    if (_database != null) {
      await _database!.close();
      _database = null;
    }
  }

  /// Retrieves the current version of the all.sqlite database.
  static Future<int> getCurrentDatabaseVersion() async {
    final db = await database;
    return await db.getVersion(); // Returns the current version of the opened database
  }
  
}


// End of file: ./lib/data/providers/all_provider.dart
//----------------------

// File: ./lib/data/providers/word_status_provider.dart

import 'dart:async';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:ltrc/data/providers/user_provider.dart';

import '../models/word_status_model.dart';

class WordStatusProvider {
  static Database? database;
  static Future<Database> getDBConnect() async {
    database ??= await UserProvider.getDBConnect();
    return database!;
  }

  static String tableName = 'wordStatus';
  
  // Define constants for database
  static const String databaseId = 'id';
  static const String databaseUserAccount = 'userAccount';
  static const String databaseWord = 'word';
  static const String databaseLearned = 'learned';
  static const String databaseLiked = 'liked';


  
  static Future<void> addWordStatus({required WordStatus status}) async {
    final Database db = await getDBConnect();
    await db.insert(
      tableName,
      status.toMap(),
      conflictAlgorithm: ConflictAlgorithm.ignore,
    );
  }

  static Future<void> addWordsStatus({required List<WordStatus> statuses}) async {
    final Database db = await getDBConnect();
    for ( var status in statuses ){
      await db.insert(
        tableName,
        status.toMap(),
        conflictAlgorithm: ConflictAlgorithm.ignore,
      );
    }
  }
    
  static Future<WordStatus> getWordStatus({required String word, required String account}) async {
    final Database db = await getDBConnect();
    final List<Map<String, dynamic>> maps = await db.query(tableName,
      columns: [databaseId, databaseUserAccount, databaseWord, databaseLearned, databaseLiked],
      where: "$databaseUserAccount = ? and $databaseWord = ?",
      whereArgs: [account, word]
    );
    return WordStatus(
      id: maps[0][databaseId],
      userAccount: maps[0][databaseUserAccount],
      word: maps[0][databaseWord],
      learned: (maps[0][databaseLearned] == 1) ? true : false,
      liked: (maps[0][databaseLiked] == 1) ? true : false
    );
  }

  static Future<List<WordStatus>> getWordsStatus({required List<String> words, required String account}) async {
    final Database db = await getDBConnect();
    List<WordStatus> statuses = [];
    for (var word in words){
      List<Map<String, dynamic>> maps = await db.query(tableName,
        columns: [databaseId, databaseUserAccount, databaseWord, databaseLearned, databaseLiked],
        where: "$databaseUserAccount = ? and $databaseWord = ?",
        whereArgs: [account, word]
      );
      statuses.add(
        WordStatus(
          id: maps[0][databaseId],
          userAccount: maps[0][databaseUserAccount],
          word: maps[0][databaseWord],
          learned: (maps[0][databaseLearned] == 1) ? true : false,
          liked: (maps[0][databaseLiked] == 1) ? true : false
        )
      );
    }
    return statuses;
  }

  static Future<List<WordStatus>> getLikedWordsStatus({required String account}) async {
    final Database db = await getDBConnect();
    List<WordStatus> statuses = [];
    List<Map<String, dynamic>> maps = await db.query(tableName,
      columns: ['*'],
      where: "$databaseUserAccount = ? and $databaseLiked = ?",
      whereArgs: [account, 1]
    );
    for (var entry in maps){
      statuses.add(
        WordStatus(
          id: entry[databaseId],
          userAccount: entry[databaseUserAccount],
          word: entry[databaseWord],
          learned: (entry[databaseLearned] == 1) ? true : false,
          liked: (entry[databaseLiked] == 1) ? true : false
        )
      );
    }
    return statuses;
  }

  static Future<void> updateWordStatus({required WordStatus status}) async {
    final Database db = await getDBConnect();
    await db.update(
      tableName,
      status.toMapWithId(),
      where: "$databaseId = ?",
      whereArgs: [status.id]
    );
  }

  static Future<void> closeDb() async {
    await deleteDatabase(join(await getDatabasesPath(), 'wordStatus.sqlite'));
  }
}

// End of file: ./lib/data/providers/word_status_provider.dart
//----------------------

// File: ./lib/data/providers/user_provider.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:path/path.dart';
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:sqflite/sqflite.dart';


import '../models/user_model.dart';

class UserProvider {
  static Database? _database;
  static bool dbExists = false;  
  static String tableName = 'users';

  // Define constants for database
  static const String databaseAccount = 'account';
  static const String databasePassword = 'password';
  static const String databaseUserName = 'username';
  static const String databaseSafetyQuestionId1 = 'safetyQuestionId1';
  static const String databaseSafetyAnswer1 = 'safetyAnswer1';
  static const String databaseSafetyQuestionId2 = 'safetyQuestionId2';
  static const String databaseSafetyAnswer2 = 'safetyAnswer2';
  static const String databaseGrade = 'grade';
  static const String databaseSemester = 'semester';
  static const String databasePublisher = 'publisher';

  static const String _dbName = 'users.sqlite';
    static const int _dbNewVersion = 10; // 10/14/2024
  static const String _wordStatusTable = 'wordStatus';

  static Future<Database> get database async {
    _database ??= await _initDatabase();
    return _database!;
  }

  static Future<Database> getDBConnect() async {
    if (!dbExists){
      _database = await _initDatabase();
    }
    return _database!;
  }  

  static Future<Database?> _initDatabase() async {
    try {
      String dbPath = join(await getDatabasesPath(), _dbName);
      debugPrint('Path to $_dbName: $dbPath');

      dbExists = await databaseExists(dbPath);
      if (!dbExists) {
        await _copyDbFromAssets(dbPath);
        dbExists = true;
        _database = await openDatabase(dbPath);
        debugPrint('$_dbName copied from assets.');
        return _database!;
      } 

      // Open the database
      _database = await openDatabase(dbPath);

      // Check and potentially upgrade the database version
      int currentVersion = await _database!.getVersion();
      if (currentVersion < _dbNewVersion) {
        debugPrint('Upgrading $_dbName from version $currentVersion to $_dbNewVersion ...');
        // users.sqlite如果需要 upgrade，需要個別處理
        // Ver 4，新增“鸚”一字。先刪掉舊的，再新增新的。
        try {
          await deleteWord(db: _database, userAccount: 'tester', word: '鸚');
          await addWord(db: _database, userAccount: 'tester', word: '鸚', learned: 1, liked: 1);

          bool userBpmfExists = await checkIfAccountExists('testerbpmf');
          if (!userBpmfExists) {
            await addUser(
              user: User(
                account: 'testerbpmf',
                password: '1234',
                username: 'testerbpmf',
                safetyQuestionId1: 1,
                safetyAnswer1: '1234',
                safetyQuestionId2: 2,
                safetyAnswer2: '1234',
                grade: 1,
                semester: '上',
                publisher: '康軒',
              ),
            );       
          }         
          await _database!.setVersion(_dbNewVersion);  
          debugPrint('Upgrade $_dbName successfully from $currentVersion to $_dbNewVersion');
        } catch (e) {
          debugPrint ("Error in upgrading users.sqlite: $e");
        }
      } else {
        debugPrint('Database $_dbName opened successfully...');
      }

      return _database!;
    } catch (e) {
      debugPrint('Error initializing $_dbName: $e');
      rethrow; // Consider handling this more gracefully
    }
  }

  static Future<void> _copyDbFromAssets(String dbPath) async {
    try {
      debugPrint('Copying $_dbName from assets/data_files/...');
      ByteData data = await rootBundle.load(join('assets/data_files/', _dbName));
      List<int> bytes = data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
      await File(dbPath).writeAsBytes(bytes, flush: true);
      debugPrint('Copy of $_dbName to $dbPath completed successfully.');
    } catch (e) {
      debugPrint('Failed to copy $_dbName from assets to $dbPath. Error: $e');
      rethrow;
    }
  }

  /// Retrieves the current version of the users.sqlite database.
  static Future<int> getCurrentDatabaseVersion() async {
    final db = await database;
    return await db.getVersion(); // Returns the current version of the opened database
  }

  static Future<void> addWord({
    required Database? db,
    required String userAccount,
    required String word,
    required int learned,
    required int liked,
  }) async {
    try {
      await db?.insert(
        _wordStatusTable,
        {
          'userAccount': userAccount,
          'word': word,
          'learned': learned,
          'liked': liked,
        },
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      debugPrint("Word $word added successfully");
    } catch (e) {
      debugPrint('An error occurred while inserting the word: $e');
    }
  }

  static Future<void> deleteWord({
    required Database? db,
    required String userAccount,
    required String word,
  }) async {
    try {
      await db?.delete(
        _wordStatusTable,
        where: 'userAccount = ? AND word = ?',
        whereArgs: [userAccount, word],
      );
      debugPrint("Word $word deleted successfully");
    } catch (e) {
      debugPrint('An error occurred while deleting the word: $e');
    }
  }

  static Future<void> addUser({required User user}) async {
    try {
      // Validate user input
      validateUser(user);

      /* Hash sensitive information
      user.password = hashPassword(user.password);
      user.safetyAnswer1 = hashPassword(user.safetyAnswer1);
      user.safetyAnswer2 = hashPassword(user.safetyAnswer2);
      */

      final Database db = await getDBConnect();
      await db.insert(
        tableName,
        user.toMap(),
        conflictAlgorithm: ConflictAlgorithm.abort,
      );
      debugPrint("User ${user.username} added successfully");
    } catch (e) {
      debugPrint('Error while adding a new user: $e');
      throw Exception('Failed to add user');
    }
  }


  static void validateUser(User user) {
    if (user.account.isEmpty || user.password.isEmpty) {
      throw Exception('Account and password cannot be empty');
    }
    // Add more validation as needed
  }  

  static Future<User> getUser({required String inputAccount}) async {
    final Database db = await getDBConnect();
    try {
      final List<Map<String, dynamic>> maps = await db.query(tableName,
          columns: [
            databaseAccount,
            databasePassword,
            databaseUserName,
            databaseSafetyQuestionId1,
            databaseSafetyAnswer1,
            databaseSafetyQuestionId2,
            databaseSafetyAnswer2,
            databaseGrade,
            databaseSemester,
            databasePublisher
          ],
          where: " $databaseAccount = ? ",
          whereArgs: [inputAccount]
          );
      return User(
        account: maps[0][databaseAccount],
        password: maps[0][databasePassword],
        username: maps[0][databaseUserName],
        safetyQuestionId1: maps[0][databaseSafetyQuestionId1],
        safetyAnswer1: maps[0][databaseSafetyAnswer1],
        safetyQuestionId2: maps[0][databaseSafetyQuestionId2],
        safetyAnswer2: maps[0][databaseSafetyAnswer2],
        grade: maps[0][databaseGrade],
        semester: maps[0][databaseSemester],
        publisher: maps[0][databasePublisher],
      );
    } catch (e) {
      throw("[Provider] get user error: $e");
    }
  }

  static Future<List<String>> getAllUserAccounts() async {
    final Database db = await getDBConnect();
    final List<Map<String, dynamic>> maps = await db.query(tableName,
      columns: [databaseAccount],
    );
    return List.generate(maps.length, (i) {
      return maps[i][databaseAccount];
    });
  }

  static Future<void> updateUser({required User user}) async {
    final Database db = await getDBConnect();
    await db.update(
      tableName, 
      user.toMap(),
        where: " $databaseAccount = ? ", 
      whereArgs: [user.account]
      );
  }

  static Future<void> deleteUser({required String inputAccount}) async {
    try {
      final Database db = await getDBConnect();
      await db.delete(tableName,
        where: " $databaseAccount = ? ", 
        whereArgs: [inputAccount]
      );
      await db.rawDelete("DELETE FROM wordStatus WHERE userAccount = ?", [inputAccount]);
    } catch (e) {
      // Error reporting
      debugPrint('Error deleting user $inputAccount: $e');
      // Consider using more sophisticated error reporting if available in your app
    }
  }

  static Future<bool> checkIfAccountExists(String accountName) async {
    try {
      // Attempt to get the user with the provided account name
      User user = await getUser(inputAccount: accountName);
      
      // If the query returns a user, the account exists
      if (user.account == accountName) {
        return true;  // Account exists
      }
      return false;   // Account does not exist
    } catch (e) {
      // If an error occurs, it could mean that the account doesn't exist or there's another issue
      debugPrint("[Provider] Error fetching user: $e");
      return false; // Assume account does not exist in case of an error
    }
  }


  static Future<void> closeDb() async {
    if (_database != null) {
      await _database!.close();
      _database = null;
    }
  }
}


// End of file: ./lib/data/providers/user_provider.dart
//----------------------

// File: ./lib/data/providers/unit_provider.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:ltrc/data/models/word_status_model.dart';
import 'package:ltrc/data/providers/all_provider.dart';
import 'package:ltrc/data/providers/word_status_provider.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

import '../models/unit_model.dart';

class UnitProvider {
  static Database? database;
  static Future<Database> getDBConnect() async {
    database ??= await AllProvider.getDBConnect();
    return database!;
  }

  static String tableName = "TextBooks";
  
  // Define constants for database
  static const String databaseId = 'id';
  static const String databasePublisher = 'publisher';
  static const String databaseGrade = 'grade';
  static const String databaseSemester = 'semester';
  static const String databaseUnitId = 'unit_id';
  static const String databaseUnitTitle = 'unit_title';
  static const String databaseNewWords = 'new_words';
  static const String databaseExtraWords = 'extra_words';
  static const String databaseContent = 'unit_content';


  static Future<void> addWordsInUnit(Unit unit) async {
    final Database db = await getDBConnect();
    await db.insert(
      tableName,
      unit.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  static Future<int> getTotalWordCount({required String inputPublisher, required int inputGrade, required String inputSemester}) async {
    final Database db = await getDBConnect();
    List<Map<String, Object?>> unitWords = await db.query(
      tableName,
      columns: [databaseNewWords, databaseExtraWords],
      where: '$databaseGrade = ? and $databaseSemester = ? and $databasePublisher = ?',
      whereArgs: [inputGrade, inputSemester, inputPublisher]
    );
    int count = 0;
    for (var unit in unitWords) {
      count += unit[databaseNewWords]!.toString().length;
      count += unit[databaseExtraWords]!.toString().length;
    }
    return count;
  }

  static Future<int> getLearnedWordCount({required String inputAccount, required String inputPublisher, required int inputGrade, required String inputSemester}) async {
    // debugPrint('getLearnedWordCount, $inputAccount, $inputPublisher, $inputGrade, $inputSemester');
    List<Unit> units = await getUnits(
      inputGrade: inputGrade, 
      inputPublisher: inputPublisher, 
      inputSemester: inputSemester
    );
    int count = 0;

    for (var unit in units){
      try {
        List<WordStatus> wordStatuses = await WordStatusProvider.getWordsStatus(
          words: List.from(unit.newWords)..addAll(unit.extraWords),
          account: inputAccount
        );
        for (var status in wordStatuses){
          count += status.learned ? 1 : 0 ;
        }
      } catch(e) {
        debugPrint('Unit ${unit.unitId} hasn\'t been read before');
      }
    }
    // debugPrint('getLearnedWordCount $count');
    return count;
  }
    
  static Future<List<Unit>> getUnits({required String inputPublisher, required int inputGrade, required String inputSemester}) async {
    final Database db = await getDBConnect();
    final List<Map<String, dynamic>> maps = await db.query(tableName,
      columns: [databaseId, databaseUnitId, databaseUnitTitle, databaseNewWords, databaseExtraWords],
      where: "$databasePublisher = ? and $databaseGrade = ? and $databaseSemester = ?",
      whereArgs: [inputPublisher, inputGrade, inputSemester]
    );
    // debugPrint('getUnits, $maps');
    return List.generate(maps.length, (i) {
      return Unit(
        id: maps[i][databaseId],
        publisher: inputPublisher,
        grade: inputGrade,
        semester: inputSemester,
        unitId: maps[i][databaseUnitId],
        unitTitle: maps[i][databaseUnitTitle],
        newWords: maps[i][databaseNewWords].split(''),
        extraWords: maps[i][databaseExtraWords].split(''),
        unitContent: "",
      );
    });
  }

  static void closeDb() async {
    database = null;
    await deleteDatabase(
      join(await getDatabasesPath(), 'all.sqlite')
    );
  }
}

// End of file: ./lib/data/providers/unit_provider.dart
//----------------------

// File: ./lib/data/providers/word_phrase_sentence_provider.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:ltrc/data/providers/all_provider.dart';

import '../models/word_phrase_sentence_model.dart';

class WordPhraseSentenceProvider {
  static Database? database;

  static Future<Database> getDBConnect() async {
    database ??= await AllProvider.getDBConnect();
    return database!;
  }

  static String tableName = 'WordPhraseSentence';
  
  // Define constants for database
  static const String databaseWordPhraseSentenceId = 'id';
  static const String databaseWord = 'word';
  static const String databasePhrase = 'phrase';
  static const String databaseDefinition = 'definition';
  static const String databaseSentence = 'sentence';
  static const String databasePhrase2 = 'phrase2';
  static const String databaseDefinition2 = 'definition2';
  static const String databaseSentence2 = 'sentence2';
  
  static Future<void> addWordPhraseSentence({required WordPhraseSentence wordphrasesentence}) async {
    final Database db = await getDBConnect();
    await db.insert(
      tableName,
      wordphrasesentence.toMap(), // How does this work?
      conflictAlgorithm: ConflictAlgorithm.ignore,
    );
  }


  static Future<WordPhraseSentence?> getWordPhraseSentenceById({required int inputWordPhraseSentenceId}) async {
    final Database db = await getDBConnect();
    final List<Map<String, dynamic>> maps = await db.query(tableName,
      columns: ["*"],
      where: "$databaseWordPhraseSentenceId=?",
      whereArgs: [inputWordPhraseSentenceId]
    );
    if (maps.isEmpty) {
      debugPrint("No word phrase sentence found for id: $inputWordPhraseSentenceId");
      return null;
    }
    return WordPhraseSentence(
      id: maps[0][databaseWordPhraseSentenceId],
      word: maps[0][databaseWord],
      phrase: maps[0][databasePhrase],
      definition: maps[0][databaseDefinition],
      sentence: maps[0][databaseSentence],
      phrase2: maps[0][databasePhrase2],
      definition2: maps[0][databaseDefinition2],
      sentence2: maps[0][databaseSentence2],      
    );
  }

  static Future<WordPhraseSentence> getWordPhraseSentenceByWord({required String inputWord}) async {
    try {
      final Database db = await getDBConnect();
      final List<Map<String, dynamic>> maps = await db.query(tableName,
        columns: ["*"],
        where: "$databaseWord=?",
        whereArgs: [inputWord]
      );

      if (maps.isNotEmpty) {
        // Assuming maps is not empty, return the first result as the WordPhraseSentence
        return WordPhraseSentence(
          id: maps[0][databaseWordPhraseSentenceId],
          word: maps[0][databaseWord],
          phrase: maps[0][databasePhrase],
          definition: maps[0][databaseDefinition],
          sentence: maps[0][databaseSentence],
          phrase2: maps[0][databasePhrase2],
          definition2: maps[0][databaseDefinition2],
          sentence2: maps[0][databaseSentence2],      
        );
      } else {
        // Handle the case where no results are found
        debugPrint("No word phrase sentence found for word: $inputWord");
        // Return a default or error object, or throw a custom exception as needed
        return WordPhraseSentence.error(); // Implement this method to return a default/error instance
      }
    } catch (e) {
      // Log the error or handle it as needed
      debugPrint("Error fetching word phrase sentence for word: $inputWord. Error: $e");
      // Return a default or error object, or re-throw the exception
      return WordPhraseSentence.error(); // Implement this method to return a default/error instance
    }
  }

  // For testing 多音字
  Future<List<Map<String, dynamic>>> readEntries() async {
    try {
      final Database db = await getDBConnect();
      List<Map<String, dynamic>> entries = await db.query('WordPhraseSentence', limit: 10);
      await db.close();
      return entries;
    } catch (e) {
      debugPrint("Error reading entries: $e");
      return [];
    }
  }

  static Future<int> getMaxId() async {
    final Database db = await getDBConnect();
    int maxId = Sqflite.firstIntValue(await db.rawQuery('SELECT MAX(id) FROM WordPhraseSentence')) ?? 0;
    return maxId;
  }  
  // For testing 多音字 - end

  static Future<void> closeDb() async{
    database = null;
    await deleteDatabase(
      join(await getDatabasesPath(), 'all.sqlite')
    );
  }
}

// End of file: ./lib/data/providers/word_phrase_sentence_provider.dart
//----------------------

// File: ./lib/data/models/bopomo_spelling_model.dart

class BopomoSpelling {
  BopomoSpelling(
    {this.initial = "",
    this.prenuclear = "",
    this.finals = "",
    this.tone = 1}
  );
  
  String initial;
  String prenuclear;
  String finals;
  int tone;

  @override
  String toString(){
    return("{initial: $initial, prenuclear: $prenuclear, finals: $finals, tone: $tone}");
  }

  @override
  bool operator ==(Object other){
    if (identical(this, other)){
      return true;
    }
    return (
      other is BopomoSpelling &&
      other.runtimeType == runtimeType &&
      other.initial == initial &&
      other.finals == finals &&
      other.prenuclear == prenuclear &&
      other.tone == tone
    );
  }

  @override
  int get hashCode => Object.hash(initial, prenuclear, finals, tone);
} 
// End of file: ./lib/data/models/bopomo_spelling_model.dart
//----------------------

// File: ./lib/data/models/word_phrase_sentence_model.dart

class WordPhraseSentence {
  WordPhraseSentence({
    required this.id,
    required this.word,
    required this.phrase,
    required this.definition,
    required this.sentence,
    required this.phrase2,
    required this.definition2,
    required this.sentence2,    
  });
  
  final int id ;
  final String word;
  final String phrase;
  final String definition;
  final String sentence;
  final String phrase2;
  final String definition2;
  final String sentence2;

  // ?? What is this for? How to add word to the database?
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'word': word,
      'phrase': phrase,
      'definition': definition,
      'sentence': sentence,
      'phrase2': phrase2,
      'definition2': definition2,
      'sentence2': sentence2
    };
  }

  // Named constructor for error state
  WordPhraseSentence.error()
      : id = -1,
        word = '',
        phrase = '',
        definition = '',
        sentence = '',
        phrase2 = '',
        definition2 = '',
        sentence2 = '';

} 
// End of file: ./lib/data/models/word_phrase_sentence_model.dart
//----------------------

// File: ./lib/data/models/user_model.dart

class User {
  User({
    required this.account,
    required this.password,
    this.username = "使用者",
    required this.safetyQuestionId1,
    required this.safetyAnswer1,
    required this.safetyQuestionId2,
    required this.safetyAnswer2,
    required this.grade,
    required this.semester,
    required this.publisher,
  });

  final String account;
  String password;
  String username;
  final int safetyQuestionId1;
  final String safetyAnswer1;
  final int safetyQuestionId2;
  final String safetyAnswer2;
  int grade;
  String semester;
  String publisher;

  Map<String, dynamic> toMap() {
    return {
      'account': account,
      'password': password,
      'username': username,
      'safetyQuestionId1': safetyQuestionId1,
      'safetyAnswer1': safetyAnswer1,
      'safetyQuestionId2': safetyQuestionId2,
      'safetyAnswer2': safetyAnswer2,
      'grade': grade,
      'semester': semester,
      'publisher': publisher
    };
  }

  @override
  String toString() {
    return "User{account: $account, password: $password, username: $username, safetyQuestionId1: $safetyQuestionId1, safetyAnswer1: $safetyAnswer1, safetyQuestionId2: $safetyQuestionId2, safetyAnswer2: $safetyAnswer2, grade: $grade, semester: $semester, publisher: $publisher}";
  }
}

// End of file: ./lib/data/models/user_model.dart
//----------------------

// File: ./lib/data/models/unit_model.dart

class Unit {
  Unit({
    required this.id,
    required this.publisher,
    required this.grade,
    required this.semester,
    required this.unitId,
    required this.unitTitle,
    required this.newWords,
    required this.extraWords,
    this.unitContent=""
  });
  final int id;
  final String publisher;
  final int grade;
  final String semester;
  final int unitId;
  final String unitTitle;
  final List<String> newWords;
  final List<String> extraWords;
  String unitContent;

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'publisher': publisher,
      'grade': grade,
      'semester': semester,
      'unitId': unitId,
      'unitTitle': unitTitle,
      'newWords': newWords.join(),
      'extraWords': extraWords.join(),
      'unitContent': unitContent
    };
  }

  @override
  String toString() {
    return "Unit{id: $id, publisher: $publisher, grade: $grade, semester: $semester, unitId: $unitId, unitTitle: $unitTitle, newWords: ${newWords.toString()}, extraWords: ${extraWords.toString()}, unit_content: $unitContent}";
  }
} 
// End of file: ./lib/data/models/unit_model.dart
//----------------------

// File: ./lib/data/models/phrase_model.dart

class Phrase {
  Phrase({
    required this.id,
    required this.phrase,
    required this.definition,
    required this.sentence,
  });
  
  final int id ;
  final String phrase;
  final String definition;
  final String sentence;

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'word': phrase,
      'phoneticTone': definition,
      'phonetic': sentence
    };
  }
} 
// End of file: ./lib/data/models/phrase_model.dart
//----------------------

// File: ./lib/data/models/sound_symbol_model.dart

class SoundSymbol {
  SoundSymbol({
    required this.id,
    required this.soundSymbol
  });
  
  final int id ;
  final String soundSymbol;

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'soundSymbol': soundSymbol,
    };
  }
} 
// End of file: ./lib/data/models/sound_symbol_model.dart
//----------------------

// File: ./lib/data/models/shape_symbol_model.dart

class ShapeSymbol {
  ShapeSymbol({
    required this.id,
    required this.shapeSymbol
  });
  
  final int id ;
  final String shapeSymbol;

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'shapeSymbol': shapeSymbol,
    };
  }
} 
// End of file: ./lib/data/models/shape_symbol_model.dart
//----------------------

// File: ./lib/data/models/word_status_model.dart

class WordStatus {
  WordStatus({
    required this.id,
    required this.userAccount,
    required this.word,
    required this.learned,
    required this.liked,
  });
  
  final int id;
  final String userAccount;
  final String word;
  bool learned;
  bool liked;

  Map<String, dynamic> toMap() {
    return {
      'userAccount': userAccount,
      'word': word,
      'learned': learned ? 1 : 0,
      'liked': liked ? 1 : 0 ,
    };
  }

  Map<String, dynamic> toMapWithId() {
    return {
      'id': id,
      'userAccount': userAccount,
      'word': word,
      'learned': learned ? 1 : 0,
      'liked': liked ? 1 : 0,
    };
  }

  @override
  String toString() {
    return "WordStatus{id : $id, userAccount : $userAccount, word : $word, learned : $learned, liked: $liked}";
  }
} 
// End of file: ./lib/data/models/word_status_model.dart
//----------------------

// File: ./lib/data/models/word_model.dart

class Word {
  Word({
    required this.id,
    required this.word,
    required this.phoneticTone,
    required this.phonetic,
    required this.tone,
    required this.shapeSymbol,
    required this.soundSymbol,
    required this.strokes,
    required this.common,
  });
  
  final int id ;
  final String word;
  final String phoneticTone;
  final String phonetic;
  final int tone;
  final String shapeSymbol;
  final String soundSymbol;
  final int strokes;
  final int common;

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'word': word,
      'phoneticTone': phoneticTone,
      'phonetic': phonetic,
      'tone': tone,
      'shapeSymbol': shapeSymbol,
      'soundSymbol': soundSymbol,
      'strokes': strokes,
      'common': common,
    };
  }
} 
// End of file: ./lib/data/models/word_model.dart
//----------------------

// File: ./lib/views/safety_hint_verify_view.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/contants/register_question_label.dart';
import 'package:ltrc/data/models/user_model.dart';

import 'package:ltrc/providers.dart';
// import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';

class SafetyHintVerifyView extends ConsumerStatefulWidget {
  const SafetyHintVerifyView({super.key});

  @override
  ConsumerState<SafetyHintVerifyView> createState() => _SafetyHintVerifyState();
}

const String notAnsweredRrrorHint = "尚未回答完安全提示問題";
const String inCorrectRrrorHint = "安全提示問題回答錯誤";

class _SafetyHintVerifyState extends ConsumerState<SafetyHintVerifyView> {
  final TextEditingController a1Controller = TextEditingController();
  final TextEditingController a2Controller = TextEditingController();

  String showErrorHint = "";

  @override
  void initState() {
    showErrorHint = "";
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    
    double deviceHeight = screenInfo.screenHeight;

    dynamic obj = ModalRoute.of(context)!.settings.arguments;
    User user = obj['user'];

    String question1 = registerQuestions[user.safetyQuestionId1];
    String question2 = registerQuestions[user.safetyQuestionId2];
    String a1 = user.safetyAnswer1;
    String a2 = user.safetyAnswer2;

    return GestureDetector(
        onTap: () {
          FocusScopeNode currentFocus = FocusScope.of(context);
          if (!currentFocus.hasPrimaryFocus) {
            currentFocus.unfocus();
          }
        },
        child: Scaffold(
          appBar: AppBar(
            leading: IconButton(
              icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
              onPressed: () => Navigator.pop(context),
            ),
          ),
          resizeToAvoidBottomInset: false,
          backgroundColor: veryDarkGray,
          body: SizedBox.expand(
            child: Column(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: <Widget>[
                  SizedBox(height: deviceHeight * 0.04),
                  Text('忘記密碼',
                      style: TextStyle(
                        fontSize: fontSize * 2.7,
                      )),
                  SizedBox(height: deviceHeight * 0.015),
                  Text('請回答安全提示問題',
                      style: TextStyle(
                        fontSize: fontSize * 1.2,
                      )),
                  SizedBox(height: deviceHeight * 0.08),
                  SizedBox(
                    height: fontSize * 1.4,
                    width: fontSize * 17.8,
                    child: Text(
                      question1,
                      textAlign: TextAlign.left,
                      style: TextStyle(
                        fontSize: fontSize,
                      ),
                    ),
                  ),
                  SizedBox(height: deviceHeight * 0.01),
                  Container(
                    height: fontSize * 3.2,
                    width: fontSize * 17.8,
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                        color: lightGray,
                        borderRadius: BorderRadius.circular(5),
                        border: Border.all(
                            width: 0.1 * fontSize, color: beige)),
                    child: Padding(
                      padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                      child: TextField(
                          controller: a1Controller,
                          style: const TextStyle(
                            color: veryDarkGrayishBlue,
                          ),
                          decoration: InputDecoration(
                            hintText: '回答 1',
                            hintStyle: TextStyle(
                                fontSize: fontSize, color: deepBlue),
                            enabledBorder: InputBorder.none,
                            focusedBorder: InputBorder.none,
                          )),
                    ),
                  ),
                  SizedBox(height: deviceHeight * 0.04),
                  SizedBox(
                    height: fontSize * 1.4,
                    width: fontSize * 17.8,
                    child: Text(
                      question2,
                      textAlign: TextAlign.left,
                      style: TextStyle(
                        fontSize: fontSize,
                      ),
                    ),
                  ),
                  SizedBox(height: deviceHeight * 0.01),
                  Container(
                    height: fontSize * 3.2,
                    width: fontSize * 17.8,
                    decoration: BoxDecoration(
                        color: lightGray,
                        borderRadius: BorderRadius.circular(5),
                        border: Border.all(
                            width: 0.1 * fontSize, color: beige)),
                    child: Padding(
                      padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                      child: TextField(
                          controller: a2Controller,
                          style: const TextStyle(
                            color: veryDarkGrayishBlue,
                          ),
                          decoration: InputDecoration(
                            hintText: '回答 2',
                            hintStyle: TextStyle(
                                fontSize: fontSize, color: deepBlue),
                            enabledBorder: InputBorder.none,
                            focusedBorder: InputBorder.none,
                          )),
                    ),
                  ),
                  SizedBox(height: deviceHeight * 0.01),
                  Visibility(
                      visible: (showErrorHint != ""),
                      maintainAnimation: true,
                      maintainSize: true,
                      maintainState: true,
                      child: Container(
                          height: fontSize,
                          width: fontSize * 17.8,
                          alignment: AlignmentDirectional.topStart,
                          child: Text(showErrorHint,
                              style: TextStyle(
                                color: brightRed,
                                fontSize: fontSize * 0.8,
                              )))),
                  SizedBox(height: deviceHeight * 0.03),
                  TextButton(
                      onPressed: () {
                        if (a1Controller.text == "" ||
                            a2Controller.text == "") {
                          setState(() {
                            showErrorHint = notAnsweredRrrorHint;
                          });
                        } else if (a1Controller.text.trim() != a1 ||
                            a2Controller.text.trim() != a2) {
                          setState(() {
                            showErrorHint = inCorrectRrrorHint;
                          });
                        } else {
                          // Navigator.of(context).pushNamed('/setNewPwd', arguments: {'user': user});
                          navigateWithProvider(
                            context, 
                            '/setNewPwd', 
                            ref, 
                            arguments: {'user': user}
                          );
                              
                        }
                      },
                      child: Text('下一步',
                          style: TextStyle(
                            fontSize: fontSize * 1.4,
                            color: beige
,
                          )))
                ]),
          ),
        ));
  }
}

// End of file: ./lib/views/safety_hint_verify_view.dart
//----------------------

// File: ./lib/views/reset_pwd_account.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/data/models/user_model.dart';
import 'package:ltrc/data/providers/user_provider.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';


class ResetPwdAccountView extends ConsumerStatefulWidget {
  const ResetPwdAccountView({super.key});

  @override
  ConsumerState<ResetPwdAccountView> createState() => _ResetPwdAccountViewState();
}

const String pwdLengthErrorHint = "帳號長度不足 6 位英/數字";
const String noAccountErrorHint = "帳號輸入錯誤或不存在";

class _ResetPwdAccountViewState extends ConsumerState<ResetPwdAccountView> {
  bool showAccountHint = false;
  String showErrorHint = "";
  TextEditingController accountController = TextEditingController();

  @override
  void initState() {
    super.initState();
    showErrorHint = "";
  }

  @override
  Widget build(BuildContext context) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    
    double deviceHeight = screenInfo.screenHeight;

    return GestureDetector(
      onTap: () {
        FocusScopeNode currentFocus = FocusScope.of(context);
        if (!currentFocus.hasPrimaryFocus) {
          currentFocus.unfocus();
        }
      },
      child: Scaffold(
        appBar: AppBar(
          leading: IconButton(
            icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
            onPressed: () => Navigator.pop(context),
          ),
        ),
        resizeToAvoidBottomInset: false,
        backgroundColor: veryDarkGray,
        body: SizedBox.expand(
          child: Column(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: <Widget>[
                SizedBox(height: deviceHeight * 0.15),
                Text('忘記密碼',
                    style: TextStyle(
                      fontSize: fontSize * 2.5,
                    )),
                SizedBox(height: deviceHeight * 0.04),
                Text('請輸入帳號',
                    style: TextStyle(
                      fontSize: fontSize * 1.2,
                    )),
                SizedBox(height: deviceHeight * 0.08),
                Visibility(
                    visible: showAccountHint,
                    maintainAnimation: true,
                    maintainSize: true,
                    maintainState: true,
                    child: Container(
                        height: fontSize * 1.4,
                        width: fontSize * 17.8,
                        alignment: AlignmentDirectional.topStart,
                        child: Text('至少6個字母/數字',
                            style: TextStyle(
                              fontSize: fontSize * 0.8,
                            )))),
                Container(
                    height: fontSize * 3.5,
                    width: fontSize * 17.8,
                    decoration: BoxDecoration(
                        color: lightSkyBlue,
                        borderRadius: BorderRadius.circular(5),
                        border: Border.all(
                            width: 0.3 * fontSize, color: beige)),
                    child: Padding(
                      padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                      child: Focus(
                        onFocusChange: (hasFocus) {
                          setState(() {
                            showAccountHint = !showAccountHint;
                            if (showErrorHint == pwdLengthErrorHint &&
                                accountController.text.length >= 4) {
                              showErrorHint = "";
                            }
                          });
                        },
                        child: TextField(
                            controller: accountController,
                            style: TextStyle(
                              color: veryDarkGrayishBlue,
                              fontSize: fontSize,
                            ),
                            decoration: InputDecoration(
                              prefixIcon: Icon(
                                Icons.account_circle,
                                size: fontSize * 1.8,
                                color: veryDarkGrayishBlue,
                              ),
                              hintText: '請輸入帳號',
                              hintStyle: TextStyle(
                                  fontSize: fontSize * 1.2,
                                  color: deepBlue),
                              enabledBorder: InputBorder.none,
                              focusedBorder: InputBorder.none,
                            )),
                      ),
                    )),
                Visibility(
                    visible: (showErrorHint != ""),
                    maintainAnimation: true,
                    maintainSize: true,
                    maintainState: true,
                    child: Container(
                        height: fontSize * 1.4,
                        width: fontSize * 17.8,
                        alignment: AlignmentDirectional.topStart,
                        child: Text(showErrorHint,
                            style: TextStyle(
                              color: brightRed,
                              fontSize: fontSize * 0.8,
                            )))),
                SizedBox(height: deviceHeight * 0.0627),
                TextButton(
                    onPressed: () async {
                      try {
                        if (accountController.text.length < 6) {
                          setState(() {
                            showErrorHint = pwdLengthErrorHint;
                          });
                        } else {
                          User user = await UserProvider.getUser(
                              inputAccount: accountController.text);
                          // Navigator.of(context).pushNamed('/safetyHintVerify',arguments: {'user': user});
                          if (!context.mounted) return;
                          navigateWithProvider(
                            context, 
                            '/safetyHintVerify', 
                            ref, 
                            arguments: {'user': user}
                          );

                        }
                      } catch (e) {
                        setState(() {
                          showErrorHint = noAccountErrorHint;
                        });
                        throw ("[Reset Pwd Account] Find user account exception: $e");
                      }
                    },
                    child: Text('下一步',
                        style: TextStyle(
                          fontSize: fontSize * 1.4,
                          color: beige,
                        )))
              ]),
        ),
      ),
    );
  }
}

// End of file: ./lib/views/reset_pwd_account.dart
//----------------------

// File: ./lib/views/view_utils.dart

// view_utils.dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/contants/routes.dart';
import 'package:ltrc/providers.dart';
import 'package:stack_trace/stack_trace.dart';

// Color constants
const Color beige = Color(0xFFF5F5DC);
const Color darkBrown = Color(0xFF28231D);
const Color paleYellow = Color(0xFFF8F88E);
const Color brightRed = Color(0xFFFF0303);
const Color mediumGray = Color(0xFF999999);
const Color vibrantOrange = Color(0xFFF8A339);
const Color deepBlue = Color(0xFF013E6D);
const Color darkCyan = Color(0xFF023E6E);
const Color darkOliveGreen = Color(0xFF48742C);
const Color goldenOrange = Color(0xFFD19131);
const Color indianRed = Color(0xFFB65454);
const Color dimGray = Color(0xFF404040);
const Color veryDarkGray = Color(0xFF1E1E1E);
const Color lightSkyBlue = Color(0xFF7DDEF8);
const Color veryDarkGrayishBlue = Color(0xFF1C1B1F);
const Color warmOrange = Color(0xFFF8A23A);
const Color black = Color(0xFF000000);
const Color lightGray = Color(0xFFD9D9D9);
const Color lightYellow = Color(0xFFFFFF93);


class ScreenInfo {
  final double screenHeight;
  final double screenWidth;
  final double fontSize;
  final Orientation orientation;
  final bool isTablet;

  ScreenInfo({
    required this.screenHeight,
    required this.screenWidth,
    required this.fontSize,
    required this.orientation,
    required this.isTablet,
  });
}

class ScreenInfoNotifier extends StateNotifier<ScreenInfo> {
  ScreenInfoNotifier()
      : super(ScreenInfo(
          screenHeight: 0,
          screenWidth: 0,
          fontSize: 0,
          orientation: Orientation.portrait,
          isTablet: false,
        ));

  Timer? _debounceTimer;

  void init(BuildContext context) {
    if (_debounceTimer?.isActive ?? false) return;

    _debounceTimer = Timer(const Duration(milliseconds: 250), () {
      final mediaQuery = MediaQuery.of(context);
      double screenHeight = mediaQuery.size.height;
      double screenWidth = mediaQuery.size.width;
      double shortestSide = mediaQuery.size.shortestSide;
      Orientation orientation = mediaQuery.orientation;
      bool isTablet = shortestSide > 600;

      double baseScreenWidth = isTablet ? 600 : 360;
      double baseFontSize = isTablet ? 24.0 : 15.0;

      if (orientation == Orientation.landscape) {
        screenHeight = mediaQuery.size.shortestSide;
        screenWidth = screenHeight * 3 / 4;
      }

      double fontSize = (baseFontSize * screenWidth / baseScreenWidth).roundToDouble();

      // Only update if the state has changed
      if (screenHeight != state.screenHeight ||
          screenWidth != state.screenWidth ||
          fontSize != state.fontSize ||
          orientation != state.orientation) {
        
        final newState = ScreenInfo(
          screenHeight: screenHeight,
          screenWidth: screenWidth,
          fontSize: fontSize,
          orientation: orientation,
          isTablet: isTablet,
        );

        state = newState;
        debugPrint('ScreenInfoNotifier updated: H: $screenHeight, W: $screenWidth, F: $fontSize, $orientation, T: $isTablet');
      } else {
        debugPrint('ScreenInfoNotifier unchanged, no update necessary.');
      }
    });
  }

  @override
  void dispose() {
    _debounceTimer?.cancel();
    super.dispose();
  }

  void updateFromContext(BuildContext context) {
    init(context);
  }  
}

/* Usage of navigateWithProvider
1. No arguments to pass: mainPage needs to be defined in AppRoutes
onPressed: () => navigateWithProvider(context, '/mainPage', ref),
2. With arguments to pass: units needs to be defined in AppRoutes
onPressed: () => navigateWithProvider(
  context, 
  '/units', 
  ref, 
  arguments: {'units': units}
),
*/

void navigateWithProvider(
    BuildContext context, 
    String routeName, 
    WidgetRef ref, 
    {Map<String, dynamic>? arguments}) {
   
  // Extract the caller method using the stack_trace package
  // Only enable the following code in development mode

  if (kDebugMode) {
    String callerInfo = "";
    try {
      // Capture the current stack trace
      final stackTrace = StackTrace.current;
      // Use Trace from stack_trace package to parse it
      final trace = Trace.from(stackTrace);

      // The second frame in the trace is likely the caller method
      final frame = trace.frames[1]; // Adjust frame index as needed
      callerInfo = '${frame.member} in ${frame.library}';
    } catch (e) {
      callerInfo = "Caller unknown";
    }
    debugPrint("navigateWithProvider called by $callerInfo, to $routeName");
  }

  final screenInfo = ref.read(screenInfoProvider);
  debugPrint("navigateWithProvider screenInfo: H: ${screenInfo.screenHeight}, W: ${screenInfo.screenWidth}, F: ${screenInfo.fontSize}");

  final routes = AppRoutes.define();

  if (!routes.containsKey(routeName)) {
    debugPrint('Error: Route $routeName not found in AppRoutes.');
    return;
  }

  Navigator.of(context).push(
    MaterialPageRoute(
      builder: (context) {
        return routes[routeName]!(context);
      },
      settings: RouteSettings(name: routeName, arguments: arguments),
    ),
  ).then((_) {
      // Update screen info after navigation is complete
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (ref.read(screenInfoProvider.notifier).mounted) {
          ref.read(screenInfoProvider.notifier).updateFromContext(context);
        }
      });
      debugPrint('Navigation to $routeName completed');       
    }).catchError((error) {
      debugPrint('Error during navigation to $routeName: $error');
    }
  );
}

// End of file: ./lib/views/view_utils.dart
//----------------------

// File: ./lib/views/register_account_view.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/contants/register_question_label.dart';
import 'package:ltrc/data/providers/user_provider.dart';
// import 'package:ltrc/extensions.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';


class RegisterAccountView extends ConsumerStatefulWidget {
  const RegisterAccountView({super.key});

  @override
  ConsumerState<RegisterAccountView> createState() => _RegisterAccountViewState();
}

const String accountLengthErrorHint = "帳號長度不足 6 位英/數字";
const String pwdLengthErrorHint = "密碼長度不足 4 位英/數字";
const String pwdConfirmErrorHint = "確認密碼錯誤";
const String duplicateAccountErrorHint = "此帳號已被建立";

class _RegisterAccountViewState extends ConsumerState<RegisterAccountView> {
  bool showAccountHint = false;
  bool showPasswordHint = false;
  bool pwdVisible = false;
  bool confirmPwdVisible = false;
  String showErrorHint = "";
  TextEditingController accountController = TextEditingController();
  TextEditingController pwdController = TextEditingController();
  TextEditingController confirmPwdController = TextEditingController();
  
  // We will shortcut these security questions by using 1234
  final TextEditingController q1Controller = TextEditingController();
  final TextEditingController a1Controller = TextEditingController();
  final TextEditingController q2Controller = TextEditingController();
  final TextEditingController a2Controller = TextEditingController();
  RegisterQuestionLabel? selectedQuestion1 = RegisterQuestionLabel.pet;
  RegisterQuestionLabel? selectedQuestion2 = RegisterQuestionLabel.name;
  
  @override
  void initState() {
    super.initState();
    pwdVisible = true;
    confirmPwdVisible = true;
    showErrorHint = "";
      // Set initial text
    a1Controller.text = "1234";
    a2Controller.text = "1234";  
  }

  @override
  Widget build(BuildContext context) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    
    double deviceHeight = screenInfo.screenHeight;
    double deviceWidth = screenInfo.screenWidth;

    return GestureDetector(
      onTap: () {
        FocusScopeNode currentFocus = FocusScope.of(context);
        if (!currentFocus.hasPrimaryFocus) {
          currentFocus.unfocus();
        }
      },
      child: Scaffold(
        resizeToAvoidBottomInset: false,
        appBar: AppBar(
          backgroundColor: veryDarkGray,
          leading: IconButton(
            icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
            onPressed: () => Navigator.pop(context),
          ),
        ),
        backgroundColor: veryDarkGray,
        body: SizedBox.expand(
          child: Column(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: <Widget>[
                SizedBox(height: deviceHeight * 0.050),
                Text('學國語',
                    style: TextStyle(
                      color: beige,
                      fontSize: deviceWidth * 46 / 360,
                    )),
                SizedBox(height: deviceHeight * 0.050),
                Visibility(
                    visible: showAccountHint,
                    maintainAnimation: true,
                    maintainSize: true,
                    maintainState: true,
                    child: Container(
                        height: fontSize * 1.4,
                        width: deviceWidth * 5 / 6,
                        alignment: AlignmentDirectional.topStart,
                        child: Text('至少6個字母/數字',
                            style: TextStyle(
                              color: beige,
                              fontSize: fontSize * 0.8,
                            )))),
                Container(
                  height: fontSize * 3.5,
                  width: deviceWidth * 5 / 6,
                  decoration: BoxDecoration(
                      color: lightSkyBlue,
                      borderRadius: BorderRadius.circular(5),
                      border: Border.all(
                          width: 0.3 * fontSize, color: beige)),
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                    child: Focus(
                      onFocusChange: (hasFocus) {
                        setState(() {
                          showAccountHint = !showAccountHint;
                          if (showErrorHint == accountLengthErrorHint &&
                              accountController.text.length >= 6) {
                            showErrorHint = "";
                          }
                        });
                      },
                      child: TextField(
                          controller: accountController,
                          style: TextStyle(
                              color: veryDarkGrayishBlue, fontSize: fontSize),
                          decoration: InputDecoration(
                            prefixIcon: Icon(
                              Icons.account_circle,
                              size: fontSize * 1.8,
                              color: veryDarkGrayishBlue,
                            ),
                            hintText: '帳號名稱',
                            hintStyle: TextStyle(
                                fontSize: fontSize * 1.2,
                                color: deepBlue),
                            focusedBorder: InputBorder.none,
                            enabledBorder: InputBorder.none,
                          )),
                    ),
                  ),
                ),
                SizedBox(height: deviceHeight * 0.012),
                Visibility(
                    visible: showPasswordHint,
                    maintainAnimation: true,
                    maintainSize: true,
                    maintainState: true,
                    child: Container(
                        height: fontSize * 1.4,
                        width: deviceWidth * 5 / 6,
                        alignment: AlignmentDirectional.topStart,
                        child: Text('至少4個數字',
                            style: TextStyle(
                              color: beige,
                              fontSize: fontSize * 0.8,
                            )))),
                Container(
                    height: fontSize * 3.5,
                    width: deviceWidth * 5 / 6,
                    decoration: BoxDecoration(
                        color: lightSkyBlue,
                        borderRadius: BorderRadius.circular(5),
                        border: Border.all(
                            width: 0.3 * fontSize,
                            color: beige)),
                    child: Padding(
                      padding:
                          const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                      child: Focus(
                        onFocusChange: (hasFocus) {
                          setState(() {
                            showPasswordHint = !showPasswordHint;
                            if (showErrorHint == pwdLengthErrorHint &&
                                pwdController.text.length >= 4) {
                              showErrorHint = "";
                            }
                          });
                        },
                        child: TextField(
                            controller: pwdController,
                            obscureText: pwdVisible,
                            style: TextStyle(
                                color: veryDarkGrayishBlue,
                                fontSize: fontSize),
                            decoration: InputDecoration(
                              prefixIcon: Icon(
                                Icons.lock,
                                size: fontSize * 1.8,
                                color: veryDarkGrayishBlue,
                              ),
                              hintText: '密碼',
                              hintStyle: TextStyle(
                                  fontSize: fontSize * 1.2,
                                  color: deepBlue),
                              focusedBorder: InputBorder.none,
                              enabledBorder: InputBorder.none,
                              suffixIcon: IconButton(
                                icon: Icon(pwdVisible
                                    ? Icons.visibility
                                    : Icons.visibility_off),
                                iconSize: fontSize,
                                onPressed: () {
                                  setState(() {
                                    pwdVisible = !pwdVisible;
                                  });
                                },
                              ),
                            )),
                      ),
                    )),
                SizedBox(height: deviceHeight * 0.0343),
                Container(
                  height: fontSize * 3.5,
                  width: deviceWidth * 5 / 6,
                  decoration: BoxDecoration(
                      color: lightSkyBlue,
                      borderRadius: BorderRadius.circular(5),
                      border: Border.all(
                          width: 0.3 * fontSize, color: beige)),
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                    child: TextField(
                        controller: confirmPwdController,
                        obscureText: confirmPwdVisible,
                        style: TextStyle(
                            color: veryDarkGrayishBlue, fontSize: fontSize),
                        decoration: InputDecoration(
                          prefixIcon: Icon(
                            Icons.lock,
                            size: fontSize * 1.8,
                            color: veryDarkGrayishBlue,
                          ),
                          hintText: '確認密碼',
                          hintStyle: TextStyle(
                              fontSize: fontSize * 1.2,
                              color: deepBlue),
                          enabledBorder: InputBorder.none,
                          focusedBorder: InputBorder.none,
                          suffixIcon: IconButton(
                            icon: Icon(confirmPwdVisible
                                ? Icons.visibility
                                : Icons.visibility_off),
                            iconSize: fontSize,
                            onPressed: () {
                              setState(() {
                                confirmPwdVisible = !confirmPwdVisible;
                              });
                            },
                          ),
                        )),
                  ),
                ),
                SizedBox(height: deviceHeight * 0.012),
                Visibility(
                    visible: (showErrorHint != ""),
                    maintainAnimation: true,
                    maintainSize: true,
                    maintainState: true,
                    child: Container(
                        height: fontSize * 1.4,
                        width: deviceWidth * 5 / 6,
                        alignment: AlignmentDirectional.topStart,
                        child: Text(showErrorHint,
                            style: TextStyle(
                              color: brightRed,
                              fontSize: fontSize * 0.8,
                            )))),
                Consumer(builder: (context, ref, child) {
                  return TextButton(
                      onPressed: () async {
                        if (accountController.text.length < 6) {
                          setState(() {
                            showErrorHint = accountLengthErrorHint;
                          });
                        } else {
                          List<String> userAccounts =
                              await UserProvider.getAllUserAccounts();
                          if (userAccounts.contains(accountController.text)) {
                            setState(() {
                              showErrorHint = duplicateAccountErrorHint;
                            });
                          } else if (pwdController.text.length < 4) {
                            setState(() {
                              showErrorHint = pwdLengthErrorHint;
                            });
                          } else if (pwdController.text !=
                              confirmPwdController.text) {
                            setState(() {
                              showErrorHint = pwdConfirmErrorHint;
                            });
                          } else {
                            ref.read(accountProvider.notifier).state =
                                accountController.text;
                            ref.read(pwdProvider.notifier).state =
                                pwdController.text;
                            if (!context.mounted) return;
                            // Navigator.of(context).pushNamed('/safetyHintRegister');
                            // navigateWithProvider(context, '/safetyHintRegister', ref);
                            navigateWithProvider(
                              context, 
                              '/register', 
                              ref, 
                              arguments: {
                              'q1': selectedQuestion1?.value,
                              'a1': a1Controller.text,
                              'q2': selectedQuestion2?.value,
                              'a2': a2Controller.text,
                            });                              
                          }
                        }
                      },
                      child: Text('下一步',
                          style: TextStyle(
                            fontSize: fontSize * 1.4,
                            color: beige,
                          )));
                })
              ]),
        ),
      ));

  }
}

// End of file: ./lib/views/register_account_view.dart
//----------------------

// File: ./lib/views/polyphonic_processor.dart

// polyphonic_processor.dart
// import 'dart:convert';
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
// import 'package:path/path.dart';
// import 'package:path/path.dart';
import 'package:tuple/tuple.dart';

import 'package:ltrc/data/models/word_model.dart';
import 'package:ltrc/data/providers/word_provider.dart';

class PolyphonicProcessor {
  late Map<String, dynamic> _polyphonicData;
  String spansUnicode = '';
  // bool skipPrev = false;  moved to process function
  RegExp chineseCharRegex = RegExp(r'[\u4e00-\u9fa5]');

  static final PolyphonicProcessor _instance = PolyphonicProcessor._internal();

  PolyphonicProcessor._internal();

  static PolyphonicProcessor get instance => _instance;

  Future<void> loadPolyphonicData() async {
    try {
      String jsonString = await rootBundle.loadString('assets/data_files/poyin_db.json');
      Map<String, dynamic> polyphonicData = json.decode(jsonString);

      if (!polyphonicData.containsKey('data')) {
        throw Exception('Polyphonic data is improperly formatted or missing key data');
      }

      _polyphonicData = removeComments(polyphonicData);

      // debugPrint('Polyphonic data loaded successfully');
    } catch (e) {
      // debugPrint('Failed to load polyphonic data: $e');
      throw Exception('Failed to load polyphonic data: $e');
    }
  }

  Map<String, dynamic> removeComments(Map<String, dynamic> data) {
    Map<String, dynamic> filteredData = {};
    data.forEach((key, value) {
      if (key != '_comment') {
        if (value is Map<String, dynamic>) {
          filteredData[key] = removeComments(value);
        } else if (value is List) {
          filteredData[key] = value.map((item) {
            if (item is Map<String, dynamic>) {
              return removeComments(item);
            }
            return item;
          }).toList();
        } else {
          filteredData[key] = value;
        }
      }
    });
    return filteredData;
  }

  TextStyle getCharPolyStyle(double fontSize, Color color, String newSs, bool highlightOn) {
    return TextStyle(
      fontFamily: 'BpmfIansui',
      fontSize: fontSize,
      color: highlightOn ? Colors.black : color,
      background: highlightOn ? (Paint()..color = Colors.yellow) : (null),
      fontFeatures: [FontFeature.enable(newSs)]
    );
  }

  TextStyle getCharStyle(double fontSize, Color color, bool highlightOn) {
    return TextStyle(
      fontFamily: 'BpmfIansui',
      fontSize: fontSize,
      color: color,
      background: null,
    );
  }

  // output: 1, 2, 3, 4, 5. If error, return 0
  Future<int> getToneForChar(String char) async {
    if (!RegExp(r'[\u4e00-\u9fff]').hasMatch(char)) {
      // Skip if char is not a Chinese character. This check is needed because of prevChar might be null
      return 0; // ?? Default tone for non-Chinese characters or null input
    }    
    try {
      Word word = await WordProvider.getWord(inputWord: char);
      return word.tone;
    } catch (e) {
      // debugPrint('Error fetching tone for character $char: $e');
      // Return a default tone in case of an error
      return 0; // ?? default is not necessary 1, e.g., 不 is 4
    }
  }

  /* 以下處理一、不的方法是基於 jeffreyxuan 的原始碼 https://github.com/jeffreyxuan/toneoz-font-zhuyin/blob/main/src/js/ybtone.js
  同時也請參考教育部國語辭典說明：https://dict.concised.moe.edu.tw/page.jsp?ID=55，以下是摘錄：及例外說明。
  A：“一”有三個音：一聲、二聲、四聲。default 是一聲，用"0000" 代表。二聲，用 "ss01" 代表，四聲，用 "ss02" 代表。
  在以下三種情況，應將「一」讀作原調一聲：
  1. 單唸 e.g. 一
  2. 詞尾 e.g. 純一、萬一、星期一
  3. 表示序數時 e.g. 一九九一、第一座
  除以上特別情況，其餘有「一」字的詞語大都需要變調。
  4. 如果「一」字在第一聲、第二聲或第三聲的字前，需將「一」字讀第四聲。 e.g. 一天(tiān)、一年(nián)、一起(xĭ)
  5. 如果「一」字在第四聲的字前，需將「一」字讀第二聲。 e.g. 一定(dìng)、一片(piàn)、一樣(yàng)
  6. 但是還是有很多例外狀況，例如“一個”、“一會”、“一切”，用 specialYiCases 處理。另外，有一部份直接寫進
     code 裡面，例如：一對、一次、一家、某一領域、一層、一名等等。

  B：“不”在 IanSui 裡面有四個音：bu4、bu2、fou、fu。（但是教育部是：bu4、fou3、fou、fu。）
  default 是四聲，用"0000" 代表。二聲，用 "ss01" 代表，fou，用 "ss02"，fu 用 “ss03” 代表。
  在以下三種情況，應將「不」讀作原調四聲：
  1. 單唸 e.g. 不
  2. 詞尾 e.g. 從不、絕不
  3. 在第一聲、第二聲、第三聲或第五聲的字前 e.g. 不該(gāi)、不來(lái)、不管(guăn)
  除以上特別情況，其餘有「不」字的詞語大都需要變調。  
  4. 如果「不」字在第四聲的字前，需將「不」字讀第二聲。 e.g. 不要(yào)、不用(yòng)、不對(dùi)
  5. 如果「不」字在第二聲的字前，需將「不」字讀第四聲。 e.g. 不同(tóng)、不對(dùi)、不足(zú)
  6. 但是還是有很多例外狀況，例如“不禁”、“不菲”、“不勝”、“不著”，用 specialBuCases 處理。另外，有一部份直接寫進
     code 裡面，例如：不好、不一樣、不一定、不一會

  處理“一”和“不”的多音字時，先處理詞尾（例如：統一、絕不），再處理特殊情況（例如：一個、不禁），最後處理一般情況。   

  C：教育部國語辭典（https://dict.concised.moe.edu.tw/page.jsp?ID=55） 裡有提到兩個變調：輕聲變調 和 其他。
  1. 輕聲變調：單字不具輕聲字音，複詞最末音節在口語中變讀為輕聲字音時，先標本調字音，再以（變）標示輕聲字音。它用
     【葫蘆】為例：ㄏㄨˊ　ㄌㄨˊ（變）ㄏㄨˊ　˙ㄌㄨ。
     問題是：IanSui 字體不支援輕聲字音˙ㄌㄨ，因此，這裡不處理輕聲字音。
  2. 其他：部分詞語在口語中有明顯變調情形時，先標本調字音，再以（變）標示變調字音。例如：
     【嗶嗶剝剝】：ㄅㄧˋ　ㄅㄧˋ　ㄅㄛ　ㄅㄛ（變）ㄅㄧ　ㄅㄧ　ㄅㄛ　ㄅㄛ
     問題是：IanSui 字體不支援一聲字音ㄅㄧ，因此，這裡不處理一聲字音。
  上面兩種情況的例子應該很多。若有人提出，再看如何處理，目前先不再花時間考慮。
  */

  Tuple3<String, bool, bool> getNewToneForYiBu({ // String: newSs, bool: skipNext, bool: skipPrev
      String? prevChar,
      required String currentChar,
      String? nextChar,
      int? prevTone,
      int? nextTone,
      required bool skipPrev,
  }) {

      final Set<String> prevCharSet1 = {
        '第', '説', '说', '唯', '惟', '统', '統', '独', '獨', '劃', '划', '萬', '專', '某',
        '十', '九', '八', '七', '六', '五', '四', '三', '二', '一', '〇', '零'
      };

      final Set<String> nextCharSet1 = {
        // 前面兩列是Jeff原來的 code
        '是', '日', '月', '的', '或', '物', '片', '系', 
        // 下一個字是數詞
        '十', '九', '八', '七', '六', '五', '四', '三', '二', '一', '〇', '零', '百', '千', '萬',        
        // 下一個字二聲，但是「一」念一聲
        '元', '則', '節', '台', '同', '名', '回', '堂', '層', '幅', '幢', '年', '息', '成', '排', '提', 
        '搏', '擊', '擲', '旁', '時', '枚', '格', '條', '樓', '流', '環', '篇', '級', '群', '言', '連', 
        '門', '間', 
        // 我查教育部辭典查到，下面的詞尾，「一」念一聲
        '天', '經', '方', '對', '次', '家', '鳴', '命', '份', '件', '尊', '聲', '歲', '副', '本', '批',
      };    
      // debugPrint('getNewToneForYiBu: prevChar: $prevChar, currentChar: $currentChar, nextChar: $nextChar, prevTone: $prevTone, nextTone: $nextTone');
      const Map<String, Tuple3<String, bool, bool>> specialYiCases = {
        '個': Tuple3("0000", false, false), // 個平常是四聲，一個的個要念輕聲，一念一聲，個這個字下一次處理
        '个': Tuple3("0000", false, false), // 個平常是四聲，一个的个要念輕聲，一念一聲，个這個字下一次處理
        '會': Tuple3("0000", false, false), // 會平常是四聲，一會的會要念“悔”三聲，一念一聲，會這個字下一次處理
        '切': Tuple3("0000", false, false), // 切平常是一聲，一切的切念四聲，一念一聲，切這個字下一次處理
        '不': Tuple3("0000", true, true),   // 不平常是四聲，“一不”念ㄧ ㄅㄨˋ，不需要再處理上一個及下一個字
      };

      const Map<String, Tuple3<String, bool, bool>> specialBuCases = {
        '禁': Tuple3("0000", false, false), // 禁平常是四聲，不禁的禁要念一聲，不念四聲，禁這個字下一次處理
        '菲': Tuple3("0000", false, false), // 菲平常是一聲，不菲的菲要念三聲，不念四聲，菲這個字下一次處理
        '勝': Tuple3("0000", false, false), // 勝平常是四聲，不勝的勝要念一聲，不念四聲，勝這個字下一次處理
        '著': Tuple3("0000", false, false), // 著平常是一聲，不著的著要念二聲，不念四聲，著這個字下一次處理
        '了': Tuple3("0000", false, false), // 了平常是輕聲，在“吃不了"時，念三聲，不念四聲，了這個字下一次處理
        '好': Tuple3("0000", false, false), // 在處理“不好好學習”時，第二個好跟後面的學會念成四聲hao4xue2，錯了。因此，要特別處理
        '假': Tuple3("0000", false, false), // 假平常是四聲，不假的假要念三聲，不念四聲，假這個字下一次處理
        '當': Tuple3("ss01", false, false), // 當平常是一聲，不當的當要念四聲，不念二聲，當這個字下一次處理
      };

      if (currentChar == '一') {
        // Check prevChar conditions, then nextChar special conditions, then general cases
        if ((!skipPrev) && (prevChar == null || prevCharSet1.contains(prevChar))) {
          // debugPrint('$prevChar一，"一"發一聲，下一個字“$nextChar”要再處理, skipPrev: true');
          return const Tuple3("0000", false, true); // Use the default, First tone; skipNext false; skipPrev true
        } else if (specialYiCases.containsKey(nextChar)) {
          // debugPrint('一$nextChar，"一"發一聲，下一個字“$nextChar”要再處理');
          return specialYiCases[nextChar]!; // Use the default, First tone; skipNext false; skipPrev false
        } else if (nextChar == null || nextChar.isEmpty || nextCharSet1.contains(nextChar)) {
          // debugPrint('一$nextChar，"一"發一聲，$nextChar發預設值，不再處理上一個及下一個字');
          return const Tuple3("0000", true, true); // Use the default, First tone, and skipNext true; skipPrev true
        } else if (prevChar == nextChar || 
            ['看', '聽', '寫', '用', '說', '動', '搖', '問'].contains(nextChar)) {
          // debugPrint('$prevChar一$nextChar，"一"發一聲，$prevChar 跟 $nextChar 發本調，不再處理上一個及下一個字');
          return const Tuple3("0000", true, true); // Use the default, First tone, and skipNext true; skipPrev true          
        } else if (nextTone != null && (nextTone == 1 || nextTone == 2 || nextTone == 3)) {
          return const Tuple3("ss02", true, true); // Use the fourth tone, and skipNext true; skipPrev true
        } else if (nextTone != null && nextTone == 4) {
          return const Tuple3("ss01", true, true); // Use the second tone, and skipNext true; skipPrev true
        } else {
          return const Tuple3("0000", false, true); // Default to first tone if no other conditions match; skipNext false; skipPrev true
        }          
      } else if (currentChar == '不') {
        // debugPrint('Processing 不. nextChar $nextChar, nextTone $nextTone, prevChar $prevChar, prevTone $prevTone');

        if (specialBuCases.containsKey(nextChar)) {
          // debugPrint('不$nextChar，不 四聲，$nextChar 特殊聲調');
          return specialBuCases[nextChar]!;
        }

        if (nextTone != null &&
            (nextTone == 1 || nextTone == 2 || nextTone == 3 || nextTone == 5)) {
          // debugPrint('“不$nextChar”, 不發四聲，nextSkip: false, prevSkip: true');
          return const Tuple3("0000", false, true); // Remain 四聲
        } else if (nextTone != null && nextTone == 4) {
          // debugPrint('Returning second tone for 不 based on nextTone');
          return const Tuple3("ss01", true, true); // Change to second tone
        } else {
          // debugPrint('Returning default 四聲 for 不');
          return const Tuple3("0000", false, true); // Default to 四聲 if no other conditions match
        }          
      }
      // debugPrint('Error: not 一 nor 不. $currentChar');
      return const Tuple3("0000", false, false); // Default case
  }


  Future<Tuple2<List<TextSpan>, String>> process(String text, double fontSize, Color color, bool highlightOn) async {
      List<TextSpan> spans = [];
      String spansUnicode = '';
      List<String> characters = text.split('');
      int length = characters.length; // Cache the length for better performance
      bool skipPrev = false; // Flag to skip the previous character processing
      var ssMapping = {
          "ss01": "E01E1",
          "ss02": "E01E2",
          "ss03": "E01E3",
          "ss04": "E01E4",
          "ss05": "E01E5",
      };
      final Map<String, String> specialDoubleCharacters = {
        '一一': 'ss00', // “一”在前面已處理，不會在這裡用到
        '仆仆': 'ss01',
        '便便': 'ss01',
        '剌剌': 'ss01',
        '厭厭': 'ss01',
        '呀呀': 'ss01',
        '呱呱': 'ss00',
        '咯咯': 'ss01',
        '啞啞': 'ss01',
        '啦啦': 'ss01',
        '喔喔': 'ss00',
        '嗑嗑': 'ss01',
        '嚇嚇': 'ss01',
        '好好': 'ss00', // 不好好學習
        '從從': 'ss03',
        '怔怔': 'ss01',
        '悶悶': 'ss01',
        '擔擔': 'ss01',
        '數數': 'ss01',
        '施施': 'ss01',
        '晃晃': 'ss01', // '白晃晃','明晃晃','亮晃晃','精晃晃','油晃晃' 用三聲；晃晃悠悠、晃晃蕩蕩、搖搖晃晃用四聲，default
        '朴朴': 'ss02',
        '棲棲': 'ss01',
        '殷殷': 'ss01',
        '比比': 'ss01',
        '泄泄': 'ss01',
        '洩洩': 'ss01',
        '湛湛': 'ss00',
        '湯湯': 'ss01',
        '濕濕': 'ss02',
        '濟濟': 'ss01',
        '濺濺': 'ss01',
        '父父': 'ss02',
        '種種': 'ss00',
        '答答': 'ss01',
        '粥粥': 'ss02',
        '累累': 'ss01',
        '繆繆': 'ss02',
        '脈脈': 'ss01',
        '菲菲': 'ss00',
        '蔚蔚': 'ss01',
        '藉藉': 'ss01',
        '虎虎': 'ss01',
        '處處': 'ss01',
        '蛇蛇': 'ss01',
        '行行': 'ss00', // 行行重行行/行行好事，行行出狀元，行行如也，念法都不同。再特別處理。
        '褶褶': 'ss01', // 褶褶有兩個念法：die2die2，zhe3zhe3，目前只處理die2die2
        '逮逮': 'ss00', 
        '那那': 'ss01',                
        '重重': 'ss01', // 重重的，重重阻礙，念法不同。再特別處理。
        '銻銻': 'ss02',
        '鰓鰓': 'ss01',
        '個個': 'ss00', // 個個或一個個，都發四聲，因此需要提前處理。
        '个个': 'ss00',
        '大大': 'ss00',
        '方方': 'ss00', 
        '喏喏': 'ss00',
      };      
      // "多"會造成下面句子很難判斷，因此特別處理。”他任內完成了許多重要工作。“，”壓力很大，要從多重管道接觸客戶。“      
      final List<String> duoCommonPhrases = ['許多', '很多', '大多', '眾多', '太多', '極多', '何多', '沒多', '甚多', '更多', '幾多',/* Add more common phrases here if needed */];      

      for (int i = 0; i < length; i++) {
          String character = characters[i];
          String hexUnicode = character.runes.first.toRadixString(16).toUpperCase();
          String nextChar = (i + 1 < length) ? characters[i + 1] : '';
          String next2Char = (i + 2 < length) ? characters[i + 2] : '';
          String next3Char = (i + 3 < length) ? characters[i + 3] : '';
          String prevChar = (i > 0) ? characters[i - 1] : '';
          // debugPrint("prevChar: $prevChar, curChar: $character, nextChar: $nextChar");          
          bool skipPrevTemp = skipPrev; // Save the current skipPrev value
          skipPrev = false; // Reset skipPrev for the next character          
          // debugPrint('Processing character: $character at index $i, skipPrev: $skipPrevTemp');

          if (!chineseCharRegex.hasMatch(character)) {
              // debugPrint('Not a Chinese character: $character');
              spans.add(TextSpan(text: character, style: TextStyle(fontSize: fontSize, color: color)));
              spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
              skipPrev = true; // 非中文字，處理下一個字時，不需要回頭看
              continue;
          }

          if (character == '一' || character == '不') { // Special handle for 一 and 不
            // Handle special cases for "一“ and "不" where the third character is a polyphonic character
            if (character == '一') { // 一部、一部分、一會、一會兒
                if (nextChar == '部') { 
                    // Handle "一部" with default tone for both "一" and "部"
                    spans.add(TextSpan(text: character, style: getCharStyle(fontSize, color, highlightOn))); // Default for "一"
                    hexUnicode = character.runes.first.toRadixString(16).toUpperCase();
                    spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));

                    spans.add(TextSpan(text: nextChar, style: getCharStyle(fontSize, color, highlightOn))); // Default for "部"
                    hexUnicode = nextChar.runes.first.toRadixString(16).toUpperCase();
                    spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));

                    if (next2Char == '分') {
                        // Handle "一部分" with 四聲 for "分"
                        String styleSet = 'ss01'; // 四聲 for "分"
                        spans.add(TextSpan(text: next2Char, style: getCharPolyStyle(fontSize, color, styleSet, highlightOn)));
                        hexUnicode = next2Char.runes.first.toRadixString(16).toUpperCase();
                        spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
                        spansUnicode += String.fromCharCode(int.parse(ssMapping[styleSet]!.substring(0, 5), radix: 16));

                        i += 2; // Skip the next 2 characters
                    } else {
                        i += 1; // Skip the next character
                    }
                    continue;
                } else if (nextChar == '會') {
                    // Handle "一會" with default tone for "一" and 三聲 for "會"
                    spans.add(TextSpan(text: character, style: getCharStyle(fontSize, color, highlightOn))); // Default for "一"
                    hexUnicode = character.runes.first.toRadixString(16).toUpperCase();
                    spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));

                    String styleSet = 'ss02'; // 三聲 for "會"
                    spans.add(TextSpan(text: nextChar, style: getCharPolyStyle(fontSize, color, styleSet, highlightOn)));
                    hexUnicode = nextChar.runes.first.toRadixString(16).toUpperCase();
                    spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
                    spansUnicode += String.fromCharCode(int.parse(ssMapping[styleSet]!.substring(0, 5), radix: 16));                    

                    if (next2Char == '兒') {
                        String styleSet = 'ss01'; // 一會兒，輕聲 for "兒"
                        spans.add(TextSpan(text: next2Char, style: getCharPolyStyle(fontSize, color, styleSet, highlightOn)));
                        hexUnicode = next2Char.runes.first.toRadixString(16).toUpperCase();
                        spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
                        spansUnicode += String.fromCharCode(int.parse(ssMapping[styleSet]!.substring(0, 5), radix: 16));

                        i += 2; // Skip the next 2 characters
                    } else {
                        i += 1; // Skip the next character
                    }
                    continue;
                }
            }

            if (character == '不') { // 不得不、不一定
                if (nextChar == '得' && next2Char == '不') {
                    // Handle "不得不" 都是用 default tone
                    for (String char in [character, nextChar, next2Char]) {
                        spans.add(TextSpan(text: char, style: getCharStyle(fontSize, color, highlightOn)));
                        hexUnicode = char.runes.first.toRadixString(16).toUpperCase();
                        spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
                    }                
                    i += 2; // Skip the next 2 characters 
                    skipPrev = true; // This is a complete phrase, so when processing the next character, we don't have to look back
                    continue;
                } else if (nextChar == '一' && next2Char == '定') {
                    // Handle "不一定"
                    spans.add(TextSpan(text: character, style: getCharStyle(fontSize, color, highlightOn))); // Default for "不"
                    hexUnicode = character.runes.first.toRadixString(16).toUpperCase();
                    spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));

                    String styleSet = 'ss01'; // 二聲 for "一"
                    spans.add(TextSpan(text: nextChar, style: getCharPolyStyle(fontSize, color, styleSet, highlightOn)));
                    hexUnicode = nextChar.runes.first.toRadixString(16).toUpperCase();
                    spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
                    spansUnicode += String.fromCharCode(int.parse(ssMapping[styleSet]!.substring(0, 5), radix: 16));

                    spans.add(TextSpan(text: next2Char, style: getCharStyle(fontSize, color, highlightOn))); // Default for "定"
                    hexUnicode = next2Char.runes.first.toRadixString(16).toUpperCase();
                    spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
                    
                    i += 2; // Skip the next 2 characters 
                    skipPrev = true; // This is a complete phrase, so when processing the next character, we don't have to look back
                    continue;
                }
            }

            int prevTone = (i > 0) ? await getToneForChar(prevChar) : 0; // 0: error
            int nextTone = (i + 1 < length) ? await getToneForChar(nextChar) : 0; // 0: error
            // debugPrint("prevChar: $prevChar, prevTone: $prevTone; nextChar: $nextChar, nextTone: $nextTone");
            var result = getNewToneForYiBu(
                prevChar: prevChar,
                currentChar: character,
                nextChar: nextChar,
                prevTone: prevTone,
                nextTone: nextTone,
                skipPrev: skipPrevTemp,
            );

            String newSs = result.item1;
            bool skipNext = result.item2;
            skipPrev = result.item3; // 一* 或 *一，或 不*, 在處理下一個字時，都不需要回頭看
            // debugPrint("newSs for $character: $newSs, skipNext: $skipNext, skipPrev: $skipPrev");
            spans.add(TextSpan(text: character, style: newSs == "0000" ? getCharStyle(fontSize, color, highlightOn) : getCharPolyStyle(fontSize, color, newSs, highlightOn)));
            spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
            if (newSs != "0000") {
                spansUnicode += String.fromCharCode(int.parse(ssMapping[newSs]!.substring(0, 5), radix: 16));
            }
            
            if (skipNext && i + 1 < length) {
              String nextHexUnicode = nextChar.runes.first.toRadixString(16).toUpperCase();
              spans.add(TextSpan(text: nextChar, style: getCharStyle(fontSize, color, highlightOn))); // Add next character
              spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
              // debugPrint("Skipping nextChar $nextChar at index: ${i + 1}");
              i += 1; // Skip the next character since it's part of the phrase
              continue; // Skip to the next loop iteration to avoid processing the skipped character again
            }      
          } else {  // 非“一”或“不”的多音字處理

            var charData = _polyphonicData['data'][character];

            if (charData != null) {
              // Check for special double characters. For single character, call "match" function
              // 個個或一個個，都發四聲，因此需要提前處理。
              // 目前的 code 可以處理下面的情況：個個都是英雄好漢，一個個都是美女，他是個性情中人。但是無法處理下面的情況：
              // 一個個性溫柔的人，他是個個性溫柔的人。需要把這兩句改成：一位個性溫柔的人，他是位個性溫柔的人。              
              String pair = character + nextChar;
              int setNextBpmf = 0;
              String next2CharStyleSet = '';
              String next3CharStyleSet = '';
              
              if (specialDoubleCharacters.containsKey(pair)) {
                String nextPair = next2Char + next3Char;
                String styleSet = specialDoubleCharacters[pair]!;
                if (pair == '重重' && next2Char == '的') {  // 重重的，重發四聲，
                  styleSet = 'ss00';
                  setNextBpmf = 1; // 加速處理'的'
                } else if (pair == '行行') {
                  if (nextPair == '出狀') {
                    styleSet = 'ss01';
                    setNextBpmf = 2; // 加速處理'出狀'
                  } else if (nextPair == '重行') {
                    styleSet = 'ss00'; // 行行重行, 重是二聲，需特別處理
                    setNextBpmf = 2; // 加速處理'重行'
                    next2CharStyleSet = 'ss01'; // 重行重行，行是四聲，需特別處理
                  } else if (nextPair == '如也') {
                    styleSet = 'ss03';
                    setNextBpmf = 2; // 加速處理'如也'
                  }
                } else if (pair == '呱呱' && (nextPair == '墜地' || nextPair == '墮地' || nextPair == '而泣')) {  // 哇哇墜地，呱呱而泣ad個發四聲，
                  styleSet = 'ss01';
                  setNextBpmf = 2; // 加速處理'墜地'、'墮地'、'而泣'                  
                } else if (pair == '晃晃') {
                  if (['白','明','亮','精','油'].contains(prevChar)) {
                    styleSet = 'ss01'; // 白晃晃、明晃晃、亮晃晃、精晃晃、油晃晃 都念三聲
                  } else { // 晃晃悠悠、晃晃蕩蕩、搖搖晃晃 都念四聲，default
                    styleSet = 'ss00'; //
                  }
                  setNextBpmf = 0;

                }

                String nextHexUnicode = nextChar.runes.first.toRadixString(16).toUpperCase();
                // debugPrint("$pair: applied style $styleSet");
                if (styleSet == 'ss00') {
                  // For 'ss00' style set, use the default getCharStyle
                  spans.add(TextSpan(text: nextChar, style: getCharStyle(fontSize, color, highlightOn)));
                  spans.add(TextSpan(text: nextChar, style: getCharStyle(fontSize, color, highlightOn)));
                  spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
                  spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
                } else {
                  // For other style sets, use getCharPolyStyle
                  spans.add(TextSpan(text: nextChar, style: getCharPolyStyle(fontSize, color, styleSet, highlightOn)));
                  spans.add(TextSpan(text: nextChar, style: getCharPolyStyle(fontSize, color, styleSet, highlightOn)));
                  spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
                  spansUnicode += String.fromCharCode(int.parse(ssMapping[styleSet]!.substring(0, 5), radix: 16));
                  spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
                  spansUnicode += String.fromCharCode(int.parse(ssMapping[styleSet]!.substring(0, 5), radix: 16));
                }
                i += 1; // Skip the next character since it's part of the phrase
                skipPrev = true; // 這是一個完整的詞語，所以在處理下一個字時，不需要回頭看

                switch (setNextBpmf) { // 加速處理下面二、三個字
                  case 0:
                    // Skip this iteration if setNextBpmf == 0
                    break;

                  case 1: // next2Char 用 default
                    spans.add(TextSpan(text: next2Char, style: getCharStyle(fontSize, color, highlightOn)));
                    nextHexUnicode = next2Char.runes.first.toRadixString(16).toUpperCase();
                    spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
                    // debugPrint('Fast processing $next2Char using default at index: ${i + 1}');
                    i += 1;
                    break;

                  case 2: // 依 next2CharStyleSet，next2Char 用 default, 或用 next2CharStyleSet
                          // 依 next3CharStyleSet，next3Char 用 default, 或用 next3CharStyleSet
                    if (next2CharStyleSet == '') {
                      spans.add(TextSpan(text: next2Char, style: getCharStyle(fontSize, color, highlightOn)));
                      nextHexUnicode = next2Char.runes.first.toRadixString(16).toUpperCase();
                      spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
                    } else {
                      spans.add(TextSpan(text: next2Char, style: getCharPolyStyle(fontSize, color, next2CharStyleSet, highlightOn)));
                      nextHexUnicode = next2Char.runes.first.toRadixString(16).toUpperCase();
                      spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
                      spansUnicode += String.fromCharCode(int.parse(ssMapping[next2CharStyleSet]!.substring(0, 5), radix: 16));
                    }
                    if (next3CharStyleSet == '') {
                      spans.add(TextSpan(text: next3Char, style: getCharStyle(fontSize, color, highlightOn)));
                      nextHexUnicode = next3Char.runes.first.toRadixString(16).toUpperCase();
                      spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
                    } else {
                      spans.add(TextSpan(text: next3Char, style: getCharPolyStyle(fontSize, color, next3CharStyleSet, highlightOn)));
                      nextHexUnicode = next3Char.runes.first.toRadixString(16).toUpperCase();
                      spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
                      spansUnicode += String.fromCharCode(int.parse(ssMapping[next3CharStyleSet]!.substring(0, 5), radix: 16));
                    }
                    // debugPrint('Fast processing $next2Char and $next3Char at index: ${i + 1} and ${i + 2}');
                    i += 2; // Skip the next character since it's part of the phrase
                    break;

                  default:
                    // Handle any unexpected values if necessary
                    // debugPrint('Unexpected setNextBpmf value: $setNextBpmf');
                    break;
                }
                continue; // Skip to the next loop iteration to avoid processing the skipped character again
              }

              List<dynamic>? variations = charData['v'];
              if (variations != null && variations.isNotEmpty) {
                  List<String> patterns = variations.map((v) => v.toString()).toList();
                  var matchResult = match(character, i, patterns, characters, skipPrev: skipPrevTemp);
                  int matchIndex = matchResult.item1;
                  bool skipNext = matchResult.item2;
                  skipPrev = matchResult.item3;              
                  // debugPrint("matchIndex: $matchIndex, skipNext: $skipNext, skipPrev: $skipPrev");

                  if (matchIndex != 0 || skipNext) {
                    String newSs = (matchIndex != 0) ? 'ss0$matchIndex' : '';
                    if (newSs.isNotEmpty) {
                        spans.add(TextSpan(text: character, style: getCharPolyStyle(fontSize, color, newSs, highlightOn)));
                        spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
                        spansUnicode += String.fromCharCode(int.parse(ssMapping[newSs]!.substring(0, 5), radix: 16));
                    } else {
                        spans.add(TextSpan(text: character, style: getCharStyle(fontSize, color, highlightOn)));
                        spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
                    }

                    if (skipNext && i + 1 < length) {
                      String nextHexUnicode = nextChar.runes.first.toRadixString(16).toUpperCase();
                      spans.add(TextSpan(text: nextChar, style: getCharStyle(fontSize, color, highlightOn))); // Add next character
                      spansUnicode += String.fromCharCode(int.parse(nextHexUnicode, radix: 16));
                      // debugPrint("Skipping $nextChar at index: ${i + 1}");
                      i += 1; // Skip the next character since it's part of the phrase
                      continue; // Skip to the next loop iteration to avoid processing the skipped character again
                    }
                  } else {
                    spans.add(TextSpan(text: character, style: getCharStyle(fontSize, color, highlightOn)));
                    spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
                  }
              } else {
                spans.add(TextSpan(text: character, style: getCharStyle(fontSize, color, highlightOn)));
                spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
              }
            } else {
              spans.add(TextSpan(text: character, style: getCharStyle(fontSize, color, highlightOn)));
              spansUnicode += String.fromCharCode(int.parse(hexUnicode, radix: 16));
              // Check if the prevChar and character are in the common phrases list. If so, set skipPrev to true
              String phrase = prevChar + character;
              if (duoCommonPhrases.contains(phrase)) {
                skipPrev = true; // This is a common phrase, so when processing the next character, we don't have to look back
                // debugPrint('Common phrase found: $phrase, setting skipPrev to true');
              } else {
                skipPrev = false; // 目前的字沒有多音字，但是下一個字可能會有，因此要設 false。
              }
            }

          }
      }
      return Tuple2(spans, spansUnicode);
  }

  Tuple3<int, bool, bool> match(String character, int index, List<String> patterns, List<String> text, {bool skipPrev = false}) {
    int defaultIndex = -1; // To handle empty patterns as fallback
    String prev2Char = (index > 1) ? text[index - 2] : '';
    String prevChar = (index > 0) ? text[index - 1] : '';
    String threeCharPhrase = prev2Char + prevChar + character;
    String nextChar = (index + 1 < text.length) ? text[index + 1] : '';
    bool isFirstChar = (prevChar == '' || !isChineseCharacter(prevChar)) ? true : false;
    bool isLastChar = (nextChar == '' || !isChineseCharacter(nextChar)) ? true : false;
    bool isStandalone = (text.length == 1) || (isFirstChar && isLastChar);
    bool skipNext = false; // Flag to skip the next character processing
    // 我原先想法是，若下一個字也是多音字，列一個表來檢查，以便加速處理。但是這個表的維護就成問題。所以放棄這個想法。
    // final List<String> noSkipNextCharacters = ['骨頭', '參與', '參差', '檻車', '爪子', '度量', '委蛇', '暈倒'/* 這裡要列出兩個字都是多音字，而且第二個字的發音不是default */];

    // debugPrint('Starting match function. Character: $character, prevChar: $prevChar, nextChar: $nextChar, patterns: $patterns, skipPrev: $skipPrev');

    if (isStandalone) {
      // debugPrint('Character $character is standalone. Returning default index.');
      return const Tuple3(0, false, true); // Return default tone index with proper skip flags set
    }

    // Special handle for '地' with 'de5' sound
    final Set<String> phrasesEndsWithDi = {
      '一十地', '大方地', '大聲地', '小心地', '小聲地', '不休地', '不安地', 
      '不倦地', '不停地', '不堪地', '不絕地', '不諱地', '不斷地', '亢奮地', 
      '仔細地', '叨叨地', '可憐地', '巧妙地', '平整地', '正當地', '正經地', 
      '生氣地', '生動地', '示弱地', '交替地', '吁吁地', '合適地', '吐吐地', 
      '如實地', '安靜地', '忙碌地', '成功地', '有味地', '有效地', '自主地', 
      '自由地', '自在地', '自信地', '自然地', '下氣地', '低聲地', '克難地', 
      '冷漠地', '吾吾地', '均勻地', '完整地', '忘我地', '快速地', '快樂地', 
      '抖擻地', '決然地', '牢固地', '狂暴地', '狂熱地', '甫定地', '迅速地', 
      '屈膝地', '周到地', '呱呱地', '和藹地', '坦率地', '委婉地', '怯步地', 
      '所能地', '易舉地', '虎嚥地', '采烈地', '勇敢地', '思索地', '急速地', 
      '筍般地', '耐心地', '重複地', '飛快地', '容易地', '恣意地', '悄悄地', 
      '特別地', '特定地', '真實地', '秘密地', '虔誠地', '究柢地', '高興地', 
      '乾脆地', '停蹄地', '偷偷地', '堅定地', '堅強地', '堅毅地', '專注地', 
      '康康地', '強烈地', '得意地', '悠悠地', '悠揚地', '悠閒地', '情願地', 
      '授權地', '敏感地', '敏銳地', '淡寫地', '深刻地', '深深地', '清楚地', 
      '甜甜地', '細心地', '許可地', '尊敬地', '悲傷地', '惺忪地', '愉快地', 
      '無私地', '無償地', '猶豫地', '痛苦地', '絮絮地', '間斷地', '意外地', 
      '意料地', '準確地', '溫柔地', '煞氣地', '痴痴地', '經意地', '詳細地', 
      '誠意地', '誠懇地', '嘆氣地', '慢慢地', '慣性地', '漂亮地', '漸漸地', 
      '瘋狂地', '盡力地', '盡瘁地', '緊緊地', '輕盈地', '輕微地', '輕輕地', 
      '輕聲地', '遠遠地', '嘩啦地', '熟慮地', '熟練地', '熱心地', '熱情地', 
      '範圍地', '緩慢地', '緩緩地', '踏實地', '整齊地', '激動地', '興奮地', 
      '諱言地', '錯誤地', '隨意地', '靜靜地', '靦腆地', '默默地', '優雅地', 
      '翼翼地', '闊步地', '禮貌地', '簡單地', '謹慎地', '穩固地', '穩穩地', 
      '嚴厲地', '歡快地', '驕傲地', '驚恐地', '靈活地', '究底地', '大大地',
    };

    if (character == '地') {
      if (phrasesEndsWithDi.contains(threeCharPhrase)) {
        // debugPrint('“$threeCharPhrase” pattern matched. 地的發音是"de5".');
        return const Tuple3(1, false, true); // de5
      } else {
        // debugPrint('“$threeCharPhrase” pattern NO matched. 地的發音是"di4".');
        return const Tuple3(0, false, true); // di4
      }
    }

    if (character == '著') {
      // Check if the neighbor characters are "著作權"
      String secondLine = patterns.length > 1 ? patterns[1] : '';
      if (index >= 0 && index + 2 < text.length) {
        String prefix = character + text[index + 1] + text[index + 2];
        if (prefix == "著作權") {
          // debugPrint('Special pattern "著作權" matched');
          skipNext = false; // Set skipNext to false if a pattern is matched
          skipPrev = false; // Set skipPrev to true if a pattern is matched
          return Tuple3(patterns.indexOf(secondLine), skipNext, skipPrev);
        }
      }
    }

    // First pass: Checking all patterns for "any+*" or "any+*+any"
    if (isFirstChar || skipPrev) {
      // debugPrint('isFirstChar: $isFirstChar or skipPrev: $skipPrev. Skipping the first pass, i.e., any+$character');
    } else {
      // debugPrint('First pass for $character: Checking patterns for "any+* or "any+*+any"');
      for (int j = 0; j < patterns.length; j++) {
        String combinedPattern = patterns[j];
        List<String> subPatterns = combinedPattern.split('/'); // Split into sub-patterns
        // debugPrint('First pass - combinedPattern $j: $combinedPattern, subPatterns: $subPatterns');

        for (String pattern in subPatterns) {
          // debugPrint('First pass - Checking ($prevChar+$character) in subPatterns: $pattern');
          if (pattern.isEmpty) {
            defaultIndex = j; // Save the index of the empty pattern
            // debugPrint('Empty pattern, setting defaultIndex to $j');
            continue; // Continue to check other patterns
          }

          if (pattern.startsWith('*')) {
            // debugPrint('Skipping sub-pattern as it starts with "*": $pattern');
            continue; // Skip if not starting with '*'
          }

          int pos = pattern.indexOf('*');
          if (pos == -1) {
            // debugPrint('Skipping sub-pattern as no "*" found: $pattern');
            continue; // Skip if no '*' found
          }

          int start = index - pos;
          int end = index - pos + pattern.length;
          if (start < 0 || end > text.length) {
            // debugPrint('Skipping sub-pattern as out of bounds: $pattern, start: $start, end: $end, text length: ${text.length}');
            continue; // Skip if out of bounds
          }

          if (matchPattern(pattern, pos, start, end, text, character)) {
            skipNext = false; // Set skipNext to false if a pattern is matched
            skipPrev = true; // Set skipPrev to true if a pattern is matched
            // debugPrint('Sub-pattern matched (any+*) ($prevChar+$character): $pattern, $j, skipNext: $skipNext, skipPrev: $skipPrev');
            return Tuple3(j, skipNext, skipPrev); // Returning with skipNext=false, skipPrev=true
          }
        }
      }
    }

    // Second pass: Checking patterns for "*+any"
    if (isLastChar) {
      // debugPrint('Last character. Skip the second pass for $character');
    } else {
      // debugPrint('Second pass for $character: Checking patterns for "*+any"');
      for (int j = 0; j < patterns.length; j++) {
        String combinedPattern = patterns[j];
        List<String> subPatterns = combinedPattern.split('/'); // Split into sub-patterns
        // debugPrint('Second pass - combinedPattern $j: $combinedPattern, subPatterns: $subPatterns');

        for (String pattern in subPatterns) {
          // debugPrint('Second pass - Checking sub-pattern: $pattern');
          if (pattern.isEmpty) {
            defaultIndex = j; // Save the index of the empty pattern
            // debugPrint('Empty pattern, setting defaultIndex to $j');
            continue; // Skip empty patterns
          }

          if (!pattern.startsWith('*')) {
            // debugPrint('Skipping sub-pattern as it does not start with $character: $pattern');
            continue; // Skip if not starting with '*'
          }

          int pos = pattern.indexOf('*');
          if (pos == -1) {
            // debugPrint('Skipping sub-pattern as no "*" found: $pattern');
            continue; // Skip if no '*' found
          }

          int start = index - pos;
          int end = index - pos + pattern.length;
          if (start < 0 || end > text.length) {
            // debugPrint('Skipping sub-pattern as out of bounds: $pattern, start: $start, end: $end, text length: ${text.length}');
            continue; // Skip if out of bounds
          }

          if (matchPattern(pattern, pos, start, end, text, character)) {
            if (isPolyphonicChar(nextChar)) { // 如果目前的字和下一個字都是多音字，設 skipNext 跟 skipPrev 為 false。
              skipNext = false;
              skipPrev = false;
            } else { // 目前的字是多音字，下一個字不是，skipNext 要設 true。
              skipNext = true;
              skipPrev = pattern.startsWith('*') && pos == 0;
            }
            if (isPolyphonicChar(nextChar)) { // 下一個字也是多音字
              /* 我原先想法是，若下一個字也是多音字，列一個表來檢查，以便加速處理。但是這個表的維護就成問題。所以放棄這個想法。
              if (noSkipNextCharacters.contains(character + nextChar)) {
                skipNext = false;
                skipPrev = false;
              } else {
                skipPrev = true; // Set skipPrev to true if a pattern is matched
                skipNext = pattern.startsWith('*') && pos == 0;
              }
              */
              skipNext = false;
              skipPrev = false;              
            } else { // 目前的字是多音字，下一個字不是，要設 true。
              skipPrev = true; // Set skipPrev to true if a pattern is matched
              skipNext = pattern.startsWith('*') && pos == 0;
            }            
            // debugPrint('Sub-pattern matched (*+any) ($character+$nextChar): $pattern, matchIndex: $j, skipNext: $skipNext, skipPrev: $skipPrev');
            return Tuple3(j, skipNext, skipPrev); // Returning with skipNext and skipPrev=false
          }
        }
      }
    }

    skipPrev = false; // 目前的字沒有多音字，但是下一個字可能會有，因此要設 false。
    // debugPrint('No pattern matched for $character. Use default index: ${defaultIndex != -1 ? defaultIndex : 0}, skipNext: $skipNext, skipPrev: $skipPrev');
    return Tuple3(defaultIndex != -1 ? defaultIndex : 0, skipNext, skipPrev); // Returning the default index with skip flags as false
  }

  // Helper function to determine if a character is polyphonic
  bool isPolyphonicChar(String character) {
    var charData = _polyphonicData['data'][character];
    if (!isChineseCharacter(character) || charData == null) {
      return false;
    } else {
      return true;
    }
  }

  // Helper function to check pattern and construct substring using StringBuffer
  bool matchPattern(String pattern, int pos, int start, int end, List<String> text, String character) {
    StringBuffer tmp = StringBuffer();
    for (int z = start; z < end; z++) {
      tmp.write(text[z]);
    }
    return tmp.toString() == pattern.replaceAll('*', character);
  }

  // Helper function to check if a character is a Chinese character
  bool isChineseCharacter(String char) {
      // final chineseCharRegEx = RegExp(r'[\u4E00-\u9FFF]');
      return chineseCharRegex.hasMatch(char);
  }

}
// End of file: ./lib/views/polyphonic_processor.dart
//----------------------

// File: ./lib/views/units_view.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/contants/bopomos.dart';
import 'package:ltrc/contants/publisher_code.dart';
import 'package:ltrc/contants/semester_code.dart';
import 'package:ltrc/data/models/word_status_model.dart';
import 'package:ltrc/data/models/word_phrase_sentence_model.dart';
import 'package:ltrc/data/providers/word_phrase_sentence_provider.dart';
import 'package:ltrc/data/providers/word_status_provider.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';


import '../contants/arabic_numerals_to_chinese.dart';
import '../data/models/unit_model.dart';

class UnitsView extends ConsumerStatefulWidget {
  
  const UnitsView({super.key});

  @override
  UnitsViewState createState() => UnitsViewState();
}
class UnitsViewState extends ConsumerState<UnitsView> {
  List<Unit> units = [];
  
  @override
  void initState() {
    super.initState();
  }
  @override
  void dispose() {
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {

    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    
    bool isTablet = screenInfo.isTablet;
    if (isTablet && MediaQuery.of(context).orientation == Orientation.landscape) fontSize *= 1.3;

    final gradeCode = ref.watch(gradeProvider);
    final semesterCode = ref.watch(semesterCodeProvider);
    final publisherCode = ref.watch(publisherCodeProvider);

    final gradeName = numeralToChinese[gradeCode] ?? 'Unknown Publisher';
    final semesterName = semesterCodeTable[semesterCode] ?? 'Unknown Publisher';
    final publisherName = publisherCodeTable[publisherCode] ?? 'Unknown Publisher';

    String title = '$publisherName：$gradeName$semesterName';
    debugPrint('UnitsView: title: $title, publisher $publisherName, grade $gradeName, semester $semesterName');

    // Extract the arguments safely
    final args = ModalRoute.of(context)!.settings.arguments as Map<String, dynamic>?;
    if (args == null || args['units'] == null) {
      return Center(
        child: Text(
          'No units available',
          style: TextStyle(fontSize: fontSize),
        ),
      );
    }

    // Now that we've checked, it's safe to cast    
    List<Unit> units = args["units"]; // Assuming 'units' is a list of 'Unit'

    Future<List<Map>> getWordsPhraseSentence(List<WordStatus> wordsStatus) async {
      List<Map> wordsPhrase = [];
      WordPhraseSentence? wordPhraseSentence;

      if (wordsStatus.isEmpty) return wordsPhrase;
      try {
        for (var wordStatus in wordsStatus) {
          // Attempt to fetch the WordPhraseSentence for the provided wordStatus
          // debugPrint('wordStatus.word: ${wordStatus.word}'); // debug
          wordPhraseSentence = await WordPhraseSentenceProvider.getWordPhraseSentenceByWord(inputWord: wordStatus.word);
          if (wordPhraseSentence.id == -1) {
            wordsPhrase.add(
              {
                "word": "",
                "vocab1": "",
                "meaning1": "",
                "sentence1": "",
                "vocab2": "",
                "meaning2": "",
                "sentence2": "",
              }
            );
          } else {
            wordsPhrase.add(
              {
                "word": wordPhraseSentence.word,
                "vocab1": wordPhraseSentence.phrase,
                "meaning1": wordPhraseSentence.definition,
                "sentence1": wordPhraseSentence.sentence,
                "vocab2": wordPhraseSentence.phrase2,
                "meaning2": wordPhraseSentence.definition2,
                "sentence2": wordPhraseSentence.sentence2,
              }
            );
          }
        }
        return wordsPhrase;
      } catch (e) {
        debugPrint('Error in getWordsPhraseSentence: $e');
        wordsPhrase = [];
        return wordsPhrase;
      }
    }    

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: Icon(Icons.chevron_left, size: fontSize * 1.5), 
          onPressed: () => Navigator.pop(context),
        ),
        title: Text(title, style: TextStyle(fontSize: fontSize * 1.5)),
      ),
      body: CustomScrollView(
        slivers: [
          SliverPadding(
            padding: const EdgeInsets.fromLTRB(23, 14, 23, 20),
            sliver: SliverGrid(
              gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
                  maxCrossAxisExtent: isTablet
                      ? fontSize * 8.0 
                      : fontSize * 8.0, 
                  mainAxisSpacing: fontSize * 0.5, // was 10,
                  crossAxisSpacing: fontSize * 0.5, // was 10,
                  childAspectRatio: isTablet ? 4 / 2 : 4 / 2, // was 4 / 3 : 4 / 4,
              ),
              delegate: SliverChildBuilderDelegate(
                (BuildContext context, int index) {
                  String text = index == 0 ? "學注音" : "最愛❤️";
                  return InkWell(
                    onTap: () async {
                      if (index == 0 ) {  // 學注音
                        List<String> bopomos = List.from(initials)..addAll(prenuclear)..addAll(finals);
                        await WordStatusProvider.addWordsStatus(
                          statuses: bopomos.map((word) => 
                            WordStatus(
                              id: -1, 
                              userAccount: ref.read(accountProvider.notifier).state , 
                              word: word, 
                              learned: false, 
                              liked: false
                            )
                          ).toList()
                        );

                        List<WordStatus> wordsStatus = await WordStatusProvider.getWordsStatus(
                          account: ref.read(accountProvider.notifier).state,
                          words: bopomos, 
                        );
                        List<Map> bpmfWordsPhrase = await getWordsPhraseSentence(wordsStatus);
                        if (!context.mounted) return;
                        /*
                        Navigator.of(context).pushNamed(
                          '/bopomos', 
                          arguments: {
                            'wordStatus' : wordsStatus,
                            'wordsPhrase' : bpmfWordsPhrase
                          }
                        );
                        */
                        navigateWithProvider(
                          context, 
                          '/bopomos', 
                          ref, 
                          arguments: {
                            'wordStatus' : wordsStatus,
                            'wordsPhrase' : bpmfWordsPhrase
                          }
                        );

                      }
                      else {
                        List<WordStatus> likedWords = await WordStatusProvider.getLikedWordsStatus(
                          account: ref.watch(accountProvider), 
                        );
                        List<Map> likedWordsPhrase = await getWordsPhraseSentence(likedWords);
                        if (!context.mounted) return;
                        navigateWithProvider(
                          context, 
                          '/words', 
                          ref, 
                          arguments: {
                            'unit' : Unit(
                              id: -1, 
                              publisher: '', 
                              grade: 1, 
                              semester: '', 
                              unitId: -1, 
                              unitTitle: "❤️最愛",
                              newWords: [] ,
                              extraWords:[]
                            ),
                            'newWordsStatus' : likedWords,
                            'newWordsPhrase' : likedWordsPhrase
                          }
                        );
                      }
                    },
                    child: Container(
                      alignment: Alignment.center,
                      decoration: const BoxDecoration(
                        borderRadius: BorderRadius.all(Radius.circular(14)),
                        color: Color(0xFF013E6D),
                      ),
                      child: FittedBox(
                        fit: BoxFit.scaleDown,
                        child: Padding(
                          padding: const EdgeInsets.all(2.0),
                          child: Text(
                            text,
                            style: TextStyle(fontSize: fontSize),
                            textAlign: TextAlign.center,
                          ),
                        ),
                      ),
                    ),
                  );
                },
                childCount: 2,
              ),
            ),
          ),

          SliverPadding(
            padding: const EdgeInsets.fromLTRB(23, 14, 23, 20),
            sliver: SliverGrid(
              gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
                  maxCrossAxisExtent: isTablet
                      ? fontSize * 12.0 // was 8.0
                      : fontSize * 12.0, // This is most important
                  mainAxisSpacing: fontSize * 0.5, // was 10,
                  crossAxisSpacing: fontSize * 0.5, // was 10,
                  childAspectRatio: isTablet ? 5 / 2 : 5 / 2, // was 4 / 3 : 4 / 4,
              ),
              delegate: SliverChildBuilderDelegate(
                (BuildContext context, int index) {
                  // String? classNum = numeralToChinese[index + 1];
                  return InkWell(
                    onTap: () async {
                      Unit unit = units[index];
                      await WordStatusProvider.addWordsStatus(
                        statuses: unit.newWords.map((word) => 
                          WordStatus(
                            id: -1, 
                            userAccount: ref.read(accountProvider.notifier).state , 
                            word: word, 
                            learned: false, 
                            liked: false
                          )
                        ).toList()
                      );
                      unit.newWords.removeWhere((item) => unit.extraWords.contains(item));
                      
                      List<WordStatus> newWordsStatus = await WordStatusProvider.getWordsStatus(
                        account: ref.read(accountProvider.notifier).state,
                        words: unit.newWords, 
                      );
                      List<WordStatus> extraWordsStatus = await WordStatusProvider.getWordsStatus(
                        account: ref.read(accountProvider.notifier).state,
                        words: unit.extraWords, 
                      );
                      List<Map> newWordsPhrase = await getWordsPhraseSentence(newWordsStatus);
                      List<Map> extraWordsPhrase = await getWordsPhraseSentence(extraWordsStatus);
                      if (!context.mounted) return;
                      navigateWithProvider(
                        context,
                        '/words', 
                        ref,
                        arguments: {
                          'unit' : unit,
                          'newWordsStatus' : newWordsStatus,
                          'extraWordsStatus' : extraWordsStatus,
                          'newWordsPhrase' : newWordsPhrase,
                          'extraWordsPhrase' : extraWordsPhrase
                        }
                      );


                    },            
                    child: Container(
                      decoration: const BoxDecoration(
                        borderRadius: BorderRadius.all(Radius.circular(14)),
                        color: Color(0xFF013E6D),
                      ),
                      alignment: Alignment.center,
                      padding: const EdgeInsets.all(2.0), // was 8.0
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          Text(
                            "第${numeralToChinese[index + 1]}課",
                            style: TextStyle(
                              fontSize: fontSize, // Choose a font size that fits all boxes
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                          Text(
                            units[index].unitTitle,
                            style: TextStyle(fontSize: fontSize), // Use the same font size for consistency
                            textAlign: TextAlign.center,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ],
                      ),
                    ),
                  );
                },
                childCount: units.length,
              ),
            ),
          ),

        ],
      ),
    );
  }
}

// End of file: ./lib/views/units_view.dart
//----------------------

// File: ./lib/views/t_teach_word.dart


// End of file: ./lib/views/t_teach_word.dart
//----------------------

// File: ./lib/views/bopomo_quiz.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_tts/flutter_tts.dart';
import 'package:ltrc/contants/bopomo_spelling_problem.dart';
import 'package:ltrc/contants/bopomos.dart';
import 'package:ltrc/data/models/bopomo_spelling_model.dart';
import 'package:ltrc/data/models/word_model.dart';
import 'package:ltrc/data/providers/word_provider.dart';
// import 'package:ltrc/extensions.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';
import '../widgets/bopomo/bopomo_container.dart';


class BopomoQuizView extends ConsumerStatefulWidget {
  const BopomoQuizView({super.key});

  @override
  ConsumerState<BopomoQuizView> createState() => _BopomoQuizState();
}

class _BopomoQuizState extends ConsumerState<BopomoQuizView> {
  final vowels = List.from(prenuclear)..addAll(finals);
  int problemId = 0;
  FlutterTts ftts = FlutterTts();
  Color answerBoxBorderColor = beige;
  BopomoSpelling caught = BopomoSpelling();
  BopomoSpelling answer = BopomoSpelling();

  Future<void> _getAnswer() async {
    if (answer.initial.isEmpty &&
        answer.prenuclear.isEmpty &&
        answer.finals.isEmpty) {
      Word answerWord =
          await WordProvider.getWord(inputWord: bopomoSpellingWords[problemId]);
      String answerSpelling = answerWord.phonetic;
      List<String> spellingList = answerSpelling.split('');
      switch (spellingList.length) {
        case (1):
          if (initials.contains(spellingList[0])) {
            answer.initial = spellingList[0];
          } else if (prenuclear.contains(spellingList[0])) {
            answer.prenuclear = spellingList[0];
          } else {
            answer.finals = spellingList[0];
          }
          break;
        case (2):
          if (initials.contains(spellingList[0])) {
            answer.initial = spellingList[0];
            if (prenuclear.contains(spellingList[1])) {
              answer.prenuclear = spellingList[1];
            } else {
              answer.finals = spellingList[1];
            }
          } else if (prenuclear.contains(spellingList[0])) {
            answer.prenuclear = spellingList[0];
            answer.finals = spellingList[1];
          }
          break;
        case (3):
          answer.initial = spellingList[0];
          answer.prenuclear = spellingList[1];
          answer.finals = spellingList[2];
          break;
        default:
          break;
      }
      answer.tone = answerWord.tone;
    }
  }

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;

    return Scaffold(
        appBar: AppBar(
          // 拼拼看
          leading: IconButton(
            icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
            onPressed: () => Navigator.pop(context),
          ),
          title: Text(
            "拼拼看",
            style: TextStyle(
                fontSize: fontSize * 1.0), // Set the font size for the title
          ),
          actions: [
            IconButton(
              icon: Icon(
                Icons.home,
                size: fontSize * 1.5,
              ),
              // onPressed: () => Navigator.of(context).pushNamed('/mainPage'),
              onPressed: () => navigateWithProvider(context, '/mainPage', ref),
            )
          ],
        ),
        body: CustomScrollView(
          slivers: [
            SliverToBoxAdapter(
              // 第${problemId+1}題\n請拼出「${bopomoSpellingWords[problemId]}」的注音
              child: Container(
                  height: fontSize * 1.7,
                  alignment: Alignment.center,
                  decoration: const BoxDecoration(
                    color: deepBlue,
                  ),
                  child: RichText(
                    // 第${problemId+1}題\n請拼出「${bopomoSpellingWords[problemId]}」的注音
                    textAlign: TextAlign.center,
                    text: TextSpan(
                        text: '第${problemId + 1}題：請拼出「',
                        style: TextStyle(
                          fontSize: fontSize,
                          fontFamily: 'BpmfIansui',
                          color: beige,
                        ),
                        children: [
                          TextSpan(
                              text: bopomoSpellingWords[problemId],
                              style: TextStyle(
                                fontSize: fontSize,
                                fontFamily: 'Iansui',
                                color: beige,
                              )),
                          TextSpan(
                              text: '」的注音',
                              style: TextStyle(
                                fontSize: fontSize,
                                fontFamily: 'BpmfIansui',
                                color: beige,
                              )),
                        ]),
                  )),
            ),
            SliverPadding(
                // 讀音、提示、答案、清除、確認
                padding: const EdgeInsets.fromLTRB(4, 4, 4, 4),
                sliver: SliverToBoxAdapter(
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    mainAxisSize: MainAxisSize.max,
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      Image(
                        height: fontSize * 8.0,
                        image: AssetImage(
                            'lib/assets/img/bopomo_spelling/${bopomoSpellingWords[problemId]}.png'),
                      ),
                      Column(
                        // 讀音、提示
                        children: [
                          Consumer(builder: (context, ref, child) {
                            return IconButton(
                              icon: Icon(
                                Icons.volume_up,
                                color: beige,
                                size: 1.2 * fontSize,
                              ),
                              onPressed: () {
                                debugPrint(
                                    ref.watch(soundSpeedProvider).toString());
                                ftts.setLanguage("zh-tw");
                                ftts.setSpeechRate(
                                    ref.watch(soundSpeedProvider));
                                ftts.setVolume(1.0);
                                ftts.speak(bopomoSpellingWords[problemId]);
                              },
                            );
                          }),
                          Text(
                            '讀\n音',
                            style: TextStyle(
                                color: beige,
                                fontSize: fontSize * 0.75),
                          ),
                          IconButton(
                            icon: Icon(
                              Icons.lightbulb,
                              color: beige,
                              size: 1.2 * fontSize,
                            ),
                            onPressed: () async {
                              await _getAnswer();
                              if (answer.initial != caught.initial) {
                                setState(() {
                                  caught.initial = answer.initial;
                                });
                              } else if (answer.prenuclear !=
                                  caught.prenuclear) {
                                setState(() {
                                  caught.prenuclear = answer.prenuclear;
                                });
                              } else if (answer.finals != caught.finals) {
                                setState(() {
                                  caught.finals = answer.finals;
                                });
                              } else if (answer.tone != caught.tone) {
                                setState(() {
                                  caught.tone = answer.tone;
                                });
                              }
                            },
                          ),
                          Text(
                            '提\n示',
                            style: TextStyle(
                                color: beige,
                                fontSize: fontSize * 0.75),
                          ),
                        ],
                      ),
                      SizedBox(
                        // 答案
                        width: 8.2 * fontSize,
                        height: 10.6 * fontSize,
                        child: Container(
                          decoration: BoxDecoration(
                            color: darkCyan,
                            border: Border.all(
                              width: 0.1 * fontSize,
                              color: answerBoxBorderColor,
                            ),
                          ),
                          child: Row(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                Column(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    BopomoContainer(
                                      character: (caught.initial.isNotEmpty &&
                                              caught.tone == 5)
                                          ? null
                                          : (caught.tone == 5)
                                              ? "˙"
                                              : caught.initial,
                                      innerWidget: (caught.initial.isNotEmpty &&
                                              caught.tone == 5)
                                          ? Column(
                                              children: [
                                                Text(
                                                  "˙",
                                                  style: TextStyle(
                                                      fontSize: fontSize),
                                                ),
                                                Text(
                                                  caught.initial,
                                                  style: TextStyle(
                                                      fontSize: fontSize),
                                                )
                                              ],
                                            )
                                          : null,
                                      color: darkOliveGreen,
                                      onPressed: () => setState(() {
                                        caught.initial = '';
                                        if (caught.tone == 5) {
                                          caught.tone = 1;
                                        }
                                      }),
                                    ),
                                    BopomoContainer(
                                      character: caught.prenuclear,
                                      innerWidget: Text(
                                        caught.prenuclear,
                                        style: TextStyle(fontSize: fontSize),
                                      ),
                                      color: goldenOrange,
                                      onPressed: () => setState(() {
                                        caught.prenuclear = '';
                                      }),
                                    ),
                                    BopomoContainer(
                                      character: caught.finals,
                                      innerWidget: Text(
                                        caught.finals,
                                        style: TextStyle(fontSize: fontSize),
                                      ),
                                      color: goldenOrange,
                                      onPressed: () => setState(() {
                                        caught.finals = '';
                                      }),
                                    ),
                                  ],
                                ),
                                BopomoContainer(
                                  character:
                                      (caught.tone == 5 || caught.tone == 1)
                                          ? ""
                                          : tones[caught.tone - 2],
                                  color: indianRed,
                                  onPressed: () => setState(() {
                                    caught.tone = 1;
                                  }),
                                ),
                              ]),
                        ),
                      ),
                      Column(
                        // 清除、確認
                        children: [
                          IconButton(
                            icon: Icon(
                              Icons.replay,
                              color: beige,
                              size: 1.2 * fontSize,
                            ),
                            onPressed: () {
                              setState(() {
                                caught = BopomoSpelling();
                              });
                            },
                          ),
                          Text(
                            '清\n除',
                            style: TextStyle(
                                color: beige,
                                fontSize: fontSize * 0.75),
                          ),
                          IconButton(
                            icon: Icon(
                              Icons.done_outline,
                              color: beige,
                              size: 1.2 * fontSize,
                            ),
                            onPressed: () async {
                              if (problemId < bopomoSpellingWords.length - 1) {
                                await _getAnswer();
                                if (answer == caught) {
                                  setState(() {
                                    answerBoxBorderColor = Colors.green;
                                  });
                                  Timer(const Duration(seconds: 1), () {
                                    setState(() {
                                      problemId += 1;
                                      caught = BopomoSpelling();
                                      answer = BopomoSpelling();
                                      answerBoxBorderColor =
                                          beige;
                                    });
                                  });
                                } else {
                                  setState(() {
                                    answerBoxBorderColor = Colors.red;
                                  });
                                  Timer(const Duration(seconds: 1), () {
                                    setState(() {
                                      answerBoxBorderColor =
                                          beige;
                                    });
                                  });
                                }
                              } else {
                                // Navigator.pushNamed(context, '/bopomoQuizFinish');
                                navigateWithProvider(context, '/bopomoQuizFinish', ref);
                              }
                            },
                          ),
                          Text(
                            '確\n認',
                            style: TextStyle(
                                color: beige,
                                fontSize: fontSize * 0.75),
                          ),
                        ],
                      ),
                    ], // children
                  ),
                )),
            // SizedBox(height: fontSize * 0.2),
            SliverPadding(
              // 四聲
              padding: const EdgeInsets.fromLTRB(25, 5, 25, 5),
              sliver: SliverGrid(
                gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
                  maxCrossAxisExtent: fontSize * 2.0,
                  mainAxisSpacing: fontSize * 0.75, // was 8.0,
                  crossAxisSpacing: fontSize * 0.75, // was 8.0
                  childAspectRatio: 1 / 1,
                ),
                delegate: SliverChildBuilderDelegate(
                  (BuildContext context, int index) {
                    return (index == caught.tone - 2)
                        ? BopomoContainer(
                            // The top right hand box
                            character: tones[index],
                            color: dimGray,
                            onPressed: () => setState(() {
                              caught.tone = 1;
                            }),
                          )
                        : BopomoContainer(
                            character: tones[index],
                            color: indianRed,
                            onPressed: () => setState(() {
                              caught.tone = index + 2;
                            }),
                          );
                  },
                  childCount: tones.length,
                ),
              ),
            ),
            SliverPadding(
              // ㄅㄆㄇㄈ
              padding: const EdgeInsets.fromLTRB(25, 5, 25, 5),
              sliver: SliverGrid(
                gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
                  maxCrossAxisExtent: fontSize * 2.0,
                  mainAxisSpacing: fontSize * 0.75,
                  crossAxisSpacing: fontSize * 0.75,
                  childAspectRatio: 1 / 1,
                ),
                delegate: SliverChildBuilderDelegate(
                  (BuildContext context, int index) {
                    return initials[index] == caught.initial
                        ? BopomoContainer(
                            character: initials[index],
                            color: dimGray,
                            onPressed: () => setState(() {
                              caught.initial = '';
                            }),
                          )
                        : BopomoContainer(
                            character: initials[index],
                            color: darkOliveGreen,
                            onPressed: () => setState(() {
                              caught.initial = initials[index];
                            }),
                          );
                  },
                  childCount: initials.length,
                ),
              ),
            ),
            SliverPadding(
              // ㄧㄨㄩ
              padding: const EdgeInsets.fromLTRB(25, 5, 25, 5),
              sliver: SliverGrid(
                gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
                  maxCrossAxisExtent: fontSize * 2.0,
                  mainAxisSpacing: fontSize * 0.75, // was 8.0,
                  crossAxisSpacing: fontSize * 0.75, // was 8.0
                  childAspectRatio: 1 / 1,
                ),
                delegate: SliverChildBuilderDelegate(
                  (BuildContext context, int index) {
                    if (index < 3) {
                      return prenuclear[index] == caught.prenuclear
                          ? BopomoContainer(
                              character: prenuclear[index],
                              color: dimGray,
                              onPressed: () => setState(() {
                                caught.prenuclear = '';
                              }),
                            )
                          : BopomoContainer(
                              character: prenuclear[index],
                              color: goldenOrange,
                              onPressed: () => setState(() {
                                caught.prenuclear = prenuclear[index];
                              }),
                            );
                    } else {
                      return finals[index - 3] == caught.finals
                          ? BopomoContainer(
                              character: finals[index - 3],
                              color: dimGray,
                              onPressed: () => setState(() {
                                caught.finals = '';
                              }),
                            )
                          : BopomoContainer(
                              character: finals[index - 3],
                              color: goldenOrange,
                              onPressed: () => setState(() {
                                caught.finals = finals[index - 3];
                              }),
                            );
                    }
                  },
                  childCount: vowels.length,
                ),
              ),
            ),
          ],
        ));
  }
}

// End of file: ./lib/views/bopomo_quiz.dart
//----------------------

// File: ./lib/views/main_page_view.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/contants/semester_code.dart';
import 'package:ltrc/contants/publisher_code.dart';
import 'package:ltrc/data/models/unit_model.dart';
import 'package:ltrc/data/providers/unit_provider.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';
// import 'package:ltrc/widgets/progress_bar.dart';


class MainPageView extends ConsumerWidget {
  const MainPageView({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    
    double deviceHeight = screenInfo.screenHeight;
    double deviceWidth = screenInfo.screenWidth;
    debugPrint('main_page_view: H: $deviceHeight, W: $deviceWidth, F: $fontSize');
    String account = ref.read(accountProvider);
    int totalWordCount = ref.watch(totalWordCountProvider);
    int learnedWordCount = ref.watch(learnedWordCountProvider);

    // for unknown reason, totalWordCount is 0. Set it here 186 to work around.
    if (totalWordCount == 0) {
      debugPrint('MainPageView WordCount: total $totalWordCount, learned $learnedWordCount');
      totalWordCount = 186;
    }

    return Scaffold(
      backgroundColor: darkBrown,
      appBar: AppBar(
        automaticallyImplyLeading: false,
        actions: [
          IconButton(
            icon: Icon(
              Icons.settings,
              size: fontSize * 1.5,
            ),
            // onPressed: () => Navigator.of(context).pushNamed('/setting'),
            onPressed: () => navigateWithProvider(context, '/setting', ref),
          )
        ],
      ),
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 600), // Adjust this value as needed
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[        
              Text(
                '學國語',
                style: TextStyle(
                  fontSize: fontSize * 2.0,
                  color: beige,
                ),
                textAlign: TextAlign.center,
              ),
              SizedBox(height: deviceHeight * 0.05),
              _buildButton(
                context,
                ref,
                '學生字',
                () async {
                  int semesterCode = ref.watch(semesterCodeProvider);
                  int publisherCode = ref.watch(publisherCodeProvider);
                  List<Unit> units = await UnitProvider.getUnits(
                    inputPublisher: publisherCodeTable[publisherCode]!,
                    inputGrade: ref.watch(gradeProvider),
                    inputSemester: semesterCodeTable[semesterCode]!);
                  if (!context.mounted) return;    
                  navigateWithProvider(
                    context, 
                    '/units', 
                    ref, 
                    arguments: {'units': units}
                  );
                },
                fontSize,
              ),
              SizedBox(height: deviceHeight * 0.02),
              if (account == 'testerbpmf') ...[
                _buildButton(
                  context,
                  ref,
                  '檢查字詞的注音',
                  () => navigateWithProvider(context, '/checkzhuyin', ref),
                  fontSize,
                ),
                SizedBox(height: deviceHeight * 0.02),
              ], 
              if (account == 'tester' || account == 'testerbpmf') ...[
                _buildButton(
                  context,
                  ref,
                  '標示注音符號',
                  () => navigateWithProvider(context, '/duoyinzi', ref),
                  fontSize,
                ),
                SizedBox(height: deviceHeight * 0.02),
              ],              

              // You can add more widgets here if needed
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildButton(BuildContext context, WidgetRef ref, String text, VoidCallback onPressed, double fontSize) {
    return ElevatedButton(
      onPressed: onPressed,
      style: ButtonStyle(
        backgroundColor: WidgetStateProperty.all(deepBlue),
        elevation: WidgetStateProperty.all(25),
        shape: WidgetStateProperty.all<RoundedRectangleBorder>(
          RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12))),
        padding: WidgetStateProperty.all(const EdgeInsets.symmetric(vertical: 16)),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: fontSize * 1.5,
          color: beige,
        ),
        textAlign: TextAlign.center,
      ),
    );
  }        
}

// End of file: ./lib/views/main_page_view.dart
//----------------------

// File: ./lib/views/bopomo_quiz_finish.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:ltrc/extensions.dart';
import 'package:ltrc/providers.dart';
// import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';


class BopomoQuizFinishView extends ConsumerWidget {
  const BopomoQuizFinishView({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;

    return Scaffold(
        appBar: AppBar(
          leading: IconButton(
            icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
            onPressed: () => Navigator.pop(context),
          ),
          title: Text(
            "拼拼看",
            style: TextStyle(fontSize: fontSize * 1.0),
          ),
          actions: [
            IconButton(
              icon: Icon(
                Icons.home,
                size: fontSize * 1.5,
              ),
              // onPressed: () => Navigator.of(context).pushNamed('/mainPage'),
              onPressed: () => navigateWithProvider(context, '/mainPage', ref)
            )
          ],
        ),
        body: Container(
            alignment: Alignment.center,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Container(
                    height: fontSize * 3.5,
                    width: fontSize * 14.0,
                    alignment: Alignment.center,
                    decoration: const BoxDecoration(
                      color: deepBlue,
                    ),
                    child: Text('⭐恭喜⭐\n完成所有題目！',
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          fontSize: fontSize,
                          color: beige,
                        ))),
                SizedBox(
                  height: fontSize * 0.3,
                ),
                ElevatedButton(
                    onPressed: () =>
                        // Navigator.of(context).pushNamed("/bopomoQuiz"),
                        navigateWithProvider(context, '/bopomoQuiz', ref),
                    child: Text("重新測驗",
                        style: TextStyle(
                            color: Colors.black, fontSize: fontSize))),
                SizedBox(
                  height: fontSize * 0.3,
                ),
                ElevatedButton(
                    onPressed: () =>
                        // Navigator.of(context).pushNamed("/mainPage"),
                        navigateWithProvider(context, '/mainPage', ref),
                    child: Text("回首頁",
                        style:
                            TextStyle(color: Colors.black, fontSize: fontSize)))
              ],
            )));
  }
}

// End of file: ./lib/views/bopomo_quiz_finish.dart
//----------------------

// File: ./lib/views/reset_password.dart

import 'package:flutter/material.dart';
import 'package:ltrc/data/models/user_model.dart';
import 'package:ltrc/data/providers/user_provider.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/providers.dart';
// import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';

class ResetPwdView extends ConsumerStatefulWidget {
  const ResetPwdView({super.key});

  @override
  ConsumerState<ResetPwdView> createState() => _ResetPwdViewState();
}

const String pwdLengthErrorHint = "密碼長度不足 4 位英/數字";
const String pwdConfirmErrorHint = "確認密碼錯誤";

class _ResetPwdViewState extends ConsumerState<ResetPwdView> {
  bool showPasswordHint = false;
  bool pwdVisible = false;
  bool confirmPwdVisible = false;
  String showErrorHint = "";
  TextEditingController pwdController = TextEditingController();
  TextEditingController confirmPwdController = TextEditingController();

  @override
  void initState() {
    super.initState();
    pwdVisible = true;
    confirmPwdVisible = true;
    showErrorHint = "";
  }

  @override
  Widget build(BuildContext context) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    
    double deviceHeight = screenInfo.screenHeight;

    dynamic obj = ModalRoute.of(context)!.settings.arguments;
    User user = obj['user'];

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
          onPressed: () => Navigator.pop(context),
        ),
      ),
      resizeToAvoidBottomInset: false,
      backgroundColor: veryDarkGray,
      body: SizedBox.expand(
        child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: <Widget>[
              SizedBox(height: deviceHeight * 0.08),
              Text('重設密碼',
                  style: TextStyle(
                    fontSize: fontSize * 2.7,
                  )),
              SizedBox(height: deviceHeight * 0.08),
              Visibility(
                  visible: showPasswordHint,
                  maintainAnimation: true,
                  maintainSize: true,
                  maintainState: true,
                  child: Container(
                      height: fontSize * 1.4,
                      width: fontSize * 17.8,
                      alignment: AlignmentDirectional.topStart,
                      child: Text('至少4個數字',
                          style: TextStyle(
                            fontSize: fontSize * 0.8,
                          )))),
              Container(
                  height: fontSize * 3.5,
                  width: fontSize * 17.8,
                  decoration: BoxDecoration(
                      color: lightSkyBlue,
                      borderRadius: BorderRadius.circular(5),
                      border: Border.all(
                          width: 0.3 * fontSize, color: beige)),
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                    child: Focus(
                      onFocusChange: (hasFocus) {
                        setState(() {
                          showPasswordHint = !showPasswordHint;
                          if (showErrorHint == pwdLengthErrorHint &&
                              pwdController.text.length >= 4) {
                            showErrorHint = "";
                          }
                        });
                      },
                      child: TextField(
                          controller: pwdController,
                          obscureText: pwdVisible,
                          style: TextStyle(
                            color: Colors.black,
                            fontSize: fontSize,
                          ),
                          decoration: InputDecoration(
                            prefixIcon: Icon(
                              Icons.lock,
                              size: fontSize * 1.8,
                              color: veryDarkGrayishBlue,
                            ),
                            hintText: '密碼',
                            hintStyle: TextStyle(
                                fontSize: fontSize * 1.2,
                                color: deepBlue),
                            enabledBorder: InputBorder.none,
                            focusedBorder: InputBorder.none,
                            suffixIcon: IconButton(
                              icon: Icon(pwdVisible
                                  ? Icons.visibility
                                  : Icons.visibility_off),
                              iconSize: fontSize,
                              onPressed: () {
                                setState(() {
                                  pwdVisible = !pwdVisible;
                                });
                              },
                            ),
                          )),
                    ),
                  )),
              SizedBox(height: deviceHeight * 0.0343),
              Container(
                  height: fontSize * 3.5,
                  width: fontSize * 17.8,
                  decoration: BoxDecoration(
                      color: lightSkyBlue,
                      borderRadius: BorderRadius.circular(5),
                      border: Border.all(
                          width: 0.3 * fontSize, color: beige)),
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                    child: TextField(
                        controller: confirmPwdController,
                        obscureText: confirmPwdVisible,
                        style: TextStyle(
                          color: Colors.black,
                          fontSize: fontSize,
                        ),
                        decoration: InputDecoration(
                          prefixIcon: Icon(
                            Icons.lock,
                            size: fontSize * 1.8,
                            color: veryDarkGrayishBlue,
                          ),
                          hintText: '確認密碼',
                          hintStyle: TextStyle(
                              fontSize: fontSize * 1.2,
                              color: deepBlue),
                          enabledBorder: InputBorder.none,
                          focusedBorder: InputBorder.none,
                          suffixIcon: IconButton(
                            icon: Icon(confirmPwdVisible
                                ? Icons.visibility
                                : Icons.visibility_off),
                            iconSize: fontSize,
                            onPressed: () {
                              setState(() {
                                confirmPwdVisible = !confirmPwdVisible;
                              });
                            },
                          ),
                        )),
                  )),
              Visibility(
                  visible: (showErrorHint != ""),
                  maintainAnimation: true,
                  maintainSize: true,
                  maintainState: true,
                  child: Container(
                      height: fontSize * 1.4,
                      width: fontSize * 17.8,
                      alignment: AlignmentDirectional.topStart,
                      child: Text(showErrorHint,
                          style: TextStyle(
                            fontSize: fontSize * 0.8,
                          )))),
              SizedBox(height: deviceHeight * 0.0627),
              TextButton(
                  onPressed: () {
                    if (pwdController.text.length < 4) {
                      setState(() {
                        showErrorHint = pwdLengthErrorHint;
                      });
                    } else if (pwdController.text !=
                        confirmPwdController.text) {
                      setState(() {
                        showErrorHint = pwdConfirmErrorHint;
                      });
                    } else {
                      user.password = pwdController.text;
                      UserProvider.updateUser(user: user);
                      // Navigator.of(context).pushNamed('/login');
                      navigateWithProvider(context, '/login', ref);
                    }
                  },
                  child: Text('完成',
                      style: TextStyle(
                        fontSize: fontSize * 1.4,
                        color: beige,
                      )))
            ]),
      ),
    );
  }
}

// End of file: ./lib/views/reset_password.dart
//----------------------

// File: ./lib/views/sw_version_view.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/data/providers/all_provider.dart';
import 'package:ltrc/data/providers/user_provider.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';
import 'package:package_info_plus/package_info_plus.dart';

class SwVersionView extends ConsumerStatefulWidget {
  const SwVersionView({super.key});

  @override
  SwVersionViewState createState() => SwVersionViewState();
}

class SwVersionViewState extends ConsumerState<SwVersionView> {
  String appVersion = "";
  String allDatabaseVersion = "";
  String userDatabaseVersion = "";
  double fontSize = 0.0;

  @override
  void initState() {
    super.initState();
    _fetchVersionInfo();
  }

  Future<void> _fetchVersionInfo() async {
    // Get the app version from package_info_plus
    PackageInfo packageInfo = await PackageInfo.fromPlatform();
    appVersion = packageInfo.version;

    // Get the database versions (converting int to String)
    allDatabaseVersion = await _getAllDatabaseVersion();
    userDatabaseVersion = await _getUserDatabaseVersion();

    // Update the state to display the versions
    setState(() {});
  }

  Future<String> _getAllDatabaseVersion() async {
    try {
      String currentVersion = (await AllProvider.getCurrentDatabaseVersion()).toString();
      debugPrint('Current all.sqlite version: $currentVersion');
      return currentVersion;
    } catch (e) {
      debugPrint('Error fetching all.sqlite database versions: $e');
      return "Error all.sqlite"; // Error case, return -1 for invalid version
    }
  }  

  Future<String> _getUserDatabaseVersion() async {
    try {
      String currentVersion = (await UserProvider.getCurrentDatabaseVersion()).toString();
      debugPrint('Current users.sqlite version: $currentVersion');
      return currentVersion;
    } catch (e) {
      debugPrint('Error fetching users.sqlite database versions: $e');
      return "Error users.sqlite"; // Error case, return -1 for invalid version
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenInfo = ref.watch(screenInfoProvider);
    fontSize = screenInfo.fontSize;
    if (screenInfo.isTablet && MediaQuery.of(context).orientation == Orientation.landscape) {
      fontSize *= 1.3;
    }

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
          onPressed: () => Navigator.pop(context),
        ),
        title: Text(
          "版本資訊",
          style: TextStyle(
            fontSize: fontSize * 1.5,
          ),
        ),
      ),
      backgroundColor: beige, // Set background color to beige
      body: _buildVersion(),
    );
  }

  Widget _buildVersion() {
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: fontSize * 0.5, vertical: fontSize * 0.5),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'App 版本: $appVersion',
            style: TextStyle(fontSize: fontSize * 1.0, color: Colors.black),
          ),
          Text(
            'all.sqlite 版本: $allDatabaseVersion',
            style: TextStyle(fontSize: fontSize * 1.0, color: Colors.black),
          ),
          Text(
            'user.sqlite 版本: $userDatabaseVersion',
            style: TextStyle(fontSize: fontSize * 1.0, color: Colors.black),
          ),
        ],
      ),
    );
  }
}

// End of file: ./lib/views/sw_version_view.dart
//----------------------

// File: ./lib/views/check_zhuyin_view.dart

import 'dart:async';
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/data/models/word_phrase_sentence_model.dart';

import 'package:ltrc/data/providers/word_phrase_sentence_provider.dart';
import 'package:ltrc/views/view_utils.dart';

import 'package:screenshot/screenshot.dart';
import 'package:path_provider/path_provider.dart';
import 'package:intl/intl.dart';  // For date formatting

import 'package:ltrc/views/polyphonic_processor.dart';

class CheckZhuyinView extends ConsumerStatefulWidget {
  
  const CheckZhuyinView({super.key});

  @override
  CheckZhuyinViewState createState() => CheckZhuyinViewState();
}

class CheckZhuyinViewState extends ConsumerState<CheckZhuyinView> {
  Map<String, dynamic> polyphonicData = {};
  TextEditingController idController = TextEditingController();
  late double fontSize;
  List<TextSpan> concatenatedTextSpans = [];
  List<TextSpan> tempTextSpans = [];
  String concatenatedUnicode = '';  
  int maxId = 3085; // For initial testing with 10 entries
  int currentId = 1;
  final int entriesPerPage = 5;
  int totalProcessed = 0;
  int maxEntries = 1000; 
  // Create an instance of ScreenshotController
  late String directory;
  ScreenshotController screenshotController = ScreenshotController();

  @override
  void initState() {
    super.initState();
    initializeState();
  }

  Future<void> initializeState() async {
    if (kDebugMode) {
      // Use Desktop directory in debug mode
      directory = '/Users/shinjou/Desktop';
    } else {
      // Use ApplicationDocumentsDirectory in release mode
      directory = (await getApplicationDocumentsDirectory()).path;
    }    
    maxId = await WordPhraseSentenceProvider.getMaxId(); // Assuming this method fetches the maximum ID
    debugPrint('Max ID: $maxId');
    setState(() {});
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    initializeFontSize();
  }

  void initializeFontSize() {
    final mediaQueryData = MediaQuery.of(context);
    fontSize = mediaQueryData.size.width * 0.04; // Dynamically setting the font size based on screen width
  }

  @override
  void dispose() {
    super.dispose();
  }

  BoxDecoration commonBoxDecoration = BoxDecoration(
    border: Border.all(color: Colors.grey),
    borderRadius: BorderRadius.circular(4.0),
  );
  
  TextStyle get commonTextStyle => TextStyle(
    fontFamily: 'BpmfIansui',
    fontSize: fontSize * 0.9,
    // color: Colors.black,
  );

  void handleStart() async {
    if (validateId()) {
      clearFields();
      await processMaxEntries(); // Ensures all processing is done before updating the UI
    }
  }

  void updateUI() {
    if (mounted) {
      setState(() {
        // By copying to a new list, we're ensuring any state change is recognized by Flutter.
        concatenatedTextSpans = List.from(concatenatedTextSpans);
        debugPrint("Data ready to display, setState to update UI now.");
      });
    }
  }

  void clearFields() {
    // idController.clear();
    debugPrint("Clearing fields");
    concatenatedTextSpans.clear();
    tempTextSpans.clear();
    concatenatedUnicode = '';
    updateUI();
    // Other clearing logic if necessary
  }

  bool validateId() {
    int id = int.tryParse(idController.text) ?? 0;
    if (id == 0) {id = 1;}
    if (id < 1 || id > maxId) {
      debugPrint('Invalid ID. Please enter a valid number between 1 and $maxId.');
      return false;
    }
    debugPrint('Valid ID: $id (Max ID: $maxId)');
    currentId = id;
    return true;
  }

  void handleContinue() async {
    clearFields(); // Clear previous data to start fresh
    // currentId = currentId + entriesPerPage;
    totalProcessed = 0;
    await processMaxEntries(); 
  }

  Future<void> processMaxEntries() async {
    final stopwatchOriginal = Stopwatch()..start();
    while (currentId <= maxId && totalProcessed <= maxEntries) {
      await processTenEntries();
      await waitForCapture();
      if (mounted) {   
        // Ensure the widget is still mounted and the new spans are not empty before updating the UI
        // (This is to avoid unnecessary updates when there's no new data to display      
        setState (() {
          totalProcessed += entriesPerPage;
          currentId += entriesPerPage;               
          concatenatedTextSpans.clear();
          concatenatedTextSpans = List.from(concatenatedTextSpans);
        });
      }      
    }
    stopwatchOriginal.stop();
    debugPrint('Process time: ${stopwatchOriginal.elapsedMicroseconds} microseconds');       
  }

  Future<void> processTenEntries() async {
    // debugPrint('Processing entries from ID $currentId to ${currentId + entriesPerPage -1}');
    List<TextSpan> newSpans = [];
    for (int id = currentId; id <= maxId && id < currentId + entriesPerPage; id++) {
      try {
        var spans = await processWordPhraseSentenceById(id);
        newSpans.addAll(spans);
        // debugPrint('Processing ID = $id, ${spans.length} spans; total ${newSpans.length} spans.');
      } catch (e) {
        debugPrint('Failed to process entry with ID $id: $e');
      }
    }
    if (mounted && newSpans.isNotEmpty) {
      // Ensure the widget is still mounted and the new spans are not empty before updating the UI
      // (This is to avoid unnecessary updates when there's no new data to display      
      setState (() {
        concatenatedTextSpans.addAll(newSpans);
        concatenatedTextSpans = List.from(concatenatedTextSpans);
        // debugPrint("processTenEntries: Data ready to display, update UI now. ${concatenatedTextSpans.length} $concatenatedTextSpans");        
      });
    }
  }

  Future<List<TextSpan>> processWordPhraseSentenceById(int id) async {
      List<TextSpan> tempTextSpans = [];
      try {
          // debugPrint("Starting to process ID $id.");
          WordPhraseSentence? entry = await WordPhraseSentenceProvider.getWordPhraseSentenceById(inputWordPhraseSentenceId: id);
          if (entry == null) {
              // Handle the case where the entry does not exist
              debugPrint("No entry found for ID $id.");
              return tempTextSpans;
          }
          
          // debugPrint("Processing word for ID $id: ${entry.word}");
          var processedWord = await PolyphonicProcessor.instance.process(entry.word, fontSize * 0.9, Colors.black, true);
          // debugPrint("Processed word for ID $id: ${processedWord.item2}");
          
          // debugPrint("Processing phrase for ID $id: ${entry.phrase}");
          var processedPhrase = await PolyphonicProcessor.instance.process(entry.phrase, fontSize * 0.9, Colors.black, true);
          // debugPrint("Processed phrase for ID $id: ${processedPhrase.item2}");
          var processedPhraseDef = await PolyphonicProcessor.instance.process(entry.definition, fontSize * 0.9, Colors.black, true);

          // debugPrint("Processing sentence for ID $id: ${entry.sentence}");
          var processedSentence = await PolyphonicProcessor.instance.process(entry.sentence, fontSize * 0.9, Colors.black, true);
          // debugPrint("Processed sentence for ID $id: ${processedSentence.item2}");
          
          // debugPrint("Processing phrase2 for ID $id: ${entry.phrase2}");
          var processedPhrase2 = await PolyphonicProcessor.instance.process(entry.phrase2, fontSize * 0.9, Colors.black, true);
          // debugPrint("Processed phrase2 for ID $id: ${processedPhrase2.item2}");
          var processedPhraseDef2 = await PolyphonicProcessor.instance.process(entry.definition2, fontSize * 0.9, Colors.black, true); 

          // debugPrint("Processing sentence2 for ID $id: ${entry.sentence2}");
          var processedSentence2 = await PolyphonicProcessor.instance.process(entry.sentence2, fontSize * 0.9, Colors.black, true);
          // debugPrint("Processed sentence2 for ID $id: ${processedSentence2.item2}");
          
          // Concatenating results for TextSpans
          tempTextSpans.add(TextSpan(text: "$id: ", style: const TextStyle(color: Colors.black)));
          tempTextSpans.addAll(processedWord.item1);
          tempTextSpans.add(const TextSpan(text: "\n"));
          tempTextSpans.addAll(processedPhrase.item1);
          tempTextSpans.add(const TextSpan(text: " "));
          tempTextSpans.addAll(processedPhraseDef.item1);
          tempTextSpans.add(const TextSpan(text: " "));          
          tempTextSpans.addAll(processedSentence.item1);
          tempTextSpans.add(const TextSpan(text: "\n"));
          tempTextSpans.addAll(processedPhrase2.item1);
          tempTextSpans.add(const TextSpan(text: " "));
          tempTextSpans.addAll(processedPhraseDef2.item1);
          tempTextSpans.add(const TextSpan(text: " "));                    
          tempTextSpans.addAll(processedSentence2.item1);
          tempTextSpans.add(const TextSpan(text: "\n"));
          // debugPrint("Finished processing ID $id. Total spans: ${tempTextSpans.length}");

          // Concatenating results for Unicode Strings
          concatenatedUnicode += "$id: ${processedWord.item2} : ";
          concatenatedUnicode += "${processedPhrase.item2} ";
          concatenatedUnicode += "${processedPhraseDef.item2} ";          
          concatenatedUnicode += "${processedSentence.item2} ";
          concatenatedUnicode += "${processedPhrase2.item2} ";
          concatenatedUnicode += "${processedPhraseDef2.item2} ";              
          concatenatedUnicode += "${processedSentence2.item2}\n";
          // debugPrint("Finished processing ID $id. Unicode: $concatenatedUnicode");

      } catch (e) {
          debugPrint('Error processing data: $e');
      }
      // debugPrint("Finished processing ID $id. Total spans: ${tempTextSpans.length}");
      return tempTextSpans;
  }


  Future<void> captureAndSave() async {
    try {
      String formattedDateTime = DateFormat('yyyy-MM-dd-HH-mm-ss').format(DateTime.now());
      String fileName = '字詞_$currentId-${currentId + entriesPerPage - 1}_$formattedDateTime.png';
      String fullPath = '$directory/$fileName';
      // debugPrint('Saving screenshot to $fullPath');

      Uint8List? image = await screenshotController.capture();
      if (image != null) {
        File imgFile = File(fullPath);
        await imgFile.writeAsBytes(image);
        debugPrint("Screenshot saved to $fullPath");
      } else {
        debugPrint("captureAndSave error: Screenshot capture returned null");
      }
    } catch (e) {
      debugPrint("captureAndSave error: $e");
    }
  }

  Future<void> waitForCapture() async {
    await Future.delayed(const Duration(seconds: 1));
    await captureAndSave();
  }

  @override
  Widget build(BuildContext context) {
    // debugPrint("Building CheckZhuyinView widget...");
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        leading: IconButton(
          icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
          onPressed: () => Navigator.pop(context),
        ),
        title: Text("詞句注音/多音字", style: commonTextStyle), 
        actions: [
          IconButton(
            icon: Icon(Icons.home, size: fontSize * 1.5),
            // onPressed: () => Navigator.of(context).pushNamed('/mainPage'),
            onPressed: () => navigateWithProvider(context, '/mainPage', ref),
          )
        ],
      ),      

      body: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.all(10),
            child: Row(
              children: <Widget>[
                Expanded(
                  child: TextField(
                    controller: idController,
                    keyboardType: const TextInputType.numberWithOptions(decimal: false),
                    decoration: const InputDecoration(
                      labelText: 'Start ID',
                      hintText: '生字 id',
                      border: OutlineInputBorder(),
                      contentPadding: EdgeInsets.symmetric(vertical: 10, horizontal: 10),
                    ),
                    style: TextStyle(fontSize: fontSize, color: Colors.black),
                    maxLength: 7,
                  ),
                ),
                const SizedBox(width: 10),
                ElevatedButton(
                  onPressed: () => handleStart(),
                  child: Text(
                    '開始', style: TextStyle(fontSize: fontSize),
                  ),
                ),
                // if (concatenatedTextSpans.isNotEmpty)
                //   RichText(text: TextSpan(children: concatenatedTextSpans)),
                const SizedBox(height: 10),
                ElevatedButton(
                  onPressed: () => handleContinue(),
                  child: Text(
                    '繼續', style: TextStyle(fontSize: fontSize),
                  ),                  
                ),
                const SizedBox(height: 10),
                ElevatedButton(
                  onPressed: () => clearFields(),
                  child: Text(
                    '清除', style: TextStyle(fontSize: fontSize),
                  ),                  
                ),

              ],
            ),
          ),

          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(10),
              child: Screenshot(
                controller: screenshotController,              
                child: Container(
                  color: Colors.white,
                  // decoration: commonBoxDecoration,
                  padding: const EdgeInsets.symmetric(vertical: 0, horizontal: 8),
                  margin: const EdgeInsets.all(10),
                  child: RichText(
                    text: TextSpan(
                      children: concatenatedTextSpans,
                      style: commonTextStyle.copyWith(height: 1.2),
                    ),
                  ),         
                )
              ),
            ),
          ),        
        ],
      )

    );
  }

}

// End of file: ./lib/views/check_zhuyin_view.dart
//----------------------

// File: ./lib/views/setting_view.dart

// setting_view.dart is a stateful widget that displays the settings page.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/contants/arabic_numerals_to_chinese.dart';
import 'package:ltrc/contants/semester_code.dart';
import 'package:ltrc/contants/publisher_code.dart';
import 'package:ltrc/data/models/user_model.dart';
import 'package:ltrc/data/providers/unit_provider.dart';
import 'package:ltrc/data/providers/user_provider.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';

class SettingView extends ConsumerStatefulWidget {
  const SettingView({super.key});

  @override
  SettingViewState createState() => SettingViewState();
}

class SettingViewState extends ConsumerState<SettingView> {
  late TextEditingController nameController;
  late String account;
  final TextEditingController gradeController = TextEditingController();
  final TextEditingController semesterController = TextEditingController();
  final TextEditingController publisherController = TextEditingController();
  var currentSliderValue = 0.5;



  late double fontSize;
  late double deviceHeight;
  late double deviceWidth;

  @override
  void initState() {
    super.initState();
    nameController = TextEditingController();
    account = "";
  }

  @override
  void dispose() {
    nameController.dispose();
    gradeController.dispose();
    semesterController.dispose();
    publisherController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenInfo = ref.watch(screenInfoProvider);
    fontSize = screenInfo.fontSize;
    deviceHeight = screenInfo.screenHeight;
    deviceWidth = screenInfo.screenWidth;
    debugPrint('setting_view: H: $deviceHeight, W: $deviceWidth, F: $fontSize');

    final List<DropdownMenuEntry<int>> gradeEntries = [];
    final List<DropdownMenuEntry<int>> semesterEntries = [];
    final List<DropdownMenuEntry<int>> publisherEntries = [];

    account = ref.watch(accountProvider);
    int selectedGrade = ref.watch(gradeProvider);
    int selectedSemester = ref.watch(semesterCodeProvider);
    int selectedPublisher = ref.watch(publisherCodeProvider);

    gradeController.text = numeralToChinese[selectedGrade]!;
    semesterController.text = semesterCodeTable[selectedSemester]!;
    publisherController.text = publisherCodeTable[selectedPublisher]!;

    currentSliderValue = ref.watch(soundSpeedProvider);

    // Populate dropdown entries
    _populateDropdownEntries(gradeEntries, semesterEntries, publisherEntries);

    return SafeArea( // Wrap the content inside a SafeArea
      child: Scaffold(
        resizeToAvoidBottomInset: false,
        backgroundColor: veryDarkGray,
        body: Center(
          child: Stack(
            alignment: Alignment.center,
            children: <Widget>[
              _buildBackgroundContainer(),
              Positioned(
                top: fontSize * 1.0,
                left: fontSize * 1.0,
                child: _buildContentContainer(
                  gradeEntries,
                  semesterEntries,
                  publisherEntries,
                  selectedGrade,
                  selectedSemester,
                  selectedPublisher,
                ),
              ),
              // Close button with tap detection
              Positioned(
                top: fontSize,  // Ensure the close button is below the notch
                right: fontSize,
                child: GestureDetector(
                  onTap: () {
                    debugPrint('Close button tapped');
                    _handleCloseButton();
                  },
                  child: Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.red, width: 2),  // Red border for visibility
                    ),
                    child: const Icon(Icons.close, color: Colors.black, size: 30),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _populateDropdownEntries(
      List<DropdownMenuEntry<int>> gradeEntries,
      List<DropdownMenuEntry<int>> semesterEntries,
      List<DropdownMenuEntry<int>> publisherEntries,
    ) {
      for (var key in [1, 2, 3, 4, 5, 6]) {
        gradeEntries.add(DropdownMenuEntry<int>(
          value: key,
          label: numeralToChinese[key]!,
          style: ButtonStyle(
            textStyle: WidgetStateProperty.all<TextStyle>(
              TextStyle(fontSize: fontSize * 0.6, color: veryDarkGrayishBlue),
            ),
          ),
        ));
      }

      for (var key in semesterCodeTable.keys) {
        semesterEntries.add(DropdownMenuEntry<int>(
          value: key,
          label: semesterCodeTable[key]!,
          style: ButtonStyle(
            textStyle: WidgetStateProperty.all<TextStyle>(
              TextStyle(fontSize: fontSize * 0.6, color: veryDarkGrayishBlue),
            ),
          ),
        ));
      }

      for (var key in publisherCodeTable.keys) {
        publisherEntries.add(DropdownMenuEntry<int>(
          value: key,
          label: publisherCodeTable[key]!,
          style: ButtonStyle(
            textStyle: WidgetStateProperty.all<TextStyle>(
              TextStyle(fontSize: fontSize * 0.6, color: veryDarkGrayishBlue),
            ),
          ),
        ));
      }
    }

  Widget _buildBackgroundContainer() {
    return Container(
      height: deviceHeight,
      width: deviceWidth,
      decoration: const BoxDecoration(
        color: deepBlue,
        borderRadius: BorderRadius.only(
          bottomLeft: Radius.circular(10),
          bottomRight: Radius.circular(10),
        ),
      ),
    );
  }

  Widget _buildContentContainer(
    List<DropdownMenuEntry<int>> gradeEntries,
    List<DropdownMenuEntry<int>> semesterEntries,
    List<DropdownMenuEntry<int>> publisherEntries,
    int selectedGrade,
    int selectedSemester,
    int selectedPublisher,
  ) {
    return Container(
      height: deviceHeight * 0.95,
      width: deviceWidth * 0.92,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(16),
        color: beige,
      ),
      child: Column(
        children: [
          _buildTopBar(),
          _buildAccountSection(),
          _buildDropdownSection('年級', gradeController, gradeEntries, selectedGrade, _handleGradeChange),
          _buildDropdownSection('學期', semesterController, semesterEntries, selectedSemester, _handleSemesterChange),
          _buildDropdownSection('課本出版社', publisherController, publisherEntries, selectedPublisher, _handlePublisherChange),
          _buildSlider(),
          _buildAcknowledgmentSection(),
          _buildSwVersion(),          
          SizedBox(height: fontSize * 0.2),
          _buildAccountActions(),
        ],
      ),
    );
  }

  Widget _buildTopBar() {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: fontSize * 0.5, horizontal: fontSize * 1.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: <Widget>[
          Row(children: <Widget>[
            Icon(Icons.settings, color: Colors.black, size: fontSize * 1.2),
            Padding(
              padding: EdgeInsetsDirectional.fromSTEB(fontSize, 0, 0, 0),
              child: Text('設定', style: TextStyle(fontSize: fontSize * 1.2, color: Colors.black)),
            ),
          ]),
        ],
      ),
    );
  }

  Widget _buildAccountSection() {
    return Padding(
      padding: EdgeInsetsDirectional.symmetric(horizontal: fontSize * 0.5, vertical: deviceHeight * 0.01),
      child: Container(
        height: fontSize * 1.8,
        width: deviceWidth * 0.85,
        margin: EdgeInsetsDirectional.fromSTEB(deviceWidth * 0.0513, deviceHeight * 0.032, 0, deviceHeight * 0.024),
        child: Row(
          children: [
            Icon(Icons.account_circle, color: veryDarkGrayishBlue, size: fontSize * 2.0),
            SizedBox(width: fontSize * 0.3),
            Flexible(
              child: Text(
                account,
                style: TextStyle(
                  color: Colors.black,
                  fontSize: (account.length) < 5 ? fontSize : (account.length) < 12 ? fontSize : fontSize * 0.8,
                ),
              ),
            ),
            SizedBox(width: fontSize * 0.7),
          ],
        ),
      ),
    );
  }

  Widget _buildDropdownSection(
    String label,
    TextEditingController controller,
    List<DropdownMenuEntry<int>> entries,
    int selectedValue,
    Function(int?) onChanged,
  ) {
    return Padding(
      padding: EdgeInsetsDirectional.symmetric(horizontal: fontSize * 0.5, vertical: deviceHeight * 0.01),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Text(label, style: TextStyle(fontSize: fontSize * 1.0, color: Colors.black)),
          DropdownMenu<int>(
            controller: controller,
            width: label == '年級' ? 6.0 * fontSize : label == '學期' ? 7.1 * fontSize : 8.2 * fontSize,
            textStyle: TextStyle(color: Colors.black, fontSize: fontSize),
            dropdownMenuEntries: entries,
            initialSelection: selectedValue,
            onSelected: onChanged,
          ),
        ],
      ),
    );
  }

  Widget _buildSlider() {
    return Padding(
      padding: EdgeInsetsDirectional.symmetric(horizontal: fontSize * 0.5, vertical: deviceHeight * 0.01),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        mainAxisSize: MainAxisSize.max,
        children: <Widget>[
          Text('撥放速度', style: TextStyle(color: Colors.black, fontSize: fontSize * 1.0)),
          SizedBox(
            width: 8.2 * fontSize,
            child: Slider(
              value: currentSliderValue,
              max: 1.0,
              divisions: 10,
              onChanged: (double value) {
                setState(() {
                  currentSliderValue = value;
                });
                ref.read(soundSpeedProvider.notifier).state = value;
                debugPrint('Slider changed to value: $currentSliderValue');
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAcknowledgmentSection() {
    return Padding(
      padding: EdgeInsetsDirectional.symmetric(horizontal: fontSize * 0.5, vertical: deviceHeight * 0.01),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        mainAxisSize: MainAxisSize.max,
        children: <Widget>[
          Text('授權與致謝', style: TextStyle(color: Colors.black, fontSize: fontSize * 1.0)),
          IconButton(
            onPressed: () => navigateWithProvider(context, '/acknowledge', ref),
            icon: const Icon(Icons.arrow_forward_ios),
            color: Colors.black,
            iconSize: fontSize * 1.2,
          ),
        ],
      ),
    );
  }

  Widget _buildSwVersion() {
    return Padding(
      padding: EdgeInsetsDirectional.symmetric(horizontal: fontSize * 0.5, vertical: deviceHeight * 0.01),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        mainAxisSize: MainAxisSize.max,
        children: <Widget>[
          Text('版本資訊', style: TextStyle(color: Colors.black, fontSize: fontSize * 1.0)),
          IconButton(
            onPressed: () => navigateWithProvider(context, '/swversion', ref),
            icon: const Icon(Icons.arrow_forward_ios),
            color: Colors.black,
            iconSize: fontSize * 1.2,
          ),
        ],
      ),
    );
  }

  Widget _buildAccountActions() {
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: fontSize * 0.5), // Reduce the padding around the buttons
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        mainAxisSize: MainAxisSize.max,
        children: [
          if (account != 'tester' && account != 'testerbpmf')
            Flexible(
              child: TextButton(
                onPressed: () => _showDeleteAccountDialog(),
                style: TextButton.styleFrom(
                  padding: EdgeInsets.symmetric(vertical: fontSize * 0.5), // Reduce the vertical padding
                  backgroundColor: Colors.grey.shade200, // Add a background color for visibility
                ),
                child: Text(
                  '刪除帳號',
                  style: TextStyle(color: Colors.black, fontSize: fontSize * 0.9), // Adjust font size
                  overflow: TextOverflow.ellipsis, // Prevent overflow
                ),
              ),
            ),
          SizedBox(width: fontSize * 0.5), // Add some spacing between buttons

          Flexible(
            child: TextButton(
              onPressed: _handleLogout,
              style: TextButton.styleFrom(
                padding: EdgeInsets.symmetric(vertical: fontSize * 0.5),
                backgroundColor: Colors.grey.shade200,
              ),
              child: Text(
                '登出',
                style: TextStyle(color: Colors.black, fontSize: fontSize * 0.9),
                overflow: TextOverflow.ellipsis, // Prevent overflow
              ),
            ),
          ),
          SizedBox(width: fontSize * 0.5), // Add some spacing between buttons

          Flexible(
            child: TextButton(
              onPressed: _handleCloseButton,
              style: TextButton.styleFrom(
                padding: EdgeInsets.symmetric(vertical: fontSize * 0.5),
                backgroundColor: Colors.grey.shade200,
              ),
              child: Text(
                '儲存',
                style: TextStyle(color: Colors.black, fontSize: fontSize * 0.9),
                overflow: TextOverflow.ellipsis, // Prevent overflow
              ),
            ),
          ),
        ],
      ),
    );
  }


  void _handleCloseButton() {
    debugPrint('_handleCloseButton called');
    
    // Capture the current route before attempting to pop
    debugPrint('Current route before pop: ${ModalRoute.of(context)?.settings.name}');
    
    if (Navigator.of(context).canPop()) {
      debugPrint('Navigator can pop. Popping from the stack.');
      
      Navigator.of(context).pop();  // Attempt to pop the page
    } else {
      debugPrint('Navigator cannot pop. Navigating to main page.');
      
      if (mounted) {
        navigateWithProvider(context, '/mainPage', ref);  // Fallback navigation
      }
    }
    
    // Log the route after pop without delay
    debugPrint('Current route after pop: ${ModalRoute.of(context)?.settings.name}');
  }

  void _handleGradeChange(int? grade) async {
    if (grade == null) return;
    try {
      User userToUpdate = await UserProvider.getUser(inputAccount: account);
      userToUpdate.grade = grade;
      await UserProvider.updateUser(user: userToUpdate);
      if (!context.mounted) return;
      ref.read(gradeProvider.notifier).state = grade;
      _updateWordCounts(grade: grade);
    } catch (e) {
      debugPrint('Error updating grade: $e');
    }
  }

  void _handleSemesterChange(int? semester) async {
    if (semester == null) return;
    try {
      User userToUpdate = await UserProvider.getUser(inputAccount: account);
      userToUpdate.semester = semesterCodeTable[semester]!;
      await UserProvider.updateUser(user: userToUpdate);
      if (!context.mounted) return;
      ref.read(semesterCodeProvider.notifier).state = semester;
      _updateWordCounts(semester: semester);
    } catch (e) {
      debugPrint('Error updating semester: $e');
    }
  }

  void _handlePublisherChange(int? publisher) async {
    if (publisher == null) return;
    try {
      User userToUpdate = await UserProvider.getUser(inputAccount: account);
      userToUpdate.publisher = publisherCodeTable[publisher]!;
      await UserProvider.updateUser(user: userToUpdate);
      if (!context.mounted) return;
      ref.read(publisherCodeProvider.notifier).state = publisher;
      _updateWordCounts(publisher: publisher);
    } catch (e) {
      debugPrint('Error updating publisher: $e');
    }
  }

  void _updateWordCounts({int? grade, int? semester, int? publisher}) async {
    try {
      int selectedGrade = grade ?? ref.read(gradeProvider);
      int selectedSemester = semester ?? ref.read(semesterCodeProvider);
      int selectedPublisher = publisher ?? ref.read(publisherCodeProvider);

      ref.read(totalWordCountProvider.notifier).state = await UnitProvider.getTotalWordCount(
        inputPublisher: publisherCodeTable[selectedPublisher]!,
        inputGrade: selectedGrade,
        inputSemester: semesterCodeTable[selectedSemester]!,
      );

      ref.read(learnedWordCountProvider.notifier).state = await UnitProvider.getLearnedWordCount(
        inputAccount: account,
        inputPublisher: publisherCodeTable[selectedPublisher]!,
        inputGrade: selectedGrade,
        inputSemester: semesterCodeTable[selectedSemester]!,
      );
    } catch (e) {
      debugPrint('Error updating word counts: $e');
    }
  }

  void _showDeleteAccountDialog() {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text("刪除帳號"),
          content: Text(
            "您確定要刪除您的帳號 $account 嗎？",
            style: TextStyle(color: Colors.black, fontSize: fontSize * 1.0),
          ),
          actions: <Widget>[
            TextButton(
              child: Text('取消', style: TextStyle(color: Colors.black, fontSize: fontSize * 1.0)),
              onPressed: () => Navigator.of(context).pop(),
            ),
            TextButton(
              child: Text('確定', style: TextStyle(color: Colors.black, fontSize: fontSize * 1.0)),
              onPressed: () async {
                try {
                  await UserProvider.deleteUser(inputAccount: account);
                  if (!context.mounted) return;
                  navigateWithProvider(context, '/login', ref);
                  debugPrint('Deleted account $account');
                } catch (e) {
                  debugPrint('Error deleting account: $e');
                }
              },
            ),
          ],
        );
      },
    );
  }

  void _handleLogout() {
    ref.read(accountProvider.notifier).state = "";
    ref.read(userNameProvider.notifier).state = "";
    ref.read(gradeProvider.notifier).state = 1;
    ref.read(semesterCodeProvider.notifier).state = 0;
    ref.read(publisherCodeProvider.notifier).state = 0;
    navigateWithProvider(context, '/login', ref);
  }

}


// End of file: ./lib/views/setting_view.dart
//----------------------

// File: ./lib/views/duoyinzi_view.dart

// import 'dart:async';
// import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter_tts/flutter_tts.dart';
import 'package:fluttertoast/fluttertoast.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/providers.dart';
// import 'package:ltrc/providers.dart';
import 'package:ltrc/views/polyphonic_processor.dart';
import 'package:ltrc/views/view_utils.dart';

// import 'package:path_provider/path_provider.dart';

class DuoyinziView extends ConsumerStatefulWidget {
  
  const DuoyinziView({super.key});

  @override
  DuoyinziViewState createState() => DuoyinziViewState();
}

class DuoyinziViewState extends ConsumerState<DuoyinziView> {
  // List<Unit> units = [];
  Map<String, dynamic> polyphonicData = {};
  final TextEditingController _controller = TextEditingController();
  List<TextSpan> processedTextSpans = [];
  String processedUnicode = '';
  late FlutterTts ftts;
  late double fontSize;

  @override
  void initState() {
    super.initState();

    ftts = FlutterTts();
    initializeTts();
  }

  @override
  void dispose() {
    super.dispose();
  }

  void initializeTts() {
    ftts.setStartHandler(() {
      debugPrint("TTS Start");
    });

    ftts.setCompletionHandler(() {
      debugPrint("TTS Complete");
    });

    ftts.setErrorHandler((msg) {
      debugPrint("TTS Error: $msg");
    });

    // Set language, pitch, volume, and other parameters as needed
    ftts.setLanguage("zh-tw");
    ftts.setSpeechRate(0.5); 
    ftts.setPitch(1.0);     
  }

  void handleStart() async {
    String text = _controller.text;
    debugPrint("Text entered: $text");
    // final stopwatchOriginal = Stopwatch()..start();
    var result = await PolyphonicProcessor.instance.process(text, fontSize * 1.2, Colors.white, true);
    // stopwatchOriginal.stop();
    // debugPrint('Process time: ${stopwatchOriginal.elapsedMicroseconds} microseconds');    
    processedTextSpans = result.item1;
    processedUnicode = result.item2;    
    setState(() {}); // Trigger a rebuild to display the processed text
  }

  void clearFields() {
    setState(() {
      _controller.clear();
      processedTextSpans = [];
      processedUnicode = '';
    });
  }

  void handleCopy() {
    debugPrint('Copying to clipboard: $processedUnicode');
    Clipboard.setData(ClipboardData(text: processedUnicode));
    Fluttertoast.showToast(
      msg: '已複製到剪貼簿!',
      toastLength: Toast.LENGTH_SHORT,
      gravity: ToastGravity.BOTTOM,
      timeInSecForIosWeb: 1,
      backgroundColor: Colors.grey,
      textColor: Colors.white,
      fontSize: fontSize,
    );
  }

  BoxDecoration commonBoxDecoration = BoxDecoration(
    border: Border.all(color: Colors.grey),
    borderRadius: BorderRadius.circular(4.0),
  );
  
  TextStyle get commonTextStyle => TextStyle(
    fontFamily: 'BpmfIansui',
    fontSize: fontSize * 1.2,
  );

  void _speakText() async {
    debugPrint('Speaking: ${_controller.text}');
    await ftts.speak(_controller.text);
  }

  @override
  Widget build(BuildContext context) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    fontSize = screenInfo.fontSize;   

    if (kDebugMode) {
      final stackTrace = StackTrace.current.toString().split('\n');
      final relevantStackTrace = '\n${stackTrace[0]}\n${stackTrace[1]}';
      debugPrint('DuoyinziView build: fontSize: $fontSize, stack: $relevantStackTrace');
    }    

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
          onPressed: () => Navigator.pop(context),
        ),
        title: Text("標示注音符號", style: commonTextStyle), 
        actions: [
          IconButton(
            icon: Icon(Icons.home, size: fontSize * 1.5),
            // onPressed: () => Navigator.of(context).pushNamed('/mainPage'),
            onPressed: () => navigateWithProvider(context, '/mainPage', ref),
          )
        ],
      ),      
      // backgroundColor: const Color(0xFFb0ebe4),
      body: Container(
        margin: EdgeInsets.all(fontSize * 0.5),
        padding: EdgeInsets.all(fontSize * 0.5),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: <Widget>[
            Expanded(
              child: Container(
                decoration: commonBoxDecoration,
                padding: const EdgeInsets.symmetric(vertical: 0), // Adjust vertical padding if necessary
                margin: const EdgeInsets.all(10), // Consistent outer margin
                child: TextField(
                  controller: _controller,
                  style: commonTextStyle,
                  decoration: InputDecoration(
                    hintText: '請貼上要標示注音符號的文字，然後按「開始」。',
                    hintMaxLines: 3,
                    hintStyle: TextStyle(color: Colors.white70, fontSize: fontSize, fontFamily: 'BpmfIansui'),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(4.0),
                      borderSide: BorderSide.none,
                    ),
                    contentPadding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10), // Consistent padding inside the TextField
                  ),
                  keyboardType: TextInputType.multiline,
                  maxLines: null, // Set null to enable multiline input
                  // minLines: 1, // Use a minLines to ensure it starts with a single line
                ),
              ),
            ),
            
            SizedBox(height: fontSize * 0.5),
            
            Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: <Widget>[
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: <Widget>[
                      ElevatedButton(
                        onPressed: handleStart,
                        child: Text('開始', style: commonTextStyle),
                      ),
                      SizedBox(width: fontSize),
                      ElevatedButton(
                        onPressed: clearFields,
                        child: Text('清除', style: commonTextStyle),
                      ),
                      IconButton(
                        icon: Icon(
                          Icons.volume_up,
                          size: fontSize * 2.0,  // Adjusting the size to 1.5 times the base font size
                          color: Colors.white,  // Setting the icon color to white
                        ),
                        onPressed: _speakText,
                        // color: commonTextStyle.color, // Apply color from commonTextStyle
                      ),
                    ],
                  ),
                  // SizedBox(height: fontSize * 0.5),
                ],
              ),
            ),

            SizedBox(height: fontSize * 0.5),
            Expanded(
              child: SingleChildScrollView(
                child: Container(
                  decoration: commonBoxDecoration,
                  // padding: const EdgeInsets.fromLTRB(12, 8, 8, 8), // Adjust padding as needed
                  padding: const EdgeInsets.symmetric(vertical: 0, horizontal: 8,), // Adjust vertical padding if necessary                  
                  margin: const EdgeInsets.all(10),             
                  child: RichText(
                    text: TextSpan(
                      children: processedTextSpans,
                      style: commonTextStyle.copyWith(height: 1.5), // Adjust the `height` to match the upper box
                    ),
                  ),
                ),
              ),
            ),

            Container(
              alignment: Alignment.center,
              margin: EdgeInsets.only(bottom: fontSize * 0.5),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  ElevatedButton(
                    onPressed: handleCopy,
                    style: ElevatedButton.styleFrom(
                      textStyle: commonTextStyle.copyWith(fontSize: fontSize * 1.2), // Adjust the fontSize here
                      padding: EdgeInsets.symmetric(horizontal: fontSize, vertical: fontSize * 0.5),
                    ),
                    child: Text('複製', style: commonTextStyle), // Removed 'const' to apply the dynamic style
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// End of file: ./lib/views/duoyinzi_view.dart
//----------------------

// File: ./lib/views/teach_word_view.dart

// teach_word_view.dart 
//（Needs to incorporate the changes or comments from teach_word_view_ok.dart）

import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:flutter_riverpod/flutter_riverpod.dart'
    hide ChangeNotifierProvider, Consumer;
import 'package:flutter_tts/flutter_tts.dart';
import 'package:fluttertoast/fluttertoast.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:ltrc/contants/bopomos.dart';
import 'package:ltrc/data/models/word_status_model.dart';
import 'package:ltrc/data/providers/word_status_provider.dart';
// import 'package:ltrc/extensions.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';
import 'package:ltrc/widgets/mainPage/left_right_switch.dart';
import 'package:ltrc/widgets/teach_word/bpmf_vocab_content.dart';
import 'package:ltrc/widgets/teach_word/card_title.dart';
import 'package:ltrc/widgets/teach_word/tab_bar_view.dart';
import 'package:ltrc/widgets/teach_word/stroke_order_animator.dart';
import 'package:ltrc/widgets/teach_word/stroke_order_animation_controller.dart';
import 'package:ltrc/widgets/teach_word/word_vocab_content.dart';
import 'package:ltrc/widgets/word_card.dart';
import 'package:provider/provider.dart';

class TeachWordView extends ConsumerStatefulWidget {
  final int unitId;
  final String unitTitle;
  final List<WordStatus> wordsStatus;
  final List<Map> wordsPhrase;
  final int wordIndex;

  const TeachWordView({
    super.key,
    required this.unitId,
    required this.unitTitle,
    required this.wordsStatus,
    required this.wordsPhrase,
    required this.wordIndex,
  });

  @override
  TeachWordViewState createState() => TeachWordViewState();
}

class TeachWordViewState extends ConsumerState<TeachWordView>
    with TickerProviderStateMixin {
  StrokeOrderAnimationController? _strokeOrderAnimationControllers;
  late TabController _tabController;
  FlutterTts ftts = FlutterTts();
  final player = AudioPlayer();
  late Map wordsPhrase;
  late Map wordObj;
  int vocabCnt = 0;
  bool img1Exist = false;
  bool img2Exist = false;
  bool wordExist = false; // 字存在，但是 json 可能不存在 (svgFileExist = false)
  bool svgFileExist = false; // 字存在，json 也存在
  double fontSize = 0; // 移到這裡，因為其他地方也會用到
  int practiceTimeLeft = 4;
  int nextStepId = 0;
  bool isBpmf = false;
  int vocabIndex = 0;
  ValueNotifier<int> currentTabIndex = ValueNotifier(0);
  // Define the color used for the background
  static const Color backgroundColor = Color.fromRGBO(245, 245, 220, 100);
  bool get wordIsLearned =>
      widget.wordsStatus[widget.wordIndex].learned; // 這才是正確的方法
  bool _showErrorDialog = false;
  bool _firstNullStroke = true;

  // List<Offset?> _points = <Offset>[];  // Define the _points variable to track user's stroke points
  // bool _isDrawingMode = false;
  // DateTime? _lastPointerMoveLogTime;

  void nextTab() async {
    // nextTab() is called in many places, one setState() is called
    // it will update the nextStepId, currentTabIndex, and call showNoSvgDialog() if no SVG in 寫一寫    
    if (kDebugMode) {
      final stackTrace = StackTrace.current.toString().split('\n');
      final relevantStackTrace = '\n${stackTrace[0]}\n${stackTrace[1]}';
      debugPrint('nextTab invoked at nextStepId: $nextStepId, currentTabIndex: ${currentTabIndex.value}, stack: $relevantStackTrace');
    }

    // If we're already at the last step, stop advancing
    if (nextStepId >= steps['goToUse2']!) {
      debugPrint('nextTab: Reached the final step, stopping navigation.');
      return;
    }

    int savedNextStepId = nextStepId;
    currentTabIndex.value += 1;

    if (svgFileExist) {
      if (wordIsLearned) { // 字已學
        if (savedNextStepId > 1 && savedNextStepId < 8) { // 1-7 different steps in 寫一寫         
          nextStepId = steps['goToUse1']!;
          debugPrint('nextTab 字已學，要從“寫一寫”中的任一步驟，跳到“用一用”，savedId: $savedNextStepId，nextId: $nextStepId');
        } else { // 0, 8, 9
          // nextStepId += 1; sjf 9/8/24
          debugPrint('nextTab 字已學，savedId: $savedNextStepId，nextId: $nextStepId');
        }
      } else { // 字未學，一步一步來  
        // nextStepId += 1; sjf 9/8/24
        debugPrint('nextTab 字未學，savedId: $savedNextStepId，nextId: $nextStepId');
      }
    } else { // no SVG
      if (nextStepId > steps['goToListen']! && nextStepId < steps['goToUse1']!) {
        debugPrint('nextTab no SVG1. 從 “聽一聽”到“寫一寫”. Show error message.');
        WidgetsBinding.instance.addPostFrameCallback((_) async {
          // 選聽一聽，nextStepId = goToListen; 選用一用，nextStepId = goToUse1
          await showNoSvgDialog('','抱歉，「${widget.wordsStatus[widget.wordIndex].word}」還沒有筆順。請繼續。謝謝！');
        });
        return; // Exit early to avoid updating `nextStepId`
      }
    }
    nextStepId = min(steps['goToUse2']!, nextStepId); // Make sure it is not greater than goToUse2
    debugPrint('nextTab svgFileExist $svgFileExist, savedId: $savedNextStepId, nextId: $nextStepId');

    // Proceed to speak and navigate
    if (nextStepId == steps['goToListen']) {
      // 0
      incrementNextStepId();
    } else if (nextStepId == steps['goToWrite'] || nextStepId == (steps['goToWrite']! + 1)) { // 1 & 2 sjf 9/8/24
      // 1、2
      // _isDrawingMode = true;
      incrementNextStepId();
      await ftts.speak(widget.wordsStatus[widget.wordIndex].word); // Keep speaking logic intact
    } else if (nextStepId == steps['goToUse1'] || nextStepId == steps['goToUse2']) {
      // 8、9
      // _isDrawingMode = false;
      await handleGoToUse();  // Follow your speaking behavior here
    } else {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        showErrorDialog('', '「${widget.wordsStatus[widget.wordIndex].word}」程序問題。請截圖回報。謝謝！');
      });
    }

    // debugPrint('nextTab completed, nextStepId: $nextStepId, currentTabIndex: ${currentTabIndex.value}, stack: ${StackTrace.current}');
    debugPrint('nextTab completed, nextStepId: $nextStepId, currentTabIndex: ${currentTabIndex.value}');
  }

  void prevTab() async {
    // prevTab() is called in many places, one setState() is called
    // it will update the nextStepId, currentTabIndex, and call showNoSvgDialog() if no SVG in 寫一寫    
    if (kDebugMode) {
      final stackTrace = StackTrace.current.toString().split('\n');
      final relevantStackTrace = '\n${stackTrace[0]}\n${stackTrace[1]}';
      debugPrint('prevTab invoked at nextStepId: $nextStepId, currentTabIndex: ${currentTabIndex.value}, stack: $relevantStackTrace');
    }    

    int currentTabValue = currentTabIndex.value;
    int savedNextStepId = nextStepId;

    debugPrint('prevTab currentTab $currentTabValue, nextId: $nextStepId, wordIsLearned: $wordIsLearned, svgFileExist: $svgFileExist');

    if (currentTabValue > 0) { // to prevent negative value
      currentTabIndex.value -= 1;
    }

    if (svgFileExist) { // 有筆順
      if (wordIsLearned) { // 字已學
        if (nextStepId > 0 && nextStepId < 8) { // 1-7 different steps in 寫一寫
          nextStepId = steps['goToListen']!;
          debugPrint('prevTab 字已學，要從“寫一寫”中的任一步驟，退回到“聽一聽” nextId: $nextStepId');
        } else { // 0, 8, 9
          nextStepId -= 1;
          if (nextStepId == steps['goToPracticeWithoutBorder1']) {
            nextStepId = steps['goToWrite']!;
          } else if (nextStepId < steps['goToListen']!) {
            nextStepId = steps['goToListen']!;
          }
          debugPrint('prevTab 字已學，nextStepId 從 0,8,9 變成 $nextStepId');
        }
      } else { // 字未學，一步一步來
        nextStepId -= 1;
        debugPrint('prevTab 字未學，savedId: $savedNextStepId，nextId: $nextStepId');
      }
    } else { // 沒有筆順
      // Check if we're at 'goToUse2', step back to 'goToUse1'
      if (nextStepId == steps['goToUse2']) {
        nextStepId -= 1; // Decrease step to go back to 'goToUse1'
        debugPrint('prevTab no svg0. 從 “用一用2”退回到“用一用1”. nextId = $nextStepId.');
        return;
      }

      // Check if we're at 'goToUse1', step back to 'goToWrite' and show error dialog
      if (nextStepId == steps['goToUse1']) {
        debugPrint('prevTab no svg1. 從 “用一用1”退回到“寫一寫”. Show error message.');
        
        WidgetsBinding.instance.addPostFrameCallback((_) async {
          await showNoSvgDialog(
            '', 
            '抱歉，「${widget.wordsStatus[widget.wordIndex].word}」還沒有筆順。請繼續。謝謝！'
          );
        });
        
        // nextStepId = steps['goToWrite']!; // Set step back to 'goToWrite'
        nextStepId = steps['practiceWithoutBorder1']!; // 跟正常流程一樣
        debugPrint('prevTab no svg2. 從 “用一用1”退回到“寫一寫”. nextId = $nextStepId.');
        return;
      }

      // For other cases, decrement the step by 1
      nextStepId -= 1;
      nextStepId = max(0, nextStepId); // Make sure it is not negative
      debugPrint('prevTab no svg3. savedId = $savedNextStepId, nextId = $nextStepId');
    }
  }

  void incrementNextStepId() {
    setState(() {
      nextStepId += 1;
      // debugPrint('setState incrementNextStepId: nextId: $nextStepId, stack: ${StackTrace.current}');
      debugPrint('setState incrementNextStepId: nextId: $nextStepId');
    });
  }

  Future<void> handleGoToUse() async {
    debugPrint('handleGoToUse invoked. vocabCnt: $vocabCnt, nextId: $nextStepId, wordIsLearned: $wordIsLearned, svgFileExist: $svgFileExist');

    switch (vocabCnt) {
      case 1:
        debugPrint('handleGoToUse vocabCnt: $vocabCnt, vocab1: ${wordObj['vocab1']}, sentence1: ${wordObj['sentence1']}, nextId: $nextStepId, wordIsLearned: $wordIsLearned, svgFileExist: $svgFileExist');
        await ftts.speak("${wordObj['vocab1']}。${wordObj['sentence1']}");
        setState(() {
          nextStepId = steps['goToUse2']!;
          debugPrint('setState handleGoToUse: newStatus.learned = true');
        });
        break;

      case 2:
        switch (nextStepId) {
          case int stepId when stepId == steps['goToUse1']:
            debugPrint('handleGoToUse vocabCnt: $vocabCnt, vocab1: ${wordObj['vocab1']}, sentence1: ${wordObj['sentence1']}, nextId: $nextStepId, wordIsLearned: $wordIsLearned, svgFileExist: $svgFileExist');
            await ftts.speak("${wordObj['vocab1']}。${wordObj['sentence1']}");
            setState(() {
              nextStepId += 1;
              debugPrint('setState handleGoToUse: nextStepId: $nextStepId');
            });
            break;

          case int stepId when stepId == steps['goToUse2']:
            debugPrint('handleGoToUse vocabCnt: $vocabCnt, vocab2: ${wordObj['vocab2']}, sentence2: ${wordObj['sentence2']}, nextId: $nextStepId, wordIsLearned: $wordIsLearned, svgFileExist: $svgFileExist');
            await ftts.speak("${wordObj['vocab2']}。${wordObj['sentence2']}");
            setState(() {
              debugPrint('setState handleGoToUse: nextStepId: $nextStepId');
            });
            break;

          default:
            debugPrint('Unexpected nextStepId for vocabCnt 2: $nextStepId');
        }
        break;

      default:
        debugPrint('handleGoToUse Error! vocabCnt: $vocabCnt, nextId: $nextStepId, wordIsLearned: $wordIsLearned, svgFileExist: $svgFileExist');
    }

    debugPrint('handleGoToUse completed, nextStepId: $nextStepId');
  }  

  Future myLoadAsset(String path) async {
    try {
      return await rootBundle.load(path);
    } catch (_) {
      return null;
    }
  }

  void getWord() async {
    // getWord() is called in initState(), NO setState() is called
    int tempIndex = widget
        .wordIndex; // change widget.wordIndex to tempIndex in this function
    bool phraseEmpty = widget.wordsPhrase.isEmpty;
    debugPrint('getWord begin: phraseEmpty: $phraseEmpty, tempIndex: $tempIndex');
    if (phraseEmpty) {
      debugPrint('getWord error: wordsPhrase is empty');
      wordObj = {};
      wordExist = false;
      return;
    } else {
      debugPrint('getWord index: $tempIndex, length: ${widget.wordsPhrase.length}');
      if (!(tempIndex < widget.wordsPhrase.length)) {
        debugPrint('getWord error: wordIndex is out of range');
        wordObj = {};
        wordExist = false;
        return;
      }
    }

    wordObj = widget.wordsPhrase[tempIndex];
    try {
      // Process vocab1
      if (wordObj['vocab1'] != "") {
        vocabCnt += 1;
      }
      // Process vocab2
      if (wordObj['vocab2'] != "") {
        vocabCnt += 1;
      }

      wordExist = true; // 字存在，但是 json 可能不存在 (svgFileExist = false)
      debugPrint('getWord end: wordExist: $wordExist, vocabCnt: $vocabCnt, ${wordObj['vocab1']}, ${wordObj['vocab2']}');
    } catch (error) {
      wordExist = false;
      debugPrint('getWord error: : $error。wordExist: $wordExist,${wordObj['vocab1']}');
    }
  }

  late List<Widget> useTabView;
  // bool _didChangeDependenciesCalled = false;  

  @override
  void initState() {
    super.initState();
    debugPrint('initState begin, wordExist: $wordExist, svgFileExist: $svgFileExist, nextId: $nextStepId, wordIsLearned: $wordIsLearned');    
    ftts.setLanguage("zh-tw");
    ftts.setSpeechRate(0.5);
    ftts.setVolume(1.0);

    // Initialize the TabController
    _tabController = TabController(length: 4, vsync: this);

    // Setup completion handler for TTS
    ftts.setCompletionHandler(() async {
      // debugPrint('\nTTS handler completed, nextStepId: $nextStepId, currentTabIndex: ${currentTabIndex.value}, , wordIsLearned: $wordIsLearned, svgFileExist: $svgFileExist, stack: ${StackTrace.current}');
      debugPrint('\nTTS handler completed, nextStepId: $nextStepId, currentTabIndex: ${currentTabIndex.value}, , wordIsLearned: $wordIsLearned, svgFileExist: $svgFileExist');

      if (!context.mounted) return;

      WordStatus newStatus = widget.wordsStatus[widget.wordIndex];

      if (nextStepId == steps['goToListen']) { // 聽一聽, 0
        debugPrint('TTS handler goToListen, call incrementNextStepId, newStatus: $newStatus, nextId: $nextStepId');
        incrementNextStepId();
      } else if (nextStepId == steps['goToUse1']) { // 用一用1, 8
        debugPrint('TTS handler goToUse1, call handleGoToUse, newStatus: $newStatus, nextId: $nextStepId');
        await handleGoToUse();
      } else if (nextStepId == steps['goToUse2']) { // 用一用2, 9
        debugPrint('TTS handler goToUse2, call _updateWordStatus, newStatus: $newStatus, nextId: 0');
        // await _updateWordStatus(newStatus, learned: true, nextStepId: nextStepId);
      }
      debugPrint("Speech has completed");
    });

    // Determine if the word is BPMF
    isBpmf = initials.contains(widget.wordsStatus[widget.wordIndex].word) ||
        prenuclear.contains(widget.wordsStatus[widget.wordIndex].word) ||
        finals.contains(widget.wordsStatus[widget.wordIndex].word);

    getWord(); // wordObj, wordExist, img1Exist, img2Exist, vocabCnt will be set, NO setState() is called
    checkWordExistence(); // setState is called once in readJsonAndProcess()
    debugPrint('initState end, wordExist: $wordExist, svgFileExist: $svgFileExist, nextId: $nextStepId, wordIsLearned: $wordIsLearned');
  }

  Future<void> _updateWordStatus(WordStatus newStatus, {required bool learned}) async {
    debugPrint('_updateWordStatus. mounted: ${context.mounted}, learned: $learned, nextStepId: $nextStepId');
    if (!context.mounted) return;

    try {
      newStatus.learned = learned;
      
      // Update the provider state
      ref.read(learnedWordCountProvider.notifier).state += learned ? 1 : 0;
      
      // Perform the database update
      await WordStatusProvider.updateWordStatus(status: newStatus);
      
      // Update the local state if needed
      if (mounted) {  // Double-check mounted status after async operation
        setState(() {
          debugPrint('setState _updateWordStatus: newStatus.learned: $learned, nextStepId: $nextStepId');
        });
      }
    } catch (e) {
      debugPrint('Error in _updateWordStatus: $e');
      // Handle error (e.g., show a snackbar to the user)
    }
  }  
    
  void checkWordExistence() {
    if (!wordExist) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        showErrorDialog('','「${widget.wordsStatus[widget.wordIndex].word}」不在SQL。請截圖回報。謝謝！');
      });
    } else {
      readJsonAndProcess(); // setState() is called here
    }
  }

  Future<void> readJsonAndProcess() async {
    // setState() is called in this function
    try {
      final result = await readJson();
      debugPrint('readJsonAndProcess: ${widget.wordsStatus[widget.wordIndex].word} ${svgFileExist ? "有筆順" : "沒有筆順"}');
      if (result.isNotEmpty) {
        setState(() {
          _strokeOrderAnimationControllers = StrokeOrderAnimationController(
              result, this,
              onQuizCompleteCallback: handleQuizCompletion);
          if (svgFileExist) {
            debugPrint('setState readJsonAndProcess: ${widget.wordsStatus[widget.wordIndex].word} 筆順檔下載成功');
          } else {
            debugPrint('setState readJsonAndProcess: 用“寫”替代，筆順檔下載成功');
          }
        });
      } else {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          showErrorDialog('','「${widget.wordsStatus[widget.wordIndex].word}」的筆順檔無法下載。請截圖回報。謝謝！');
          debugPrint('readJsonAndProcess error: ${widget.wordsStatus[widget.wordIndex].word} 的筆順檔無法下載, svgFileExist: $svgFileExist');
          _firstNullStroke = true; // Reset the flag
          _showErrorDialog = false; // Reset the flag           
        });        
        setState(() {
          _strokeOrderAnimationControllers = null;
          debugPrint('setState readJsonAndProcess error: ${widget.wordsStatus[widget.wordIndex].word} 的筆順檔無法下載, svgFileExist: $svgFileExist');
        });
      }
    } catch (error) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        showErrorDialog('','「${widget.wordsStatus[widget.wordIndex].word}」筆順檔問題，請截圖回報。svgFileExist: $svgFileExist。謝謝！');
        _firstNullStroke = true; // Reset the flag
        _showErrorDialog = false; // Reset the flag           
      });
      setState(() {
        _strokeOrderAnimationControllers = null;
        // svgFileExist is set in readJson(). Should not be set here.
        debugPrint('setState readJsonAndProcess error: ${widget.wordsStatus[widget.wordIndex].word} 筆順檔問題, svgFileExist: $svgFileExist');
      });
    }
  }

  Future<String> readJson() async {
    // Define the noSvgList. This list needs to be updated every new school semester
    List<String> noSvgList = [
      '吔', '姍', '媼', '嬤', '履', '搧', '枴', '椏', '欓', '汙',
      '溼', '漥', '痠', '礫', '粄', '粿', '綰', '蓆', '襬', '譟',
      '踖', '踧', '鎚', '鏗', '鏘', '陳', '颺', '齒'
    ];

    String word = widget.wordsStatus[widget.wordIndex].word; // Ensure wordsStatus and wordIndex are initialized

    // If the word is in the noSvgList, set svgFileExist to false and use '學' as a fallback
    if (noSvgList.contains(word)) {
      word = '學'; // Set the word to "學" to avoid null checking in the rest of code
      svgFileExist = false;
    } else {
      svgFileExist = true;
    }

    debugPrint('readJson() word: $word, svgFileExist: $svgFileExist');
  
    // Proceed with loading the SVG file. If svgFileExist is false, 
    // load “學” so that 看一看、聽一聽、用一用 still work.
    try {
      final String response = await rootBundle.loadString('lib/assets/svg/$word.json');
      return response.replaceAll("\"", "'"); // Replace double quotes with single quotes in the response
    } catch (e) {
      // Handle error if the SVG file does not exist or cannot be loaded
      svgFileExist = false;
      debugPrint('readJson() error: $e, svgFileExist: $svgFileExist');
      return ''; // Return an empty string in case of error
    }
  }

  void handleQuizCompletion(QuizSummary summary) {
    if (nextStepId >= steps['practiceWithBorder1']! &&
        nextStepId <= steps['turnBorderOff']!) {
      setState(() {
        practiceTimeLeft -= 1;
        nextStepId += 1;
        debugPrint('setState handleQuizCompletion: practiceTimeLeft: $practiceTimeLeft, nextId: $nextStepId');
      });
      Fluttertoast.showToast(
        msg: [
          nextStepId == steps['turnBorderOff']
              ? "恭喜筆畫正確！讓我們 去掉邊框 再練習 $practiceTimeLeft 遍哦！"
              : "恭喜筆畫正確！讓我們再練習 $practiceTimeLeft 次哦！"
        ].join(),
        fontSize: 30,
      );
    } else {
      if (nextStepId == steps['practiceWithoutBorder1']) {
        setState(() {
          practiceTimeLeft -= 1;
          nextStepId += 1;
          widget.wordsStatus[widget.wordIndex].learned = true; // 設成“已學”
          _updateWordStatus(widget.wordsStatus[widget.wordIndex], learned: true);
          debugPrint('setState handleQuizCompletion 要進入用一用1, practiceTimeLeft: $practiceTimeLeft, nextId: $nextStepId, learned: true');
        });
      }
      Fluttertoast.showToast(
        msg: ["恭喜筆畫正確！"].join(),
        fontSize: fontSize * 1.2,
      );
    }
  }

  void showErrorDialog(String message, String title) {
    if (!context.mounted) return;

    showDialog(
      context: context,
      barrierDismissible: false,  // This ensures the dialog is modal
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(
            title,
            style: TextStyle(
              color: Colors.black, // Set text color to black
              fontSize: fontSize * 1.2, // Set font size
            ),
          ),
          content: Text(
            message,
            style: TextStyle(
              color: Colors.black, // Set text color to black
              fontSize: fontSize * 1.2, // Set font size
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: Text(
                '回首頁',
                style: TextStyle(
                  color: Colors.black, // Set text color to black
                  fontSize: fontSize * 1.2, // Set font size
                ),
              ),
              onPressed: () {
                Navigator.of(context).pop(); // Close the dialog
                Navigator.of(context).pushReplacementNamed(
                    '/mainPage'); // Navigate to Home screen
              },
            ),
          ],
        );
      },
    );
  }

  // Show error dialog for 寫一寫 if there is no SVG file
  Future<void> showNoSvgDialog(String message, String title) async {
    if (!context.mounted) return;
    String word = widget.wordsStatus[widget.wordIndex].word;
    
    showDialog(
      context: context,
      barrierDismissible: false,  // This ensures the dialog is modal
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(
            title,
            style: TextStyle(
              color: Colors.black, // Set text color to black
              fontSize: fontSize * 1.2, // Set font size
            ),
          ),
          content: Text(
            message,
            style: TextStyle(
              color: Colors.black, // Set text color to black
              fontSize: fontSize * 1.2, // Set font size
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: Text(
                '聽一聽',
                style: TextStyle(
                  color: Colors.black, // Set text color to black
                  fontSize: fontSize * 1.2, // Set font size
                ),
              ),
              onPressed: () async {
                Navigator.of(context).pop(); // Close the dialog
                int savedNextStepId = nextStepId;
                int oldTabIndex = currentTabIndex.value;
                nextStepId = steps['goToWrite']!;
                currentTabIndex.value = 2;                
                debugPrint('聽一聽 說：$word');  // 移到前面，因為 await 會有延遲
                if (isBpmf) {
                  await player.play(AssetSource('bopomo/$word.mp3'));
                } else {
                  await ftts.speak(word);
                }
                debugPrint('寫一寫，上一頁1，savedId: $savedNextStepId，nextId: $nextStepId，oldTabIndex: $oldTabIndex, newTabIndex: ${currentTabIndex.value},叫 prevTab()');            
                prevTab(); // it will update the nextStepId and currentTabIndex 
                nextStepId = steps['goToWrite']!;      // sjf 10/8/24 hard code to go to 寫一寫
                debugPrint('寫一寫，上一頁2，force nextId to $nextStepId'); // sjf 10/8/24        
                return _tabController.animateTo(_tabController.index - 1);
              },
            ),
            TextButton(
              child: Text(
                '用一用',
                style: TextStyle(
                  color: Colors.black, // Set text color to black
                  fontSize: fontSize * 1.2, // Set font size
                ),
              ),
              onPressed: () {
                Navigator.of(context).pop(); // Close the dialog
                int savedNextStepId = nextStepId;
                widget.wordsStatus[widget.wordIndex].learned = true; // 設成“已學”，用一用才會順利
                _updateWordStatus(widget.wordsStatus[widget.wordIndex], learned: true);
                nextStepId = steps['goToUse1']!; // Force to goToUse1
                // vocabCnt = 2;
                debugPrint('寫一寫，下一頁，savedId: $savedNextStepId,  nextId: $nextStepId，呼叫 handleGoToUse()');                   
                handleGoToUse();
                currentTabIndex.value += 1;
                return _tabController.animateTo(_tabController.index + 1);
              },
            ),
          ],
        );
      },
    );
  }

  @override
  void dispose() {
    super.dispose();
    _tabController.dispose();
  }

  Map<String, int> steps = { // 沒有看一看
    'goToListen': 0, // 聽一聽
    'goToWrite': 1, // 寫一寫
    'seeAnimation': 2, // 寫一寫-筆順
    'practiceWithBorder1': 3, // 寫一寫-寫字-有邊框
    'practiceWithBorder2': 4, // 寫一寫-寫字-有邊框
    'practiceWithBorder3': 5, // 寫一寫-寫字-有邊框
    'turnBorderOff': 6, // 寫一寫-關掉邊框
    'practiceWithoutBorder1': 7, // 寫一寫-寫字-無邊框
    'goToUse1': 8, // 用一用-例句1
    'goToUse2': 9, // 用一用-例句2
  };

  @override
  Widget build(BuildContext context) {
    final screenInfo = ref.watch(screenInfoProvider);
    fontSize = screenInfo.fontSize;
    double deviceHeight = screenInfo.screenHeight;
    double deviceWidth = screenInfo.screenWidth;
    // debugPrint('teach_word_view H: $deviceHeight, W: $deviceWidth, fontSize: $fontSize, stack: ${StackTrace.current}');
    debugPrint('teach_word_view H: $deviceHeight, W: $deviceWidth, fontSize: $fontSize');

    double availableWidth = deviceWidth - 10; // 10 padding on each side
    double availableHeight = deviceHeight - 10; // example padding top and bottom
    double nonConsumedHeight = deviceHeight * 0.15; // was 0.20;

    String word = widget.wordsStatus[widget.wordIndex].word;
    int unitId = widget.unitId;
    String unitTitle = widget.unitTitle;
    debugPrint('\nbuild word: $word, nextId: $nextStepId, wordIsLearned: $wordIsLearned');

    // 不知道為何每一個字都會出現 _strokeOrderAnimationControllers is null 一次。
    // 若出現第二次，則有問題。    
    if (_strokeOrderAnimationControllers == null) {
      debugPrint('build _strokeOrder is null, _firstNullStroke: $_firstNullStroke, nextId: $nextStepId');
      if (_firstNullStroke) {
        _firstNullStroke = false;
        return LayoutBuilder(builder: (context, constraints) { return Container(); });
      } else {
        _showErrorDialog = true;
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (_showErrorDialog) {
            showErrorDialog('','「$word」沒有筆順2。請截圖回報。謝謝！');
            _firstNullStroke = true; // Reset the flag
            _showErrorDialog = false; // Reset the flag           
          }
        });
        // Return a fallback widget to avoid returning null
        return LayoutBuilder(builder: (context, constraints) { return Container(); }); // or any other placeholder widget
      }
    }

    debugPrint('build _strokeOrder is not null, word: $word, nextId: $nextStepId, wordIsLearned: $wordIsLearned, vocabCnt: $vocabCnt, vocabIndex: $vocabIndex, svgFileExist: $svgFileExist');

    List<Widget> useTabView = [
      /*
      TeachWordTabBarView( // 用一用 - 例句1
        content: Stack(
          children: [
            SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min, // Prevents unbounded height issues
                children: [
                  ConstrainedBox(
                    constraints: BoxConstraints(
                      maxWidth: availableWidth, 
                    ),
                    child: Column(
                      // mainAxisSize: MainAxisSize.min, // Prevents infinite height
                      mainAxisSize: MainAxisSize.max,
                      children: <Widget>[
                        LeftRightSwitch(
                          // LeftRightSwitch for 用一用
                          iconsColor: gray85Color,
                          iconsSize: fontSize * 2.0, 
                          rightBorder: nextStepId == steps['goToUse2'],
                          middleWidget: TeachWordCardTitle(
                              sectionName: '用一用', iconsColor: gray85Color),
                          isFirst: false,
                          isLast: (vocabCnt == 1),
                          onLeftClicked: wordIsLearned
                              ? () {
                                  int savedNextStepId = nextStepId;
                                  int oldTabIndex = currentTabIndex.value;
                                  nextStepId = steps['goToUse1']!; // Force to goToUse1
                                  currentTabIndex.value = 3;       // Force to 3
                                  debugPrint('用一用1，上一頁1，savedId: $savedNextStepId，nextId: $nextStepId，oldTabIndex: $oldTabIndex, newTabIndex: ${currentTabIndex.value},叫 prevTab()');
                                  prevTab(); // prevTab() will update the nextStepId and currentTabIndex, and will speak for 用一用
                                  return _tabController.animateTo(_tabController.index - 1);
                                }
                              : null,
                          onRightClicked: (nextStepId == steps['goToUse2'] || wordIsLearned)
                              ? () async {
                                  if (nextStepId == steps['goToUse2']) {
                                    await ftts.speak("${wordObj['vocab2']}。${wordObj['sentence2']}");
                                    debugPrint('用一用1，下一頁1 vocab2: ${wordObj['vocab2']}, ${wordObj['sentence2']}');
                                    setState(() {
                                      debugPrint('setState 用一用1，下一頁1， newStatus.learned: true');
                                    });                                    
                                  }
                                  setState(() {
                                    vocabIndex = 1;
                                    debugPrint('setState 用一用1，下一頁1， vocabIndex: $vocabIndex');
                                  });
                                }
                              : null,
                        ),
                        isBpmf
                            ? BopomofoVocabContent(
                                word: word,
                                vocab: wordObj['vocab1'],
                                sentence: "${wordObj['sentence1']}",
                              )
                            : WordVocabContent(
                                vocab: wordObj['vocab1'],
                                meaning: wordObj['meaning1'],
                                sentence: "${wordObj['sentence1']}\n",
                                vocab2: wordObj['vocab2'],
                              ),
                        SizedBox(height: fontSize * 0.2), // Adjust height as needed
                        // Instead of Expanded, use SizedBox or Flexible with constrained height
                        SizedBox(
                          height: fontSize * 3.0, // Adjust height for the image or icon
                          child: (img1Exist && !isBpmf)
                              ? Image(
                                  height: fontSize * 3.0,
                                  image: AssetImage('lib/assets/img/vocabulary/${wordObj['vocab1']}.webp'),
                                )
                              : SizedBox(height: fontSize * 0.5),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
            Positioned(
              // Position the text at the bottom right
              right: fontSize, 
              bottom: fontSize, 
              child: Text(
                "1 / $vocabCnt",
                style: TextStyle(
                  fontSize: fontSize * 0.75,
                  fontWeight: FontWeight.normal,
                  color: backgroundColor,
                ),
              ),
            ),
          ],
        ),
      ),
      // Same structure for the second sentence tab
      */
      // Usage for 用一用1
      UseTabContentView(
        sectionName: '用一用',
        vocabIndex: vocabIndex,
        contentWidget: Column( // Use a Column for vertical layout
          children: [
            isBpmf
                ? BopomofoVocabContent(
                    word: word,
                    vocab: wordObj['vocab1'],
                    sentence: wordObj['sentence1'],
                  )
                : WordVocabContent(
                    vocab: wordObj['vocab1'],
                    meaning: wordObj['meaning1'],
                    sentence: wordObj['sentence1'],
                    vocab2: wordObj['vocab2'],
                  ),
            Spacer(), // Pushes the text widget down
            Row(
              mainAxisAlignment: MainAxisAlignment.end, // Align to bottom right
              children: [
                Text(
                  "${vocabIndex + 1} / 2",
                  style: TextStyle(
                    fontSize: fontSize * 0.75,
                    fontWeight: FontWeight.normal,
                    color: backgroundColor,
                  ),
                ),
                SizedBox(width: 16.0), // Add some padding on the right
              ],
            ),
          ],
        ),
        onLeftClicked: wordIsLearned
            ? () {
                prevTab();
                ftts.speak("${wordObj['vocab1']}。${wordObj['sentence1']}");
                setState(() {
                  vocabIndex = 0;
                });
              }
            : null,
        onRightClicked: (nextStepId == steps['goToUse2'] || wordIsLearned)
            ? () async {
                if (nextStepId == steps['goToUse2']) {
                  await ftts.speak("${wordObj['vocab2']}。${wordObj['sentence2']}");
                  setState(() {});
                }
                setState(() {
                  vocabIndex = 1;
                });
              }
            : null,
        isFirst: false,
        isLast: false,
        screenInfo: screenInfo,
        fontSize: fontSize,
        backgroundColor: backgroundColor,
      ),

      (vocabCnt == 2)
        /*
        ? TeachWordTabBarView( // 用一用 - 例句2
            content: Stack(
              children: [
                SingleChildScrollView(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      ConstrainedBox(
                        constraints: BoxConstraints(
                          maxWidth: availableWidth,
                        ),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: <Widget>[
                            LeftRightSwitch(
                              iconsColor: gray85Color,
                              iconsSize: fontSize * 2.0,
                              rightBorder: false,
                              middleWidget: TeachWordCardTitle(
                                  sectionName: '用一用', iconsColor: gray85Color),
                              isFirst: false,
                              isLast: true,
                              onLeftClicked: wordIsLearned
                                  ? () {
                                      debugPrint('用一用2，上一頁1，nextId: $nextStepId，叫 prevTab()');
                                      prevTab();  // prevTab() will update the nextStepId and currentTabIndex, and will speak for 用一用
                                      ftts.speak("${wordObj['vocab1']}。${wordObj['sentence1']}");
                                      setState(() {
                                        vocabIndex = 0;
                                        debugPrint('setState 用一用2，上一頁1， vocabIndex: $vocabIndex');
                                      });
                                    }
                                  : null,
                            ),
                            isBpmf
                                ? BopomofoVocabContent(
                                    word: word,
                                    vocab: wordObj['vocab2'],
                                    sentence: "${wordObj['sentence2']}",
                                  )
                                : WordVocabContent(
                                    vocab: wordObj['vocab2'],
                                    meaning: wordObj['meaning2'],
                                    sentence: "${wordObj['sentence2']}\n",
                                    vocab2: wordObj['vocab1'],
                                  ),
                            SizedBox(height: fontSize * 0.2), 
                            // Similarly here, avoid using Expanded
                            SizedBox(
                              height: fontSize * 3.0,
                              child: (img2Exist && !isBpmf)
                                  ? Image(
                                      height: fontSize * 3.0,
                                      image: AssetImage('lib/assets/img/vocabulary/${wordObj['vocab2']}.webp'),
                                    )
                                  : SizedBox(height: fontSize * 0.5),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
                Positioned(
                  right: fontSize, 
                  bottom: fontSize, 
                  child: Text(
                    "2 / $vocabCnt",
                    style: TextStyle(
                      fontSize: fontSize * 0.75,
                      fontWeight: FontWeight.normal,
                      color: backgroundColor,
                    ),
                  ),
                ),
              ],
            ))
        : LayoutBuilder(builder: (context, constraints) { return Container(); })
        */

        // Usage for 用一用2

        ? UseTabContentView(
          sectionName: '用一用',
          vocabIndex: 1,
          contentWidget: Column( // Use a Column for vertical layout
            children: [
              isBpmf
                  ? BopomofoVocabContent(
                      word: word,
                      vocab: wordObj['vocab2'],
                      sentence: wordObj['sentence2'],
                    )
                  : WordVocabContent(
                      vocab: wordObj['vocab2'],
                      meaning: wordObj['meaning2'],
                      sentence: wordObj['sentence2'],
                      vocab2: wordObj['vocab1'],
                    ),
              Spacer(), // Pushes the text widget down
              Row(
                mainAxisAlignment: MainAxisAlignment.end, // Align to bottom right
                children: [
                  Text(
                    "2 / 2",
                    style: TextStyle(
                      fontSize: fontSize * 0.75,
                      fontWeight: FontWeight.normal,
                      color: backgroundColor,
                    ),
                  ),
                  SizedBox(width: 16.0), // Add some padding on the right
                ],
              ),
            ],
          ),
          onLeftClicked: wordIsLearned
              ? () {
                  prevTab();
                  ftts.speak("${wordObj['vocab1']}。${wordObj['sentence1']}");
                  setState(() {
                    vocabIndex = 0;
                  });
                }
              : null,
          onRightClicked: null, // No further tab, this is the last one
          isFirst: false,
          isLast: true,
          screenInfo: screenInfo,
          fontSize: fontSize,
          backgroundColor: backgroundColor,
        )

        : LayoutBuilder(builder: (context, constraints) { return Container(); })
    
    ];
    
    return DefaultTabController(
      length: 4,
      child: Scaffold(
        appBar: PreferredSize(
          preferredSize: Size(deviceWidth, kToolbarHeight * 2), // Double height to accommodate TabBar
          child: Center(
            child: SizedBox(
              width: deviceWidth,
              // color: Theme.of(context).appBarTheme.backgroundColor,
              child: SafeArea(
                child: Column(
                  children: [
                    // AppBar content
                    SizedBox(
                      height: kToolbarHeight,
                      child: Row(
                        children: [
                          IconButton(
                            icon: Icon(Icons.chevron_left, color: beige, size: fontSize * 1.5),
                            onPressed: () => Navigator.pop(context),
                          ),
                          Expanded(
                            child: (unitId == -1)
                                ? Text(unitTitle, 
                                    style: TextStyle(fontSize: fontSize * 1.2),
                                    textAlign: TextAlign.center)
                                : Text("${unitId.toString().padLeft(2, '0')} | $unitTitle",
                                    style: TextStyle(fontSize: fontSize * 1.2),
                                    textAlign: TextAlign.center),
                          ),
                          IconButton(
                            onPressed: () => navigateWithProvider(context, '/mainPage', ref),
                            icon: Icon(Icons.home_filled, color: beige, size: fontSize * 1.5),
                          ),
                        ],
                      ),
                    ),
                    // TabBar
                    SizedBox(
                      height: kToolbarHeight,
                      child: TabBar(
                        tabs: [
                          Tab(icon: Icon(Icons.image, size: fontSize * 0.75)),
                          Tab(icon: Icon(Icons.hearing, size: fontSize * 0.75)),
                          Tab(icon: Icon(Icons.create, size: fontSize * 0.75)),
                          Tab(icon: Icon(Icons.school, size: fontSize * 0.75)),
                        ],
                        controller: _tabController,
                        onTap: (index) {
                          _tabController.index = currentTabIndex.value;
                        },
                        labelColor: darkBrown,
                        dividerColor: mediumGray,
                        unselectedLabelColor: mediumGray,
                        indicatorSize: TabBarIndicatorSize.tab,
                        indicatorPadding: const EdgeInsets.symmetric(horizontal: 2),
                        indicator: const BoxDecoration(
                          borderRadius: BorderRadius.only(
                            topLeft: Radius.circular(10),
                            topRight: Radius.circular(10),
                          ),
                          color: mediumGray,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),

        body: TabBarView(
          physics: const NeverScrollableScrollPhysics(),
          controller: _tabController,
          children: [
            TeachWordTabBarView( // 看一看
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Flexible(
                      fit: FlexFit.loose,
                      child: Center(
                        child: ConstrainedBox(
                          constraints: BoxConstraints(
                            maxWidth: deviceWidth * 0.90,  // Limit content to 90% of device width
                          ),
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: <Widget>[
                              LeftRightSwitch(
                                iconsColor: lightGray,
                                iconsSize: max(fontSize * 2.0, 48.0),
                                rightBorder: nextStepId == steps['goToListen'],
                                middleWidget: const TeachWordCardTitle(
                                  sectionName: '看一看',
                                  iconsColor: lightGray,
                                ),
                                isFirst: true,
                                isLast: false,
                                onRightClicked: (nextStepId == steps['goToListen'] || wordIsLearned)
                                    ? () async {
                                        nextTab();
                                        if (isBpmf) {
                                          await player.play(AssetSource('bopomo/$word.mp3'));
                                        } else {
                                          await ftts.speak(word);
                                        }
                                        return _tabController.animateTo(_tabController.index + 1);
                                      }
                                    : null,
                              ),
                              SizedBox(height: fontSize * 0.3),
                              Flexible(
                                fit: FlexFit.loose,
                                child: Stack(
                                  alignment: Alignment.center,
                                  children: [
                                    LayoutBuilder(
                                      builder: (context, constraints) {
                                        return Container(
                                          decoration: const BoxDecoration(
                                            color: darkBrown,
                                          ),
                                          child: Center(
                                            child: Image(
                                              width: max(17.6 * fontSize, 300.0),
                                              image: isBpmf
                                                  ? AssetImage('lib/assets/img/bopomo/$word.png')
                                                  : AssetImage('lib/assets/img/oldWords/$word.webp'),
                                              errorBuilder: (BuildContext context, Object exception, StackTrace? stackTrace) {
                                                debugPrint('Error loading image: $exception');
                                                return Center(
                                                  child: Text(
                                                    word,
                                                    textAlign: TextAlign.center,
                                                    style: TextStyle(
                                                      fontSize: fontSize * 8.0,
                                                      color: backgroundColor,
                                                      fontWeight: FontWeight.w100,
                                                      fontFamily: isBpmf ? "BpmfOnly" : "BpmfIansui",
                                                    ),
                                                  ),
                                                );
                                              },
                                            ),
                                          ),
                                        );
                                      }
                                    ),
                                  ],
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            
            TeachWordTabBarView( // 聽一聽
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    ConstrainedBox(
                      constraints: BoxConstraints(
                        maxHeight: deviceHeight * 0.9,
                        maxWidth: deviceWidth * 0.9,  // Constrain width to 90% of deviceWidth
                      ),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: <Widget>[
                          LeftRightSwitch(
                            iconsColor: lightGray,
                            iconsSize: max(fontSize * 2.0, 48.0),
                            rightBorder: nextStepId == steps['goToWrite'],
                            middleWidget: const TeachWordCardTitle(
                              sectionName: '聽一聽',
                              iconsColor: lightGray,
                            ),
                            isFirst: false,
                            isLast: false,
                            onLeftClicked: (nextStepId == steps['goToWrite'] || wordIsLearned)
                                ? () {
                                    prevTab();
                                    return _tabController.animateTo(_tabController.index - 1);
                                  }
                                : null,
                            onRightClicked: (nextStepId == steps['goToWrite'] || wordIsLearned)
                                ? () {
                                    nextTab(); // from 聽一聽 to 寫一寫
                                    return _tabController.animateTo(_tabController.index + 1);
                                  }
                                : null,
                          ),
                          SizedBox(height: fontSize * 0.3),
                          SizedBox(
                            height: (deviceHeight * 0.4),
                            width: deviceWidth * 1.0,  // Limit width to 90% of deviceWidth
                            child: Stack(
                              alignment: Alignment.center,
                              children: [
                                LayoutBuilder(builder: (context, constraints) {
                                  return Container(
                                    decoration: const BoxDecoration(
                                      color: darkBrown,
                                    ),
                                    child: Center(
                                      child: Text(
                                        word,
                                        textAlign: TextAlign.center,
                                        style: TextStyle(
                                          fontSize: fontSize * 8.0,
                                          color: backgroundColor,
                                          fontWeight: FontWeight.w100,
                                          fontFamily: isBpmf ? "BpmfOnly" : "BpmfIansui",
                                        ),
                                      ),
                                    ),
                                  );
                                }),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
            
            TeachWordTabBarView( // 寫一寫
              content: ChangeNotifierProvider<StrokeOrderAnimationController>.value(
                value: _strokeOrderAnimationControllers!,
                child: Consumer<StrokeOrderAnimationController>(
                  builder: (context, controller, child) {
                    return Center(
                      child: ConstrainedBox(
                        constraints: BoxConstraints(
                          maxWidth: availableWidth * 0.90,
                          maxHeight: availableHeight - nonConsumedHeight,
                        ),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,  // Ensure the column takes only the necessary space
                          children: <Widget>[
                            LeftRightSwitch(
                              iconsColor: lightGray,
                              iconsSize: max(fontSize * 2.0, 48.0),  // Ensure a minimum tap target size
                              rightBorder: nextStepId == steps['goToUse1'],
                              middleWidget: const TeachWordCardTitle(
                                sectionName: '寫一寫',
                                iconsColor: lightGray,
                              ),
                              isFirst: false,
                              isLast: false,
                              onLeftClicked: wordIsLearned
                                  ? () async {
                                      int savedNextStepId = nextStepId;
                                      int oldTabIndex = currentTabIndex.value;
                                      nextStepId = steps['goToWrite']!;
                                      currentTabIndex.value = 2;
                                      debugPrint('回去 聽一聽 說：$word');
                                      
                                      if (isBpmf) {
                                        await player.play(AssetSource('bopomo/$word.mp3'));
                                      } else {
                                        await ftts.speak(word);
                                      }

                                      debugPrint('寫一寫，上一頁2，savedId: $savedNextStepId，nextId: $nextStepId，oldTabIndex: $oldTabIndex, newTabIndex: ${currentTabIndex.value},叫 prevTab()');
                                      
                                      prevTab();
                                      return _tabController.animateTo(_tabController.index - 1);
                                    }
                                  : null,
                              onRightClicked: (nextStepId == steps['goToUse1'] || wordIsLearned)
                                  ? () {
                                      nextTab();
                                      return _tabController.animateTo(_tabController.index + 1);
                                    }
                                  : null,
                            ),
                            SizedBox(height: fontSize * 0.2),

                            // Constrained Container for the animation and icons
                            SizedBox(
                              width: availableWidth,
                              height: (availableHeight - nonConsumedHeight) * 0.5,  // Allocate 50% of the available height
                              child: LayoutBuilder(
                                builder: (context, constraints) {
                                  return Container(
                                    decoration: !isBpmf
                                        ? const BoxDecoration(
                                            image: DecorationImage(
                                              image: AssetImage("lib/assets/img/box.png"),
                                              fit: BoxFit.fitWidth,
                                            ),
                                          )
                                        : const BoxDecoration(color: darkBrown),
                                    child: Stack(
                                      alignment: Alignment.center,
                                      children: [
                                        Positioned(
                                          left: 10,
                                          top: 5,
                                          child: Column(children: [
                                            _buildPracticeTimeIcon(
                                                practiceTimeLeft >= 4 && !wordIsLearned,
                                                fontSize,
                                                mediumGray, // Fixed: Color is passed directly
                                                warmOrange  // Fixed: Color is passed directly
                                            ),
                                            _buildPracticeTimeIcon(
                                                practiceTimeLeft >= 3 && !wordIsLearned,
                                                fontSize,
                                                mediumGray,
                                                warmOrange
                                            ),
                                            _buildPracticeTimeIcon(
                                                practiceTimeLeft >= 2 && !wordIsLearned,
                                                fontSize,
                                                mediumGray,
                                                warmOrange
                                            ),
                                            SizedBox(height: fontSize * 0.9),
                                            _buildPracticeTimeIcon(
                                                practiceTimeLeft >= 1 && !wordIsLearned,
                                                fontSize,
                                                mediumGray,
                                                warmOrange
                                            ),
                                          ]),
                                        ),
                                        FittedBox(
                                          child: StrokeOrderAnimator(
                                            _strokeOrderAnimationControllers!,
                                            key: UniqueKey(),
                                          ),
                                        ),
                                      ],
                                    ),
                                  );
                                },
                              ),
                            ),

                            // GridView for icons and labels (筆順、寫字、邊框)
                            Flexible(
                              fit: FlexFit.loose,  // Allow this to take up the remaining space
                              child: GridView.count(
                                crossAxisCount: 3,
                                childAspectRatio: 1.0,
                                mainAxisSpacing: 2,
                                crossAxisSpacing: 3,
                                shrinkWrap: true,  // Use only the space needed by children
                                physics: const NeverScrollableScrollPhysics(),  // Disable GridView's scrolling
                                children: <Widget>[
                                  buildIconButtonWithLabel(
                                    context: context,
                                    border: (nextStepId == steps['seeAnimation'] && !wordIsLearned),
                                    iconData: [Icons.pause, Icons.play_arrow],
                                    label: '筆順',
                                    isSelected: controller.isAnimating,
                                    onPressed: ((!controller.isQuizzing && (nextStepId == steps['seeAnimation'])) || wordIsLearned)
                                        ? () async {
                                            if (!controller.isAnimating) {
                                              controller.startAnimation();
                                              if (isBpmf) {
                                                await player.play(AssetSource('bopomo/$word.mp3'));
                                              } else {
                                                await ftts.speak(word);
                                              }
                                              debugPrint('筆順 $word');
                                              if (nextStepId == steps['seeAnimation']) {
                                                setState(() {
                                                  nextStepId += 1;
                                                  debugPrint('setState 筆順 $word, nextStepId: $nextStepId');
                                                });
                                              }
                                            } else {
                                              controller.stopAnimation();
                                              debugPrint("stop animation // nextStepId update time");
                                            }
                                          }
                                        : null,
                                    fontSize: fontSize,
                                  ),
                                  buildIconButtonWithLabel(
                                    context: context,
                                    border: ((nextStepId > steps['seeAnimation']! && nextStepId < steps['turnBorderOff']!) && 
                                            !wordIsLearned && !controller.isQuizzing) || (nextStepId == steps['practiceWithoutBorder1']!),
                                    iconData: [Icons.edit_off, Icons.edit],
                                    label: '寫字',
                                    isSelected: controller.isQuizzing,
                                    onPressed: ((nextStepId > steps['seeAnimation']! && nextStepId < steps['turnBorderOff']!) || wordIsLearned || (nextStepId == steps['practiceWithoutBorder1']!))
                                        ? () async {
                                            controller.startQuiz();
                                            if (isBpmf) {
                                              await player.play(AssetSource('bopomo/$word.mp3'));
                                            } else {
                                              await ftts.speak(word);
                                            }
                                            debugPrint('寫字 $word');
                                          }
                                        : null,
                                    fontSize: fontSize,
                                  ),
                                  buildIconButtonWithLabel(
                                    context: context,
                                    border: (nextStepId == steps['turnBorderOff'] && !wordIsLearned),
                                    iconData: [Icons.remove_red_eye, Icons.remove_red_eye_outlined],
                                    label: '邊框',
                                    isSelected: controller.showOutline,
                                    onPressed: (nextStepId == steps['turnBorderOff'] || wordIsLearned)
                                        ? () {
                                            if (nextStepId == steps['turnBorderOff']) {
                                              setState(() {
                                                nextStepId += 1;
                                                debugPrint('setState 邊框 $word, nextStepId: $nextStepId');
                                              });
                                            }
                                            controller.setShowOutline(!controller.showOutline);
                                          }
                                        : null,
                                    fontSize: fontSize,
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
              ),
            ),

            useTabView[vocabIndex],
          ],
        ),
        bottomNavigationBar: BottomAppBar(
          height: 4.0 * fontSize,
          elevation: 0,
          color: darkBrown,
          child: ConstrainedBox(
            constraints: BoxConstraints(
              maxWidth: deviceWidth,  // Constrain the bottom app bar to the device width
            ),
            child: LeftRightSwitch(
              iconsColor: beige,
              iconsSize: fontSize * 2.0,
              rightBorder: false,
              middleWidget: WordCard(
                unitId: unitId,
                unitTitle: unitTitle,
                wordsStatus: widget.wordsStatus,
                wordsPhrase: widget.wordsPhrase,
                wordIndex: widget.wordIndex,
                sizedBoxWidth: 10 * fontSize,
                sizedBoxHeight: 4.0 * fontSize,
                fontSize: fontSize * 1.2,
                isBpmf: isBpmf,
                isVertical: false,
                disable: true,
              ),
              isFirst: (widget.wordIndex == 0),
              isLast: (widget.wordIndex == widget.wordsStatus.length - 1),
              onLeftClicked: () {
                navigateWithProvider(
                  context,
                  '/teachWord',
                  ref,
                  arguments: {
                    'unitId': widget.unitId,
                    'unitTitle': widget.unitTitle,
                    'wordsStatus': widget.wordsStatus,
                    'wordsPhrase': widget.wordsPhrase,
                    'wordIndex': widget.wordIndex - 1,
                  },
                );
              },
              onRightClicked: () {
                navigateWithProvider(
                  context,
                  '/teachWord',
                  ref,
                  arguments: {
                    'unitId': widget.unitId,
                    'unitTitle': widget.unitTitle,
                    'wordsStatus': widget.wordsStatus,
                    'wordsPhrase': widget.wordsPhrase,
                    'wordIndex': widget.wordIndex + 1,
                  },
                );
              },
            ),
          ),
        ),
      ),

    );

  }

  // Helper method to create an icon button with a label
  Widget buildIconButtonWithLabel({
    required BuildContext context,
    required bool border,
    required List<IconData> iconData,
    required String label,
    required bool isSelected,
    required Function()? onPressed, // Change the type to Function()?
    required double fontSize,
  }) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: <Widget>[
        LayoutBuilder(builder: (context, constraints) {
          return Container(
            decoration: BoxDecoration(
              border: border
                  ? Border.all(color: lightYellow, width: 1.5)
                  : null,
            ),
            child: IconButton(
              icon: Icon(
                isSelected ? iconData[0] : iconData[1],
                size: fontSize * 1.0,
              ),
              color: backgroundColor,
              onPressed: onPressed != null
                  ? () => onPressed()
                  : null, // Use a closure to call the function
            ),
          );
        }),
        Text(
          label,
          textAlign: TextAlign.center,
          style: TextStyle(
            fontSize: fontSize,
            color: backgroundColor,
          ),
        ),
      ],
    );
  }
  
  /*
  Widget _buildPracticeTimeIcon(bool condition, double fontSize, String defaultColorHex, String activeColorHex) {
    return Icon(
      condition ? Icons.check_circle_outline_outlined : Icons.check_circle,
      color: condition ? defaultColorHex.toColor() : activeColorHex.toColor(),
      size: fontSize * 1.5,
    );
  }
  */
  
  Widget _buildPracticeTimeIcon(bool condition, double fontSize, Color defaultColor, Color activeColor) {
    return Icon(
      condition ? Icons.check_circle_outline_outlined : Icons.check_circle,
      color: condition ? defaultColor : activeColor,
      size: fontSize * 1.5,
    );
  }


  // This method is responsible for rendering previously drawn correct strokes
  List<CustomPaint> paintCorrectStrokes(List<List<Offset>> correctStrokePaths,
      {Color brushColor = Colors.black, double brushWidth = 8}) {
    final List<CustomPaint> brushStrokes = [];

    for (var strokePath in correctStrokePaths) {
      if (strokePath.isNotEmpty) {
        brushStrokes.add(
          CustomPaint(
            painter: Brush(
              strokePath,
              brushColor: brushColor,
              brushWidth: brushWidth,
            ),
          ),
        );
      }
    }

    return brushStrokes;
  }



}

class TabContentView extends StatelessWidget {
  final String sectionName;
  final Widget contentWidget;
  final VoidCallback? onLeftClicked;
  final VoidCallback? onRightClicked;
  final bool isFirst;
  final bool isLast;
  final bool rightBorder;
  final ScreenInfo screenInfo;
  final double? fontSize;

  const TabContentView({
    super.key,
    required this.sectionName,
    required this.contentWidget,
    this.onLeftClicked,
    this.onRightClicked,
    this.isFirst = false,
    this.isLast = false,
    this.rightBorder = false,
    required this.screenInfo,
    this.fontSize,
  });

  @override
  Widget build(BuildContext context) {

    return SingleChildScrollView(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          ConstrainedBox(
            constraints: BoxConstraints(
              maxWidth: screenInfo.screenWidth - 10,
            ),
            child: Column(
              children: [
                LeftRightSwitch(
                  iconsColor: lightGray,
                  iconsSize: fontSize! * 2.0,
                  rightBorder: rightBorder,
                  middleWidget: TeachWordCardTitle(
                    sectionName: sectionName,
                    iconsColor: lightGray,
                  ),
                  isFirst: isFirst,
                  isLast: isLast,
                  onLeftClicked: onLeftClicked,
                  onRightClicked: onRightClicked,
                ),
                contentWidget,
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class UseTabContentView extends StatelessWidget {
  final String sectionName;
  final Widget contentWidget;
  final int vocabIndex;
  final VoidCallback? onLeftClicked;
  final VoidCallback? onRightClicked;
  final bool isFirst;
  final bool isLast;
  final ScreenInfo? screenInfo;
  final double? fontSize;
  final Color backgroundColor;

  const UseTabContentView({
    super.key,
    required this.sectionName,
    required this.contentWidget,
    required this.vocabIndex,
    required this.onLeftClicked,
    required this.onRightClicked,
    required this.isFirst,
    required this.isLast,
    required this.screenInfo,
    required this.fontSize,
    required this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {

    return SingleChildScrollView(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          ConstrainedBox(
            constraints: BoxConstraints(
              maxWidth: screenInfo!.screenWidth - 10,
            ),
            child: Column(
              children: [
                LeftRightSwitch(
                  iconsColor: lightGray,
                  iconsSize: fontSize! * 2.0,
                  rightBorder: false,
                  middleWidget: TeachWordCardTitle(
                    sectionName: sectionName,
                    iconsColor: lightGray,
                  ),
                  isFirst: isFirst,
                  isLast: isLast,
                  onLeftClicked: onLeftClicked,
                  onRightClicked: onRightClicked,
                ),
                contentWidget,
                Positioned(
                  right: fontSize,
                  bottom: fontSize,
                  child: Text(
                    "${vocabIndex + 1} / 2",
                    style: TextStyle(
                      fontSize: fontSize! * 0.75,
                      fontWeight: FontWeight.normal,
                      color: backgroundColor,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}


// End of file: ./lib/views/teach_word_view.dart
//----------------------

// File: ./lib/views/safety_hint_register_view.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/contants/register_question_label.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';

class SafetyHintRegisterView extends ConsumerStatefulWidget {
  const SafetyHintRegisterView({super.key});

  @override
  ConsumerState<SafetyHintRegisterView> createState() => _SafetyHintRegisterState();
}

const String notSelectQuestionRrrorHint = "尚未選擇安全提示問題";
const String noAnswerRrrorHint = "尚未回答安全提示問題";

class _SafetyHintRegisterState extends ConsumerState<SafetyHintRegisterView> {
  final TextEditingController q1Controller = TextEditingController();
  final TextEditingController a1Controller = TextEditingController();
  final TextEditingController q2Controller = TextEditingController();
  final TextEditingController a2Controller = TextEditingController();

  String showErrorHint = "";
  RegisterQuestionLabel? selectedQuestion1;
  RegisterQuestionLabel? selectedQuestion2;

  @override
  void initState() {
    showErrorHint = "";
    selectedQuestion1 = RegisterQuestionLabel.initial;
    selectedQuestion2 = RegisterQuestionLabel.initial;
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    
    double deviceHeight = screenInfo.screenHeight;

    final List<DropdownMenuEntry<RegisterQuestionLabel>> q1Entries =
        <DropdownMenuEntry<RegisterQuestionLabel>>[];
    final List<DropdownMenuEntry<RegisterQuestionLabel>> q2Entries =
        <DropdownMenuEntry<RegisterQuestionLabel>>[];

    for (final RegisterQuestionLabel question in RegisterQuestionLabel.values) {
      if (question.question != "") {
        q1Entries.add(DropdownMenuEntry<RegisterQuestionLabel>(
          label: question.question,
          value: question,
          style: ButtonStyle(
            textStyle: WidgetStateProperty.all<TextStyle>(
              TextStyle(
                fontSize: fontSize * 0.6,
                color: veryDarkGrayishBlue,
              ),
            ),
          ),
          enabled: question.question != "請選擇問題" &&
              question.question != selectedQuestion2!.question,
        ));
      }
    }

    for (final RegisterQuestionLabel question in RegisterQuestionLabel.values) {
      if (question.question != "") {
        q2Entries.add(
          DropdownMenuEntry<RegisterQuestionLabel>(
            label: question.question,
            value: question,
            style: ButtonStyle(
              textStyle: WidgetStateProperty.all<TextStyle>(
                TextStyle(
                  fontSize: fontSize * 0.6,
                  color: veryDarkGrayishBlue,
                ),
              ),
            ),
            enabled: question.question != "請選擇問題" &&
                question.question != selectedQuestion1!.question,
          ),
        );
      }
    }

    return GestureDetector(
        onTap: () {
          FocusScopeNode currentFocus = FocusScope.of(context);
          if (!currentFocus.hasPrimaryFocus) {
            currentFocus.unfocus();
          }
        },
        child: Scaffold(
          appBar: AppBar(
            leading: IconButton(
              icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
              onPressed: () => Navigator.pop(context),
            ),
          ),
          resizeToAvoidBottomInset: false,
          backgroundColor: veryDarkGray,
          body: SizedBox.expand(
            child: Column(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: <Widget>[
                  // SizedBox(height: deviceHeight * 0.04),

                  Text('選取安全提示',
                      style: TextStyle(
                        fontSize: fontSize * 1.2,
                      )),
                  Text('問題&答案',
                      style: TextStyle(
                        fontSize: fontSize * 1.2,
                      )),

                  // SizedBox(height: deviceHeight * 0.04),

                  Container(
                    decoration: BoxDecoration(
                      color: lightSkyBlue,
                      borderRadius: BorderRadius.circular(5),
                    ),
                    child: DropdownMenu<RegisterQuestionLabel>(
                      label: Text(
                        "請選擇問題 1 ",
                        style: TextStyle(
                          fontSize: fontSize,
                        ),
                      ),
                      controller: q1Controller,
                      width: 17.8 * fontSize,
                      textStyle: TextStyle(
                        fontSize: fontSize,
                        color: veryDarkGrayishBlue,
                      ),
                      dropdownMenuEntries: q1Entries,
                      onSelected: (RegisterQuestionLabel? questionLabel) {
                        setState(() {
                          selectedQuestion1 = questionLabel;
                        });
                      },
                    ),
                  ),

                  SizedBox(height: deviceHeight * 0.015),
                  Container(
                    height: 2.5 * fontSize,
                    width: 17.8 * fontSize,
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                        color: lightGray,
                        borderRadius: BorderRadius.circular(5),
                        border: Border.all(
                            width: 0.1 * fontSize, color: beige)),
                    child: Padding(
                      padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                      child: TextField(
                          controller: a1Controller,
                          style: TextStyle(
                              fontSize:
                                  fontSize, // Set your desired font size here
                              color: veryDarkGrayishBlue),
                          decoration: InputDecoration(
                            hintText: '回答 1',
                            hintStyle: TextStyle(
                                fontSize:
                                    fontSize, // Also set font size for hint text if needed
                                color: veryDarkGrayishBlue),
                            enabledBorder: InputBorder.none,
                            focusedBorder: InputBorder.none,
                          )),
                    ),
                  ),

                  SizedBox(height: deviceHeight * 0.015),

                  Container(
                    decoration: BoxDecoration(
                      color: lightSkyBlue,
                      borderRadius: BorderRadius.circular(5),
                    ),
                    child: DropdownMenu<RegisterQuestionLabel>(
                      label: Text(
                        "請選擇問題 2 ",
                        style: TextStyle(
                          fontSize: fontSize,
                          color: veryDarkGrayishBlue,
                        ),
                      ),
                      controller: q2Controller,
                      width: 17.8 * fontSize,
                      textStyle: TextStyle(
                        fontSize: fontSize,
                        color: veryDarkGrayishBlue,
                      ),
                      dropdownMenuEntries: q2Entries,
                      onSelected: (RegisterQuestionLabel? questionLabel) {
                        setState(() {
                          selectedQuestion2 = questionLabel;
                        });
                      },
                    ),
                  ),

                  SizedBox(height: deviceHeight * 0.015),
                  Container(
                    height: 2.5 * fontSize,
                    width: 17.8 * fontSize,
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                        color: lightGray,
                        borderRadius: BorderRadius.circular(5),
                        border: Border.all(
                            width: 0.1 * fontSize, color: beige)),
                    child: Padding(
                      padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                      child: TextField(
                          controller: a2Controller,
                          style: TextStyle(
                              fontSize:
                                  fontSize, // Set your desired font size here
                              color: veryDarkGrayishBlue),
                          decoration: InputDecoration(
                            hintText: '回答 2',
                            hintStyle: TextStyle(
                                fontSize:
                                    fontSize, // Also set font size for hint text if needed
                                color: veryDarkGrayishBlue),
                            enabledBorder: InputBorder.none,
                            focusedBorder: InputBorder.none,
                          )),
                    ),
                  ),

                  SizedBox(height: fontSize),

                  Visibility(
                      visible: (showErrorHint != ""),
                      maintainAnimation: true,
                      maintainSize: true,
                      maintainState: true,
                      child: Container(
                          height: fontSize * 0.5,
                          width: fontSize * 17.8,
                          alignment: AlignmentDirectional.topStart,
                          child: Text(showErrorHint,
                              style: TextStyle(
                                color: brightRed,
                                fontSize: fontSize * 0.8,
                              )))),

                  SizedBox(height: fontSize * 0.5),

                  Text('如果你忘記密碼，',
                      style: TextStyle(
                        fontSize: fontSize * 0.8,
                      )),

                  Text('這些問題可驗證你的身份，',
                      style: TextStyle(
                        fontSize: fontSize * 0.8,
                      )),

                  Text('協助你取回密碼。',
                      style: TextStyle(
                        fontSize: fontSize * 0.8,
                      )),

                  SizedBox(height: fontSize * 0.5),

                  TextButton(
                      onPressed: () {
                        if (q1Controller.text == "請選擇問題" ||
                            q2Controller.text == "請選擇問題") {
                          setState(() {
                            showErrorHint = notSelectQuestionRrrorHint;
                          });
                        } else if (a1Controller.text == "" ||
                            a2Controller.text == "") {
                          setState(() {
                            showErrorHint = noAnswerRrrorHint;
                          });
                        } else {
                          /*
                          Navigator.of(context)
                              .pushNamed('/register', arguments: {
                            'q1': selectedQuestion1?.value,
                            'a1': a1Controller.text,
                            'q2': selectedQuestion2?.value,
                            'a2': a2Controller.text,
                          });
                          */
                          navigateWithProvider(
                            context, 
                            '/register', 
                            ref, 
                            arguments: {
                            'q1': selectedQuestion1?.value,
                            'a1': a1Controller.text,
                            'q2': selectedQuestion2?.value,
                            'a2': a2Controller.text,
                          });
                        }
                      },
                      child: Text('下一步',
                          style: TextStyle(
                            fontSize: fontSize * 1.2,
                            color: beige,
                          )))
                ]),
          ),
        ));
  }
}

// End of file: ./lib/views/safety_hint_register_view.dart
//----------------------

// File: ./lib/views/register_view.dart

import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/contants/arabic_numerals_to_chinese.dart';
import 'package:ltrc/contants/semester_code.dart';
import 'package:ltrc/contants/publisher_code.dart';
import 'package:ltrc/data/models/user_model.dart';
import 'package:ltrc/data/providers/unit_provider.dart';
import 'package:ltrc/data/providers/user_provider.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';
import 'package:ltrc/widgets/mainPage/left_right_switch.dart';


class RegisterView extends ConsumerStatefulWidget {
  const RegisterView({super.key});

  @override
  RegisterViewState createState() => RegisterViewState();
}

class RegisterViewState extends ConsumerState<RegisterView> {
  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    
    double deviceHeight = screenInfo.screenHeight;
    double deviceWidth = screenInfo.screenWidth;
    bool isTablet = screenInfo.screenWidth > 600;

    final grade = ref.watch(gradeProvider);
    final semesterCode = ref.watch(semesterCodeProvider);
    final publisherCode = ref.watch(publisherCodeProvider);
    final pwd = ref.watch(pwdProvider);
    final account = ref.watch(accountProvider);

    dynamic obj = ModalRoute.of(context)!.settings.arguments;

    return Scaffold(
      backgroundColor: veryDarkGray,
      body: SizedBox.expand(
        
        child: Column(
          children: <Widget>[
            SizedBox(height: isTablet ? fontSize * 1.5 : fontSize * 3.0), // 避開 iPhone 11 Pro Max 的瀏海
            Container(
              height: fontSize * 6.0, // Adjust as needed
              width: deviceWidth * 0.7,
              decoration: const BoxDecoration(
                color: deepBlue,
              ),
              alignment: Alignment.center,  // Centers the content within the container
              child: Center(  // Ensures the text is centered both vertically and horizontally
                child: Text(
                  '請選擇：年級、學期、課本版本',
                  style: TextStyle(
                    color: beige,
                    fontSize: fontSize * 1.2,
                  ),
                  textAlign: TextAlign.center,  // Centers the text within its own bounds
                ),
              ),
            ),

            SizedBox(height: fontSize * 1.0),
            Icon(
              Icons.home_filled,
              color: warmOrange,
              size: deviceHeight * 0.083,
            ),
            LeftRightSwitch(
              // 年級
              iconsColor: beige,
              iconsSize: fontSize * 1.5,
              rightBorder: false,
              onLeftClicked: () => {
                ref.read(gradeProvider.notifier).state =
                    (ref.read(gradeProvider.notifier).state - 2) % 6 + 1
              },
              onRightClicked: () => {
                ref.read(gradeProvider.notifier).state =
                    (ref.read(gradeProvider.notifier).state) % 6 + 1
              },
              middleWidget: Container(
                  alignment: AlignmentDirectional.center,
                  width: deviceWidth * 0.57,
                  height: deviceHeight * 0.067,
                  decoration: BoxDecoration(
                      borderRadius: BorderRadiusDirectional.circular(20),
                      color: lightSkyBlue),
                  child: Text('${numeralToChinese[grade]}年級',
                      style: TextStyle(
                        color: black,
                        fontSize:
                            min(deviceWidth * 0.166, deviceHeight * 0.044),
                      ))),
              isFirst: false,
              isLast: false,
            ),
            SizedBox(height: fontSize * 0.3),
            LeftRightSwitch(
              // 學期
              iconsColor: beige,
              iconsSize: fontSize * 1.5,
              rightBorder: false,
              onLeftClicked: () => {
                ref.read(semesterCodeProvider.notifier).state =
                    (ref.read(semesterCodeProvider.notifier).state - 1) % 2
              },
              onRightClicked: () => {
                ref.read(semesterCodeProvider.notifier).state =
                    (ref.read(semesterCodeProvider.notifier).state + 1) % 2
              },
              middleWidget: Container(
                  alignment: AlignmentDirectional.center,
                  width: deviceWidth * 0.57,
                  height: deviceHeight * 0.067,
                  decoration: BoxDecoration(
                      borderRadius: BorderRadiusDirectional.circular(20),
                      color: lightSkyBlue),
                  child: Text(semesterCodeTable[semesterCode]!,
                      style: TextStyle(
                        color: black,
                        fontSize:
                            min(deviceWidth * 0.166, deviceHeight * 0.044),
                      ))),
              isFirst: false,
              isLast: false,
            ),
            SizedBox(height: fontSize * 0.3),
            LeftRightSwitch(
              // 出版商
              iconsColor: beige,
              iconsSize: fontSize * 1.5,
              rightBorder: false,
              onLeftClicked: () => {
                ref.read(publisherCodeProvider.notifier).state =
                    (ref.read(publisherCodeProvider.notifier).state - 1) % 3
              },
              onRightClicked: () => {
                ref.read(publisherCodeProvider.notifier).state =
                    (ref.read(publisherCodeProvider.notifier).state + 1) % 3
              },
              middleWidget: Container(
                  alignment: AlignmentDirectional.center,
                  width: deviceWidth * 0.57,
                  height: deviceHeight * 0.067,
                  decoration: BoxDecoration(
                      borderRadius: BorderRadiusDirectional.circular(20),
                      color: lightSkyBlue),
                  child: Text(publisherCodeTable[publisherCode]!,
                      style: TextStyle(
                        color: black,
                        fontSize:
                            min(deviceWidth * 0.166, deviceHeight * 0.044),
                      ))),
              isFirst: false,
              isLast: false,
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(
                  0, deviceHeight * 0.0687, 0, fontSize * 1.0),
              child: Container(
                  alignment: AlignmentDirectional.center,
                  width: deviceHeight * 0.095,
                  height: deviceHeight * 0.095,
                  decoration: const BoxDecoration(
                    color: warmOrange,
                    shape: BoxShape.circle,
                  ),
                  child: IconButton(
                    icon: Icon(Icons.chevron_right, size: fontSize * 1.2),
                    color: veryDarkGray,
                    iconSize: deviceHeight * 0.09,
                    onPressed: () async {
                      try {
                        await UserProvider.addUser(
                          user: User(
                            account: account,
                            password: pwd,
                            safetyQuestionId1: obj['q1'],
                            safetyAnswer1: obj['a1'] as String,
                            safetyQuestionId2: obj['q2'],
                            safetyAnswer2: obj['a2'] as String,
                            grade: grade,
                            semester: semesterCodeTable[semesterCode]!,
                            publisher: publisherCodeTable[publisherCode]!,
                          ),
                        );
                      } catch (e) {
                        throw ("create user error: $e");
                      }

                      ref.read(totalWordCountProvider.notifier).state =
                          await UnitProvider.getTotalWordCount(
                        inputPublisher: publisherCodeTable[publisherCode]!,
                        inputGrade: grade,
                        // inputSemester: "上", // Need to enhance
                        inputSemester: semesterCodeTable[semesterCode]!,
                      );

                      ref.read(learnedWordCountProvider.notifier).state = 0;
                      if (!context.mounted) return;
                      // Navigator.of(context).pushNamed('/mainPage');
                      navigateWithProvider(context, '/mainPage', ref);
                    },
                  )),
            )
          ],
        ),
      ),
    );
  }
}

// End of file: ./lib/views/register_view.dart
//----------------------

// File: ./lib/views/bopomos_view.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/data/models/word_status_model.dart';
// import 'package:ltrc/extensions.dart';
import 'package:ltrc/providers.dart';
// import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';
import '../widgets/word_card.dart';
// import '../

class BopomosView extends ConsumerWidget {
  const BopomosView({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;
    bool isTablet = screenInfo.screenWidth > 600;

    dynamic obj = ModalRoute.of(context)!.settings.arguments;
    List<WordStatus> wordsStatus = obj['wordStatus'];
    List<Map> wordsPhrase = obj['wordsPhrase'];

    return Scaffold(
        appBar: AppBar(
          leading: IconButton(
            icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
            onPressed: () => Navigator.pop(context),
          ),
          title: Text(
            "00 | 學注音",
            style: TextStyle(
                fontSize: fontSize * 1.0), // Set the font size for the title
          ),
          actions: [
            IconButton(
              icon: Icon(Icons.home, size: fontSize * 1.5),
              // onPressed: () => Navigator.of(context).pushNamed('/mainPage'),
              onPressed: () => navigateWithProvider(context, '/mainPage', ref),
            )
          ],
        ),
        body: CustomScrollView(
          slivers: [
            SliverPadding(
              padding: const EdgeInsets.fromLTRB(14, 8, 14, 16),
              sliver: SliverGrid(
                gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
                  maxCrossAxisExtent: isTablet
                      ? fontSize * 8.0
                      : fontSize * 8.0, // This is most important
                  mainAxisSpacing: fontSize * 0.5, // Reduced spacing
                  crossAxisSpacing: fontSize * 0.5, // Reduced spacing
                  childAspectRatio: isTablet ? 4 / 3 : 4 / 4,
                ),
                delegate: SliverChildBuilderDelegate(
                  (BuildContext context, int index) {
                    return WordCard(
                      disable: false,
                      isBpmf: true,
                      unitId: 0,
                      unitTitle: "學注音",
                      wordsStatus: wordsStatus,
                      wordsPhrase: wordsPhrase,
                      wordIndex: index,
                      sizedBoxWidth: fontSize *
                          2.0, // 1.8 This may need to be adjusted if the cards are still too wide
                      sizedBoxHeight: fontSize *
                          3.0, // 9.1 This may need to be adjusted if the cards are still too tall
                      fontSize: fontSize *
                          2.5, // Ensure this is appropriate for the size of the cards
                      isVertical: true,
                    );
                  },
                  childCount: wordsStatus.length,
                ),
              ),
            ),
            SliverPadding(
              padding: const EdgeInsets.fromLTRB(46, 16, 46, 16),
              sliver: SliverList(
                  delegate: SliverChildBuilderDelegate(
                (BuildContext context, int idx) {
                  return InkWell(
                    // onTap: () => Navigator.of(context).pushNamed('/bopomoQuiz'),
                    onTap: () => navigateWithProvider(context, '/bopomoQuiz', ref),
                    child: Container(
                      width: fontSize * 17.5,
                      height: fontSize * 4.0,
                      alignment: Alignment.center,
                      decoration: const BoxDecoration(
                        borderRadius:
                            BorderRadius.all(Radius.circular(14)),
                        color: beige,
                      ),
                      child: Text(
                        "拼拼看",
                        style: TextStyle(
                          fontSize: fontSize * 2.0,
                          color: darkBrown,
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ),
                  );
                },
                childCount: 1,
              )),
            ),
          ],
        ));
  }
}

// End of file: ./lib/views/bopomos_view.dart
//----------------------

// File: ./lib/views/log_in_view.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/contants/semester_code.dart';
import 'package:ltrc/contants/publisher_code.dart';
import 'package:ltrc/data/models/user_model.dart';
import 'package:ltrc/data/providers/unit_provider.dart';
import 'package:ltrc/data/providers/user_provider.dart';
// import 'package:ltrc/extensions.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';

class LogInView extends ConsumerStatefulWidget {
  const LogInView({super.key});

  @override
  LogInViewState createState() => LogInViewState();
}

const String pwdConfirmErrorHint = "帳號/密碼錯誤";
const String accountLengthErrorHint = "帳號長度不足 6 位英/數字";
const String abnormalErrorHint = "無法登入，請告知老師";

class LogInViewState extends ConsumerState<LogInView> {
  TextEditingController accountController = TextEditingController();
  TextEditingController pwdController = TextEditingController();

  bool pwdVisible = false;
  String showErrorHint = "";

  @override
  void initState() {
    super.initState();
    pwdVisible = true;
    showErrorHint = "";
  }

  @override
  Widget build(BuildContext context) {
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;
    double deviceHeight = screenInfo.screenHeight;
    double deviceWidth = screenInfo.screenWidth;
    debugPrint('log_in_view: H: $deviceHeight, W: $deviceWidth, F: $fontSize');

    return GestureDetector(
      onTap: () {
        FocusScopeNode currentFocus = FocusScope.of(context);
        if (!currentFocus.hasPrimaryFocus) {
          currentFocus.unfocus();
        }
      },
      child: Scaffold(
        resizeToAvoidBottomInset: false,
        backgroundColor: veryDarkGray,
        body: SingleChildScrollView(  // Allow scrolling in case of overflow
          child: ConstrainedBox(
            constraints: BoxConstraints(
              minHeight: deviceHeight,
            ),
            child: IntrinsicHeight(  // Ensure the Column takes up minimum height of the screen
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: <Widget>[
                  SizedBox(height: deviceHeight * 0.1),
                  Text('學國語',
                      style: TextStyle(
                        fontSize: fontSize * 3.0, // was 4.0
                      )),
                  SizedBox(height: fontSize * 2.0),
                  Container(
                      height: deviceHeight * 60 / 712,
                      width: deviceWidth * 5 / 6,
                      decoration: BoxDecoration(
                          color: lightSkyBlue,
                          borderRadius: BorderRadius.circular(5),
                          border: Border.all(
                              width: 0.3 * fontSize,
                              color: beige)),
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                        child: TextField(
                            controller: accountController,
                            style: TextStyle(
                                color: veryDarkGrayishBlue, fontSize: fontSize),
                            decoration: InputDecoration(
                              prefixIcon: Icon(
                                Icons.account_circle,
                                size: fontSize * 1.8,
                                color: veryDarkGrayishBlue,
                              ),
                              hintText: '帳號名稱',
                              hintStyle: TextStyle(
                                fontSize: fontSize * 1.2,
                                color: veryDarkGrayishBlue,
                              ),
                              floatingLabelBehavior: FloatingLabelBehavior.always,
                              floatingLabelAlignment: FloatingLabelAlignment.center,
                              focusedBorder: InputBorder.none,
                              enabledBorder: InputBorder.none,
                            )),
                      )),
                  SizedBox(height: deviceHeight * 0.073),
                  Container(
                      height: deviceHeight * 60 / 712,
                      width: deviceWidth * 5 / 6,
                      decoration: BoxDecoration(
                          color: lightSkyBlue,
                          borderRadius: BorderRadius.circular(5),
                          border: Border.all(
                              width: 0.3 * fontSize,
                              color: beige)),
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(10.0, 0.0, 10.0, 0.0),
                        child: TextField(
                            controller: pwdController,
                            obscureText: pwdVisible,
                            style: TextStyle(
                                color: veryDarkGrayishBlue, fontSize: fontSize),
                            decoration: InputDecoration(
                              prefixIcon: Icon(
                                Icons.lock,
                                size: fontSize * 1.8,
                                color: veryDarkGrayishBlue,
                              ),
                              hintText: '密碼',
                              hintStyle: TextStyle(
                                fontSize: fontSize * 1.2,
                                color: veryDarkGrayishBlue,
                              ),
                              floatingLabelBehavior: FloatingLabelBehavior.always,
                              floatingLabelAlignment: FloatingLabelAlignment.center,
                              focusedBorder: InputBorder.none,
                              enabledBorder: InputBorder.none,
                              suffixIcon: IconButton(
                                icon: Icon(pwdVisible ? Icons.visibility : Icons.visibility_off),
                                iconSize: fontSize,
                                onPressed: () {
                                  setState(() {
                                    pwdVisible = !pwdVisible;
                                  });
                                },
                              ),
                            )),
                      )),
                  Center(
                    child: SizedBox(
                      width: deviceWidth * 5 / 6,
                      child: Align(
                        alignment: AlignmentDirectional.bottomEnd,
                        child: TextButton(
                          onPressed: () => navigateWithProvider(context, '/resetPwdAccount', ref),
                          style: TextButton.styleFrom(
                            minimumSize: const Size(110, 16),
                          ),
                          child: Text('忘記密碼',
                              style: TextStyle(
                                fontSize: fontSize * 0.8,
                                color: beige,
                              )),
                        ),
                      ),
                    ),
                  ),
                  Visibility(
                      visible: (showErrorHint != ""),
                      maintainAnimation: true,
                      maintainSize: true,
                      maintainState: true,
                      child: Container(
                          width: deviceWidth * 5 / 6,
                          alignment: AlignmentDirectional.topStart,
                          child: Text(showErrorHint,
                              style: TextStyle(
                                color: brightRed,
                                fontSize: 1.0 * fontSize,
                              )))),
                  SizedBox(height: deviceHeight * 0.038),
                  Center(
                      child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: <Widget>[
                        TextButton(
                            onPressed: () async {
                              accountController.text = accountController.text.trim();
                              pwdController.text = pwdController.text.trim();
                              if (accountController.text.length < 6) {
                                setState(() {
                                  showErrorHint = accountLengthErrorHint;
                                });
                              } else {
                                try {
                                  User user = await UserProvider.getUser(inputAccount: accountController.text);

                                  debugPrint('User found: ${user.account}');

                                  if (user.password != pwdController.text) {
                                    debugPrint('Password does not match for user: ${user.account}');
                                    setState(() {
                                      showErrorHint = pwdConfirmErrorHint;
                                    });
                                  } else {
                                    debugPrint('Password matched for user: ${user.account}');

                                    ref.read(accountProvider.notifier).state = accountController.text;
                                    ref.read(userNameProvider.notifier).state = user.username;
                                    ref.read(gradeProvider.notifier).state = user.grade;
                                    ref.read(semesterCodeProvider.notifier).state = semesterCodeTable.keys.firstWhere(
                                            (e) => semesterCodeTable[e] == user.semester);
                                    ref.read(publisherCodeProvider.notifier).state = publisherCodeTable.keys.firstWhere(
                                            (e) => publisherCodeTable[e] == user.publisher);

                                    ref.read(totalWordCountProvider.notifier).state = await UnitProvider.getTotalWordCount(
                                      inputPublisher: user.publisher,
                                      inputGrade: user.grade,
                                      inputSemester: user.semester,
                                    );

                                    ref.read(learnedWordCountProvider.notifier).state = await UnitProvider.getLearnedWordCount(
                                      inputAccount: accountController.text,
                                      inputPublisher: user.publisher,
                                      inputGrade: user.grade,
                                      inputSemester: user.semester,
                                    );

                                    if (!context.mounted) return;

                                    navigateWithProvider(context, '/mainPage', ref);
                                  }
                                } catch (e) {
                                  debugPrint('Error fetching user: $e');
                                  setState(() {
                                    showErrorHint = abnormalErrorHint;
                                  });
                                }
                              }
                            },
                            style: TextButton.styleFrom(
                              minimumSize: const Size(110, 30),
                            ),
                            child: Text('登入',
                                style: TextStyle(
                                  fontSize: fontSize * 1.4,
                                  color: beige,
                                ))),
                        Text('/',
                            style: TextStyle(
                              fontSize: fontSize * 1.4,
                            )),
                        TextButton(
                            onPressed: () => navigateWithProvider(context, '/registerAccount', ref),
                            style: TextButton.styleFrom(
                              minimumSize: const Size(110, 30),
                            ),
                            child: Text('註冊',
                                style: TextStyle(
                                  fontSize: fontSize * 1.4,
                                  color: beige,
                                )))
                      ])),
                  const Spacer(),  // Spacer to push content up
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

}

// End of file: ./lib/views/log_in_view.dart
//----------------------

// File: ./lib/views/words_view.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/contants/bopomos.dart';
import 'package:ltrc/data/models/unit_model.dart';
import 'package:ltrc/data/models/word_status_model.dart';
import 'package:ltrc/providers.dart';
// import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';
import 'package:ltrc/widgets/word_card.dart';


class WordsView extends ConsumerWidget {
  const WordsView({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;
    bool isTablet = screenInfo.screenWidth > 600;
    if (isTablet) {fontSize = fontSize * 1.2;}

    dynamic obj = ModalRoute.of(context)!.settings.arguments;
    Unit unit = obj["unit"];
    List<WordStatus> newWordsStatus = obj["newWordsStatus"];
    List<WordStatus> extraWordsStatus = obj["extraWordsStatus"] ?? [];
    List<Map> newWordsPhrase = obj["newWordsPhrase"];
    List<Map> extraWordsPhrase = obj["extraWordsPhrase"] ?? [];

    return Scaffold(
        appBar: AppBar(
          leading: IconButton(
            icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
            onPressed: () => Navigator.pop(context),
          ),
          title: (unit.id == -1)
              ? Text(unit.unitTitle,
                  style: TextStyle(
                    fontSize: fontSize * 1.0,
                  ))
              : Text(
                  "${unit.unitId.toString().padLeft(2, '0')} | ${unit.unitTitle}",
                  style: TextStyle(
                    fontSize: fontSize * 1.0,
                  )),
          actions: [
            IconButton(
              icon: Icon(Icons.home, size: fontSize * 1.5),
              // onPressed: () => Navigator.of(context).pushNamed('/mainPage'),
              onPressed: () => navigateWithProvider(context, '/mainPage', ref),
            )
          ],
        ),
        body: CustomScrollView(
          slivers: [
            SliverPadding(
              padding: const EdgeInsets.all(20),
              sliver: SliverGrid(
                gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
                  maxCrossAxisExtent: isTablet
                      ? fontSize * 8.0
                      : fontSize * 8.0, // This is most important
                  mainAxisSpacing: fontSize * 0.5, // was 10,
                  crossAxisSpacing: fontSize * 0.5, // was 10,
                  childAspectRatio: isTablet ? 4 / 3 : 4 / 4,
                ),
                delegate: SliverChildBuilderDelegate(
                  (BuildContext context, int index) {
                    return WordCard(
                      isBpmf: (initials.contains(newWordsStatus[index].word) ||
                          prenuclear.contains(newWordsStatus[index].word) ||
                          finals.contains(newWordsStatus[index].word)),
                      unitId: unit.unitId,
                      unitTitle: unit.unitTitle,
                      wordsStatus: newWordsStatus,
                      wordsPhrase: newWordsPhrase,
                      wordIndex: index,
                      sizedBoxWidth: fontSize * 2.0,
                      sizedBoxHeight: fontSize * 3.0,
                      fontSize: fontSize * 2.0, // 2.5
                      isVertical: true,
                      disable: false,
                    );
                  },
                  childCount: newWordsStatus.length,
                ),
              ),
            ),
            (extraWordsStatus.isEmpty)
                ? const SliverToBoxAdapter(child: Text(''))
                : SliverPadding(
                    padding: const EdgeInsets.fromLTRB(24, 0, 0, 0),
                    sliver: SliverToBoxAdapter(
                        child: Text("唸唸看",
                            style: TextStyle(
                              fontSize: fontSize * 1.5,
                            )))),
            SliverPadding(
              padding: const EdgeInsets.all(20),
              sliver: SliverGrid(
                gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
                  maxCrossAxisExtent: isTablet
                      ? fontSize * 8.0
                      : fontSize * 8.0, // This is most important
                  mainAxisSpacing: fontSize * 0.5, // was 15,
                  crossAxisSpacing: fontSize * 0.5, // was 15,
                  childAspectRatio: isTablet ? 4 / 3 : 4 / 4,
                ),
                delegate: SliverChildBuilderDelegate(
                  (BuildContext context, int index) {
                    return WordCard(
                        isBpmf: false,
                        unitId: unit.unitId,
                        unitTitle: unit.unitTitle,
                        wordsStatus: extraWordsStatus,
                        wordsPhrase: extraWordsPhrase,
                        wordIndex: index,
                        sizedBoxWidth: fontSize * 2.0,
                        sizedBoxHeight: fontSize * 3.0,
                        fontSize: fontSize * 2.5,
                        isVertical: true,
                        disable: false);
                  },
                  childCount: extraWordsStatus.length,
                ),
              ),
            )
          ],
        ));
  }
}

// End of file: ./lib/views/words_view.dart
//----------------------

// File: ./lib/views/acknowledge.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/providers.dart';
// import 'package:ltrc/views/view_utils.dart';

class Resource{
  final String resource;
  final String description;

  Resource({required this.resource, required this.description});
}

final List<Resource> resourceList = [
  Resource(
    resource: "各年級生字表",
    description: "由中研院語言學研究所李佳穎老師提供，用於所有功能。"
  ),
  Resource(
    resource: "字型演變",
    description: "來自中央研究院歷史語言學研究所與資訊科學研究所開發之「小學堂」字型演變資料庫。"
  ),
  Resource(
    resource: "筆順動畫",
    description: "來自文鼎科技開發股份有限公司授權之漢字及注音字型。更感謝他們的技術支持。"
  ),  
  Resource(
    resource: "注音字卡", 
    description: "由郭俊成老師提供，用於注音符號的學習。"
  ),
  Resource(
    resource: "注音符號處理方法", 
    description: "ButTaiwan, https://github.com/ButTaiwan/bpmfvs/blob/master/NOTICE.txt. jeffreyxuan, https://github.com/jeffreyxuan/toneoz-font-zhuyin-wenkai."
  ),  
    Resource(
    resource: "注音符號錄音",
    description: "胡銘志老師幫忙錄製注音符號發音。"
  ),  
  Resource(
    resource: "諮詢顧問",
    description: "鄭漢文校長與陳素慧老師擔任諮詢顧問，提供寶貴現場教學經驗。"
  ),
  Resource(
    resource: "APP開發",
    description: "林羿成、蔡伊甯、李昊翰、方新舟合力開發此軟體。版權歸誠致教育基金會所有。"
  ),
  Resource(
    resource: "版權所有©2024誠致教育基金會", 
    description: ''
  )
];

class AcknowledgeView extends ConsumerWidget {
  const AcknowledgeView({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;
    if (screenInfo.isTablet && MediaQuery.of(context).orientation == Orientation.landscape) {
      fontSize *= 1.3;
    }
    
    int count = 0;
    return Scaffold(
        appBar: AppBar(
          leading: IconButton(
            icon: Icon(Icons.chevron_left, size: fontSize * 1.5),
            onPressed: () => Navigator.pop(context),
          ),
          title: Text("授權與致謝",
              style: TextStyle(
                fontSize: fontSize * 1.0,
              )),
        ),
        body: CustomScrollView(slivers: [
          SliverPadding(
              padding: const EdgeInsets.fromLTRB(23, 14, 23, 20),
              sliver: SliverToBoxAdapter(
                child: Column(
                    mainAxisAlignment: MainAxisAlignment.start,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text("",           //"版權所有©2024誠致教育基金會" moved to the bottom
                          textAlign: TextAlign.right,
                          style: TextStyle(
                              fontSize: fontSize * 0.3, fontWeight: FontWeight.normal)),
                      ...resourceList.map((e) {
                        count++;
                        return Padding(
                            padding: const EdgeInsets.fromLTRB(0, 7, 0, 7),
                            child: Text(
                                "$count. ${e.resource}\n ${e.description}",
                                style: TextStyle(fontSize: fontSize)));
                      // ignore: unnecessary_to_list_in_spreads
                      }).toList(),
                    ]),
              ))
        ]));
  }
}
// End of file: ./lib/views/acknowledge.dart
//----------------------

// File: ./lib/widgets/grade_and_provider_button.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';
// import 'package:ltrc/views/view_utils.dart';
// import 'package:ltrc/providers.dart';

class GradeAndProviderButton extends ConsumerWidget {
  final double buttonWidth;
  final double buttonHeight;
  final String text;
  const GradeAndProviderButton(
      {super.key,
        required this.buttonWidth,
        required this.buttonHeight,
        required this.text});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    

    return Container(
      width: buttonWidth,
      height: buttonHeight,
      decoration: const BoxDecoration(
        boxShadow: [
          BoxShadow(
            color: Colors.black26,
            offset: Offset(0, 6),
            blurRadius: 6
          )
        ]
      ),
      child: ElevatedButton(
        onPressed: () {},
        style: ButtonStyle(
          shape: WidgetStateProperty.all<RoundedRectangleBorder>(
            RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(7)
            ),
          ),
          backgroundColor: const WidgetStatePropertyAll(lightGray)
        ),
        child: Text(
          text,
          style: TextStyle(
            color: black,
            fontSize: fontSize,
          )
        )
      ),
    );
  }
}

// End of file: ./lib/widgets/grade_and_provider_button.dart
//----------------------

// File: ./lib/widgets/teach_word/card_title.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/providers.dart';
// import 'package:ltrc/providers.dart';
// import 'package:ltrc/views/view_utils.dart';
// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:ltrc/providers.dart';
// import 'package:ltrc/views/polyphonic_processor.dart';
import 'package:ltrc/widgets/teach_word/zhuyin_processing.dart';
// import 'package:tuple/tuple.dart';

class TeachWordCardTitle extends ConsumerWidget {
  final Color iconsColor;
  final String sectionName;
  const TeachWordCardTitle({
    required this.iconsColor,
    required this.sectionName,
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    

    return Container(
      width: fontSize * 8.0, // for 3 1.5 fontSize characters
      height: fontSize * 2.0, // word fontSize = 1.8
      alignment: Alignment.center,
      margin: const EdgeInsets.all(8.0),
      decoration: BoxDecoration(
        borderRadius: const BorderRadius.all(Radius.circular(38 / 2)),
        color: iconsColor,
      ),
      child: ZhuyinProcessing(
        text: sectionName,
        fontSize: fontSize * 1.2,
        color: Colors.black,
        highlightOn: false,
      ),
    );
  }
}

// End of file: ./lib/widgets/teach_word/card_title.dart
//----------------------

// File: ./lib/widgets/teach_word/zhuyin_processing.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/polyphonic_processor.dart';
import 'package:tuple/tuple.dart';

class ZhuyinProcessing extends ConsumerWidget {
  final String text;
  final double fontSize;
  final Color color;
  final bool highlightOn;

  const ZhuyinProcessing({
    super.key,
    required this.text,
    required this.fontSize,
    required this.color,
    required this.highlightOn,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    int grade = ref.watch(gradeProvider);

    if (grade < 5) {
      return FutureBuilder<Tuple2<List<TextSpan>, String>>(
        // future: _processText(fontSize, text),
        future: PolyphonicProcessor.instance.process(text, fontSize, color, highlightOn),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.done && snapshot.hasData) {
            return RichText(
              text: TextSpan(children: snapshot.data!.item1),
              // style: TextStyle(
              //   fontSize: fontSize,
              //   color: color,
              // ),
            );
          } else if (snapshot.hasError) {
            return Text('Error loading polyphonic data',
              style: TextStyle(
                fontSize: fontSize,
                color: color,
              ),
            );
          } else {
            return const CircularProgressIndicator();
          }
        },
      );
    } else {
      return Text(
        text,
        style: TextStyle(
          fontSize: fontSize,
          color: color,
        ),
      );
    }
  }
}

// End of file: ./lib/widgets/teach_word/zhuyin_processing.dart
//----------------------

// File: ./lib/widgets/teach_word/word_vocab_content.dart

// word_vocab_content.dart is a stateful widget that displays the vocabulary, meaning, and example sentence.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_tts/flutter_tts.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/widgets/teach_word/zhuyin_processing.dart';

class WordVocabContent extends ConsumerStatefulWidget {
  final String vocab; // correct answer
  final String meaning;
  final String sentence;
  final String vocab2; // wrong answer

  const WordVocabContent({
    super.key,
    required this.vocab,
    required this.meaning,
    required this.sentence,
    required this.vocab2,
  });

  @override
  WordVocabContentState createState() => WordVocabContentState();
}

class WordVocabContentState extends ConsumerState<WordVocabContent> {
  final FlutterTts ftts = FlutterTts();
  late String vocab;
  late String vocab2;
  late String meaning;
  late String sentence;
  String displayedSentence = '';
  late List<String> options;
  String message = '';
  late String blankSentence;

  @override
  void initState() {
    super.initState();
    // debugPrint('word_vocab_content initState: vocab = ${widget.vocab}, sentence = ${widget.sentence}, stack: ${StackTrace.current}');
    debugPrint('word_vocab_content initState: vocab = ${widget.vocab}, sentence = ${widget.sentence}');
    _initVariables();
  }

  @override
  void didUpdateWidget(covariant WordVocabContent oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Only reinitialize variables if vocab or sentence has changed
    if (widget.vocab != oldWidget.vocab || widget.sentence != oldWidget.sentence) {
      debugPrint('Updating variables because vocab or sentence has changed.');
      _initVariables();
    } else {
      debugPrint('No change in vocab or sentence, skipping re-initialization.');
    }
  }

  void _initVariables() {
    vocab = widget.vocab;
    vocab2 = widget.vocab2;
    meaning = widget.meaning;
    sentence = widget.sentence;
    blankSentence = _createBlankSentence(sentence, vocab);
    displayedSentence = blankSentence;
    options = [vocab, vocab2]..shuffle();
    message = '';
    debugPrint('Initialized variables: vocab = $vocab, options = $options');
  }

  String _createBlankSentence(String sentence, String vocab) {
    int vocabLength = vocab.length;
    String underscoreString = "__" * vocabLength;
    return sentence.replaceAll(vocab, underscoreString);
  }

  Future<void> _speak(String text) async {
    int result = await ftts.speak(text);
    if (result == 1) {
      debugPrint('WordVocabContent _speak succeeded! text: $text');
    } else {
      debugPrint('WordVocabContent _speak failed! text: $text');
    }
  }

  void _selectWord(String word) {
    // debugPrint('_selectWord: word = $word, vocab = $vocab, stack: ${StackTrace.current}');
    debugPrint('_selectWord: word = $word, vocab = $vocab');
    _speak(word);
    if (word == vocab) {
      setState(() {
        // debugPrint('setState _selectWord: 答對了, stack: ${StackTrace.current}');
        debugPrint('setState _selectWord: 答對了');
        displayedSentence = widget.sentence;
        message = '答對了！';
      });
    } else {
      setState(() {
        // debugPrint('setState _selectWord: 再試試, stack: ${StackTrace.current}');
        debugPrint('setState _selectWord: 再試試');
        displayedSentence = blankSentence;
        message = '再試試！';
      });
    }
    _speak(message);
  }

  void _onContinuePressed() {
    debugPrint('_onContinuePressed: init variables');
    _initVariables(); // Reset for a new page
    setState(() {
      debugPrint('setState _onContinuePressed: resetting message');
      message = '';
    });
  }

  @override
  Widget build(BuildContext context) {
    // debugPrint('Building WordVocabContent widget: stack: ${StackTrace.current}');
    debugPrint('Building WordVocabContent widget');
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;

    const Color explanationColor = Color.fromRGBO(228, 219, 124, 1);
    const Color whiteColor = Colors.white;

    List<Widget> children = [
      // Vocabulary display with TTS button
      Container(
        alignment: Alignment.center,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              widget.vocab,
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: fontSize * 1.2,
                color: explanationColor,
              ),
            ),
            IconButton(
              icon: const Icon(Icons.volume_up),
              iconSize: fontSize * 1.2,
              color: explanationColor,
              onPressed: () => _speak(widget.vocab),
            ),
          ],
        ),
      ),

      // Meaning of the vocabulary
      Padding(
        padding: EdgeInsets.only(left: fontSize * 0.5),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Text(
                  "解釋：",
                  style: TextStyle(
                    fontSize: fontSize,
                    color: explanationColor,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.volume_up),
                  iconSize: fontSize,
                  color: explanationColor,
                  onPressed: () => _speak(widget.meaning),
                ),
              ],
            ),
            ZhuyinProcessing(
              text: widget.meaning,
              fontSize: fontSize,
              color: whiteColor,
              highlightOn: true,
            ),
          ],
        ),
      ),
      SizedBox(height: fontSize * 0.1),

      // Example sentence with TTS button
      Padding(
        padding: EdgeInsets.only(left: fontSize * 0.5),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Text(
                  "例句：",
                  style: TextStyle(
                    fontSize: fontSize,
                    color: explanationColor,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.volume_up),
                  iconSize: fontSize,
                  color: explanationColor,
                  onPressed: () => _speak(widget.sentence),
                ),
              ],
            ),
            ZhuyinProcessing(
              text: displayedSentence,
              fontSize: fontSize,
              color: whiteColor,
              highlightOn: true,
            ),
          ],
        ),
      ),

      // Display options (vocab and vocab2) as buttons
      Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: options.map((word) {
          return Container(
            width: fontSize * 10.0, // for 4 1.5 fontSize characters
            height: fontSize * 2.0, // word fontSize = 1.0
            alignment: Alignment.center,
            margin: const EdgeInsets.all(0.0),
            child: ElevatedButton(
              onPressed: () => _selectWord(word),
              child: Text(
                word,
                style: TextStyle(
                  fontSize: fontSize * 0.90, // 1.0 will overflow in some small devices
                  color: Colors.black,
                ),
              ),
            ),
          );
        }).toList(),
      ),

      Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            '繼    ', // Invisible text to center "答對了！" and "再試試！"
            style: TextStyle(
              fontSize: fontSize, // Adjust font size accordingly
              color: Colors.transparent, // Text color is transparent
            ),
          ),
          // Display message based on selection
          if (message.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 0.0),
              child: Text(
                message,
                style: TextStyle(
                  color: explanationColor,
                  fontSize: fontSize * 1.0,
                ),
              ),
            ),

          // Continue button
          if (message.isNotEmpty)
            ElevatedButton(
              onPressed: _onContinuePressed,
              // 用下面 style 把 button 隱藏起來
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.transparent,
                disabledForegroundColor: Colors.transparent.withOpacity(0.38),
                disabledBackgroundColor: Colors.transparent.withOpacity(0.12),
                shadowColor: Colors.transparent,
                elevation: 0,
              ),
              child: Text(
                '續',// Invisible text
                style: TextStyle(
                  fontSize: fontSize,
                  color: Colors.transparent,
                ),
              ),
            ),
        ],
      ),
    ];

    return Column(
      mainAxisAlignment: MainAxisAlignment.start,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: children,
    );
  }
}

// End of file: ./lib/widgets/teach_word/word_vocab_content.dart
//----------------------

// File: ./lib/widgets/teach_word/stroke_order_animation_controller.dart

import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:svg_path_parser/svg_path_parser.dart';

import 'stroke_order_animator.dart';

/// A ChangeNotifier that controls the behaviour of a stroke order diagram.
/// It must be passed as an argument to a [StrokeOrderAnimator] that handles
/// the actual presentation of the diagram. It can be consumed by the
/// [StrokeOrderAnimator] and an app to allow for synchronization of, e.g.,
/// control buttons with the animations.
class StrokeOrderAnimationController extends ChangeNotifier {
  String _strokeOrder;
  String get strokeOrder => _strokeOrder;
  List<int> _radicalStrokeIndices = List.empty();
  List<int> get radicalStrokes => _radicalStrokeIndices;

  int _nStrokes = 0;
  int get nStrokes => _nStrokes;
  int _currentStroke = 0;
  int get currentStroke => _currentStroke;
  List<Path> _strokes = List.empty();
  List<Path> get strokes => _strokes;
  List<List<Offset>> _medians = List.empty();
  List<List<Offset>> get medians => _medians;

  final AnimationController _strokeAnimationController;
  AnimationController get strokeAnimationController =>
      _strokeAnimationController;
  final AnimationController _hintAnimationController;
  AnimationController get hintAnimationController => _hintAnimationController;
  bool _isAnimating = false;
  bool get isAnimating => _isAnimating;
  bool _isQuizzing = false;
  bool get isQuizzing => _isQuizzing;
  double _strokeAnimationSpeed = 1;
  double _hintAnimationSpeed = 3;

  QuizSummary _summary = QuizSummary(0);
  QuizSummary get summary => _summary;

  final List<Function> _onQuizCompleteCallbacks = [];
  final List<Function> _onWrongStrokeCallbacks = [];
  final List<Function> _onCorrectStrokeCallbacks = [];

  bool _showStroke;
  bool _showOutline;
  bool _showMedian;
  bool _showUserStroke;
  bool _highlightRadical;

  bool get showStroke => _showStroke;
  bool get showOutline => _showOutline;
  bool get showMedian => _showMedian;
  bool get showUserStroke => _showUserStroke;
  bool get highlightRadical => _highlightRadical;

  Color _strokeColor;
  Color _outlineColor;
  Color _medianColor;
  Color _radicalColor;
  Color _brushColor;
  Color _hintColor;

  Color get strokeColor => _strokeColor;
  Color get outlineColor => _outlineColor;
  Color get medianColor => _medianColor;
  Color get radicalColor => _radicalColor;
  Color get brushColor => _brushColor;
  Color get hintColor => _hintColor;

  double _brushWidth;
  double get brushWidth => _brushWidth;

  int _hintAfterStrokes;
  int get hintAfterStrokes => _hintAfterStrokes;

  StrokeOrderAnimationController(
    this._strokeOrder,
    tickerProvider, {
    double strokeAnimationSpeed = 1,
    double hintAnimationSpeed = 1,
    bool showStroke = true,
    bool showOutline = true,
    bool showMedian = false,
    bool showUserStroke = false,
    bool highlightRadical = false,
    Color strokeColor = const Color.fromRGBO(153, 153, 153, 1),
    Color outlineColor = const Color.fromRGBO(153, 153, 153, 1),
    Color medianColor = const Color.fromRGBO(153, 153, 153, 1),
    Color radicalColor = Colors.red,
    Color brushColor = const Color.fromRGBO(153, 153, 153, 1),
    double brushWidth = 8.0,
    int hintAfterStrokes = 3,
    Color hintColor = Colors.white,
    Function? onQuizCompleteCallback,
    Function? onWrongStrokeCallback,
    Function? onCorrectStrokeCallback,
  })  : _strokeColor = strokeColor,
        _showStroke = showStroke,
        _showOutline = showOutline,
        _showMedian = showMedian,
        _showUserStroke = showUserStroke,
        _highlightRadical = highlightRadical,
        _outlineColor = outlineColor,
        _medianColor = medianColor,
        _radicalColor = radicalColor,
        _brushColor = brushColor,
        _brushWidth = brushWidth,
        _hintAfterStrokes = hintAfterStrokes,
        _hintColor = hintColor,
        _strokeAnimationSpeed = strokeAnimationSpeed,
        _hintAnimationSpeed = hintAnimationSpeed,
        _strokeAnimationController = AnimationController(
          vsync: tickerProvider,
        ),
        _hintAnimationController = AnimationController(
          vsync: tickerProvider,
        ) {
    _strokeAnimationController.addStatusListener(_strokeCompleted);

    _hintAnimationController.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        _hintAnimationController.reset();
      }
    });

    setStrokeOrder(_strokeOrder);  // this causes problem
    _setCurrentStroke(0);
    _summary = QuizSummary(_nStrokes);

    addOnQuizCompleteCallback(onQuizCompleteCallback);
    addOnWrongStrokeCallback(onWrongStrokeCallback);
    addOnCorrectStrokeCallback(onCorrectStrokeCallback);

    notifyListeners();
  }

  @override
  dispose() {
    _strokeAnimationController.dispose();
    _hintAnimationController.dispose();
    _onCorrectStrokeCallbacks.clear();
    _onWrongStrokeCallbacks.clear();
    _onQuizCompleteCallbacks.clear();
    super.dispose();
  }

  void startAnimation() {
    if (!_isAnimating && !_isQuizzing) {
      if (currentStroke == _nStrokes) {
        _setCurrentStroke(0);
      }
      _isAnimating = true;
      _strokeAnimationController.forward();
      notifyListeners();
    }
  }

  void stopAnimation() {
    if (_isAnimating) {
      _setCurrentStroke(currentStroke + 1);
      _isAnimating = false;
      _strokeAnimationController.reset();
      notifyListeners();
    }
  }

  void startQuiz() {
    if (!_isQuizzing) {
      _isAnimating = false;
      _setCurrentStroke(0);
      summary.reset();
      _strokeAnimationController.reset();
      _isQuizzing = true;
      notifyListeners();
    }
  }

  void stopQuiz() {
    if (_isQuizzing) {
      _isAnimating = false;
      _strokeAnimationController.reset();
      _isQuizzing = false;
      notifyListeners();
    }
  }

  void nextStroke() {
    if (!_isQuizzing) {
      if (currentStroke == _nStrokes) {
        _setCurrentStroke(1);
      } else if (_isAnimating) {
        _setCurrentStroke(currentStroke + 1);
        _strokeAnimationController.reset();

        if (currentStroke < _nStrokes) {
          _strokeAnimationController.forward();
        } else {
          _isAnimating = false;
        }
      } else {
        if (currentStroke < _nStrokes) {
          _setCurrentStroke(currentStroke + 1);
        }
      }

      notifyListeners();
    }
  }

  void previousStroke() {
    if (!_isQuizzing) {
      if (currentStroke != 0) {
        _setCurrentStroke(currentStroke - 1);
      }

      if (_isAnimating) {
        _strokeAnimationController.reset();
        _strokeAnimationController.forward();
      }

      notifyListeners();
    }
  }

  void reset() {
    _setCurrentStroke(0);
    _isAnimating = false;
    _strokeAnimationController.reset();
    summary.reset();
    notifyListeners();
  }

  void showFullCharacter() {
    if (!_isQuizzing) {
      _setCurrentStroke(_nStrokes);
      _isAnimating = false;
      _strokeAnimationController.reset();
      notifyListeners();
    }
  }

  void _strokeCompleted(AnimationStatus status) {
    if (status == AnimationStatus.completed) {
      _setCurrentStroke(currentStroke + 1);
      _strokeAnimationController.reset();
      if (currentStroke < _nStrokes) {
        _strokeAnimationController.forward();
      } else {
        _isAnimating = false;
      }
    }
    notifyListeners();
  }

  void setShowStroke(bool value) {
    _showStroke = value;
    notifyListeners();
  }

  void setShowUserStroke(bool value) {
    _showUserStroke = value;
    notifyListeners();
  }

  void setShowOutline(bool value) {
    _showOutline = value;
    notifyListeners();
  }

  void setShowMedian(bool value) {
    _showMedian = value;
    notifyListeners();
  }

  void setHighlightRadical(bool value) {
    _highlightRadical = value;
    notifyListeners();
  }

  void setStrokeColor(Color value) {
    _strokeColor = value;
    notifyListeners();
  }

  void setOutlineColor(Color value) {
    _outlineColor = value;
    notifyListeners();
  }

  void setMedianColor(Color value) {
    _medianColor = value;
    notifyListeners();
  }

  void setRadicalColor(Color value) {
    _radicalColor = value;
    notifyListeners();
  }

  void setBrushColor(Color value) {
    _brushColor = value;
    notifyListeners();
  }

  void setHintColor(Color value) {
    _hintColor = value;
    notifyListeners();
  }

  void setBrushWidth(double value) {
    _brushWidth = value;
    notifyListeners();
  }

  void setHintAfterStrokes(int value) {
    _hintAfterStrokes = value;
    notifyListeners();
  }

  void setStrokeAnimationSpeed(double value) {
    _strokeAnimationSpeed = value;
    _setCurrentStroke(currentStroke);
  }

  void setHintAnimationSpeed(double value) {
    _hintAnimationSpeed = value;
    _setCurrentStroke(currentStroke);
  }

  void _setNormalizedStrokeAnimationSpeed(double normFactor) {
    _strokeAnimationController.duration = Duration(
        milliseconds: (normFactor / _strokeAnimationSpeed * 1000).toInt());
  }

  void _setNormalizedHintAnimationSpeed(double normFactor) {
    _hintAnimationController.duration = Duration(
        milliseconds: (normFactor / _hintAnimationSpeed * 1000).toInt());
  }

  void addOnQuizCompleteCallback(Function? onQuizCompleteCallback) {
    if (onQuizCompleteCallback != null) {
      _onQuizCompleteCallbacks.add(onQuizCompleteCallback);
    }
  }

  void addOnWrongStrokeCallback(Function? onWrongStrokeCallback) {
    if (onWrongStrokeCallback != null) {
      _onWrongStrokeCallbacks.add(onWrongStrokeCallback);
    }
  }

  void addOnCorrectStrokeCallback(Function? onCorrectStrokeCallback) {
    if (onCorrectStrokeCallback != null) {
      _onCorrectStrokeCallbacks.add(onCorrectStrokeCallback);
    }
  }

  void setStrokeOrder(String strokeOrder) {
    dynamic parsedJson;
    List<Path> tmpStrokes;
    List<List<Offset>> tmpMedians;
    List<int> tmpRadicalStrokeIndices = [];

    if (strokeOrder.isNotEmpty) {
      try {
        parsedJson = json.decode(strokeOrder.replaceAll("'", '"'));
      } catch (e) {
        throw const FormatException("Invalid JSON string for stroke order.");
      }

      try {
        tmpStrokes = List.generate(
            parsedJson['strokes'].length,
            (index) => parseSvgPath(parsedJson['strokes'][index]).transform(
                // Transformation according to the makemeahanzi documentation
                Matrix4(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 900, 0, 1)
                    .storage));
      } catch (e) {
        throw const FormatException("Invalid strokes in stroke order JSON.");
      }

      try {
        tmpMedians = List.generate(parsedJson['medians'].length, (iStroke) {
          return List.generate(parsedJson['medians'][iStroke].length, (iPoint) {
            return Offset(
                (parsedJson['medians'][iStroke][iPoint][0]).toDouble(),
                (parsedJson['medians'][iStroke][iPoint][1] * -1 + 900)
                    .toDouble());
          });
        });
      } catch (e) {
        throw const FormatException("Invalid medians in stroke order JSON.");
      }

      if (tmpMedians.length != tmpStrokes.length) {
        throw const FormatException("Number of strokes and medians not equal.");
      }

      // Check for the existence of 'radStrokes' in the parsed JSON
      if (parsedJson.containsKey('radStrokes') && parsedJson['radStrokes'] != null) {
        try {
          tmpRadicalStrokeIndices = List<int>.generate(
              parsedJson['radStrokes'].length,  // lengh is null
              (index) => parsedJson['radStrokes'][index]);
        } catch (e, s) {
          // debugPrint("Could not read radical stroke indices from JSON.");  // why this error?
          debugPrint('Error: $e');
          debugPrint('StackTrace: $s');
          tmpRadicalStrokeIndices = [];
        }
      } else {
        debugPrint("No radical stroke indices found in JSON."); // why this error?
        tmpRadicalStrokeIndices = [];
      }

      if (tmpStrokes.isNotEmpty) {
        _strokeOrder = strokeOrder;
        _strokes = tmpStrokes;
        _medians = tmpMedians;
        _radicalStrokeIndices = tmpRadicalStrokeIndices;
        _nStrokes = _strokes.length;
      }
    } else {
      throw const FormatException("Stroke order JSON is empty.");
    }
  }

  void checkStroke(List<Offset?> rawStroke) {
    List<Offset> stroke = getNonNullPointsFrom(rawStroke);
    final strokeLength = getLength(stroke);

    if (isQuizzing && currentStroke < nStrokes && strokeLength > 0) {
      if (strokeIsCorrect(strokeLength, stroke)) {
        notifyCorrectStrokeCallbacks();
        _summary.correctStrokePaths[currentStroke] = stroke;
        _setCurrentStroke(currentStroke + 1);

        if (currentStroke == nStrokes) {
          stopQuiz();
          notifyQuizCompleteCallbacks();
        }
      } else {
        summary.mistakes[currentStroke] += 1;
        notifyWrongStrokeCallbacks();

        if (summary.mistakes[currentStroke] >= hintAfterStrokes) {
          animateHint();
        }
      }

      notifyListeners();
    }
  }

  bool strokeIsCorrect(double strokeLength, List<Offset> stroke) {
    final median = _medians[currentStroke];
    final medianLength = getLength(median);

    List<double> allowedLengthRange = getAllowedLengthRange(medianLength);
    double startEndMargin = getStartEndMargin(medianLength);

    bool isCorrect = false;

    if (strokeLengthWithinBounds(strokeLength, allowedLengthRange) &&
        strokeStartIsWithinMargin(stroke, median, startEndMargin) &&
        strokeEndIsWithinMargin(stroke, median, startEndMargin) &&
        strokeHasRightDirection(stroke, median)) {
      isCorrect = true;
    }
    return isCorrect;
  }

  void animateHint() {
    if (!(debugSemanticsDisableAnimations ?? false)) {
      _hintAnimationController.reset();
      _hintAnimationController.forward();
    }
  }

  void notifyWrongStrokeCallbacks() {
    for (var callback in _onWrongStrokeCallbacks) {
      callback(currentStroke);
    }
  }

  void notifyQuizCompleteCallbacks() {
    for (var callback in _onQuizCompleteCallbacks) {
      callback(summary);
    }
  }

  void notifyCorrectStrokeCallbacks() {
    for (var callback in _onCorrectStrokeCallbacks) {
      callback(currentStroke);
    }
  }

  double getStartEndMargin(double medianLength) {
    double startEndMargin;

    // Be more lenient on short strokes
    if (medianLength < 150) {
      startEndMargin = 200;
    } else {
      startEndMargin = 150;
    }
    return startEndMargin;
  }

  List<double> getAllowedLengthRange(double medianLength) {
    List<double> lengthRange;

    // Be more lenient on short strokes
    if (medianLength < 150) {
      lengthRange = [0.2, 3];
    } else {
      lengthRange = [0.5, 1.5];
    }

    lengthRange = lengthRange.map((e) => e.toDouble() * medianLength).toList();

    return lengthRange;
  }

  bool strokeHasRightDirection(
      List<Offset> points, List<Offset> currentMedian) {
    return ((distance2D(points.first, currentMedian.first) <
            distance2D(points.last, currentMedian.first)) ||
        (distance2D(points.last, currentMedian.last) <
            distance2D(points.first, currentMedian.last)));
  }

  bool strokeStartIsWithinMargin(
      List<Offset> points, List<Offset> currentMedian, double startEndMargin) {
    final strokeStartWithinMargin =
        points.first.dx > currentMedian.first.dx - startEndMargin &&
            points.first.dx < currentMedian.first.dx + startEndMargin &&
            points.first.dy > currentMedian.first.dy - startEndMargin &&
            points.first.dy < currentMedian.first.dy + startEndMargin;
    return strokeStartWithinMargin;
  }

  bool strokeEndIsWithinMargin(
      List<Offset> points, List<Offset> currentMedian, double startEndMargin) {
    final strokeEndWithinMargin =
        points.last.dx > currentMedian.last.dx - startEndMargin &&
            points.last.dx < currentMedian.last.dx + startEndMargin &&
            points.last.dy > currentMedian.last.dy - startEndMargin &&
            points.last.dy < currentMedian.last.dy + startEndMargin;
    return strokeEndWithinMargin;
  }

  bool strokeLengthWithinBounds(double strokeLength, List<double> lengthRange) {
    return strokeLength > lengthRange[0] && strokeLength < lengthRange[1];
  }

  double getLength(List<Offset> points) {
    double pathLength = 0;

    final path = convertOffsetsToPath(points);
    final pathMetrics = path.computeMetrics().toList();

    if (pathMetrics.isNotEmpty) {
      pathLength = pathMetrics.first.length;
    }
    return pathLength;
  }

  Path convertOffsetsToPath(List<Offset> points) {
    final path = Path();

    if (points.length > 1) {
      path.moveTo(points[0].dx.toDouble(), points[0].dy.toDouble());
      for (var point in points) {
        path.lineTo(point.dx.toDouble(), point.dy.toDouble());
      }
    }

    return path;
  }

  List<Offset> getNonNullPointsFrom(List<Offset?> rawPoints) {
    List<Offset> points = [];

    for (var point in rawPoints) {
      if (point != null) {
        points.add(point);
      }
    }

    return points;
  }

  void _setCurrentStroke(int value) {
    _currentStroke = value;

    // Normalize the animation speed to the length of the stroke
    // The first stroke of 你 (length 520) is taken as reference
    if (currentStroke < nStrokes) {
      final currentMedian = _medians[currentStroke];

      final medianPath = Path();
      if (currentMedian.length > 1) {
        medianPath.moveTo(currentMedian[0].dx, currentMedian[0].dy);
        for (var point in currentMedian) {
          medianPath.lineTo(point.dx, point.dy);
        }
      }

      final medianLength = medianPath.computeMetrics().first.length;

      if (medianLength > 0) {
        final normFactor = (medianLength / 520).clamp(0.5, 1.5);
        _setNormalizedStrokeAnimationSpeed(normFactor);
        _setNormalizedHintAnimationSpeed(normFactor);
      }
    }

    notifyListeners();
  }
}

class QuizSummary {
  final int _nStrokes;
  int get nStrokes => _nStrokes;

  late List<int> mistakes;
  late List<List<Offset>> correctStrokePaths;

  int get nTotalMistakes =>
      mistakes.fold(0, (previous, current) => previous + current);

  QuizSummary(this._nStrokes) {
    reset();
  }

  void reset() {
    mistakes = List.generate(nStrokes, (index) => 0);
    correctStrokePaths = List.generate(nStrokes, (index) => []);
  }
}

// End of file: ./lib/widgets/teach_word/stroke_order_animation_controller.dart
//----------------------

// File: ./lib/widgets/teach_word/stroke_order_animator.dart

import 'dart:math';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'stroke_order_animation_controller.dart';

/// A widget for displaying a stroke order diagram.
/// Takes a `StrokeOrderAnimationController` as argument.
class StrokeOrderAnimator extends StatefulWidget {
  final StrokeOrderAnimationController _controller;

  const StrokeOrderAnimator(this._controller, {super.key});

  @override
  StrokeOrderAnimatorState createState() => StrokeOrderAnimatorState();
}

class StrokeOrderAnimatorState extends State<StrokeOrderAnimator> {
  List<Offset?> _points = <Offset>[];

  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onPanUpdate: (DragUpdateDetails details) {
        setState(() {
          RenderBox box = context.findRenderObject() as RenderBox;
          Offset point = box.globalToLocal(details.globalPosition);

          if (point.dx >= 0 &&
              point.dx <= box.size.width &&
              point.dy >= 0 &&
              point.dy <= box.size.height) {
            _points = List.from(_points)..add(point);
          } else {
            if (_points.last != null) {
              _points = List.from(_points)..add(null);
            }
          }
        });
      },
      onPanEnd: (DragEndDetails details) {
        widget._controller.checkStroke(_points);
        setState(() {
          _points.clear();
        });
      },
      child: Stack(
        children: <Widget>[
          ...List.generate(widget._controller.strokes.length, (index) {
            // Determine whether to use standard stroke color, radical color or hint color
            Color strokeColor = widget._controller.strokeColor;

            if (widget._controller.highlightRadical &&
                widget._controller.radicalStrokes.contains(index)) {
              strokeColor = widget._controller.radicalColor;
            }

            if (widget._controller.isQuizzing &&
                index == widget._controller.currentStroke) {
              strokeColor = widget._controller.hintColor;
            }

            final animate = index == widget._controller.currentStroke &&
                (widget._controller.isAnimating ||
                    widget._controller.isQuizzing);
            final animationController = widget._controller.isQuizzing
                ? widget._controller.hintAnimationController
                : widget._controller.strokeAnimationController;

            return SizedBox(
              width: 1024,  // ressponsive?
              height: 1024,  // ressponsive?
              child: CustomPaint(
                  painter: StrokePainter(widget._controller.strokes[index],
                      showStroke: widget._controller.showStroke &&
                          index < widget._controller.currentStroke,
                      strokeColor: strokeColor,
                      showOutline: widget._controller.showOutline,
                      outlineColor: widget._controller.outlineColor,
                      showMedian: widget._controller.showMedian,
                      medianColor: widget._controller.medianColor,
                      animate: animate,
                      animation: animationController,
                      median: widget._controller.medians[index])),
            );
          }),
          if (widget._controller.showUserStroke)
            ...paintCorrectStrokes(
                widget._controller.summary.correctStrokePaths,
                brushColor: widget._controller.brushColor,
                brushWidth: widget._controller.brushWidth),
          if (widget._controller.isQuizzing)
            CustomPaint(
              painter: Brush(_points,
                brushColor: widget._controller.brushColor,
                brushWidth: widget._controller.brushWidth
              ),
            ),
        ],
      ),
    );
  }

  List<CustomPaint> paintCorrectStrokes(List<List<Offset>> correctStrokePaths,
      {Color brushColor = Colors.black, double brushWidth = 8}) {
    final List<CustomPaint> brushStrokes = [];

    for (var strokePath in correctStrokePaths) {
      if (strokePath.isNotEmpty) {
        brushStrokes.add(
          CustomPaint(
            painter: Brush(
              strokePath,
              brushColor: brushColor,
              brushWidth: brushWidth,
            ),
          ),
        );
      }
    }

    return brushStrokes;
  }
}

class StrokePainter extends CustomPainter {
  // If the stroke should be animated, an animation and the median have to be provided
  final bool animate;
  final Animation<double>? animation;
  final Path strokeOutlinePath;
  final Color strokeColor;
  final Color outlineColor;
  final Color medianColor;
  final bool showOutline;
  final bool showStroke;
  final bool showMedian;
  final List<Offset> median;

  double strokeStart = -1;
  double strokeEnd = -1;

  Path visibleStroke = Path();

  StrokePainter(
    this.strokeOutlinePath, {
    this.showStroke = true,
    this.strokeColor = Colors.grey,
    this.showOutline = false,
    this.outlineColor = Colors.black,
    this.showMedian = false,
    this.medianColor = Colors.black,
    this.animate = false,
    this.animation,
    this.median = const [],
  }) : super(repaint: animation);

  @override
  void paint(Canvas canvas, Size size) {
    if (strokeStart < 0) {
      // Calculate the points on strokeOutlinePath that are closest to the start and end points of the median
      strokeStart = getClosestPointOnPathAsDistanceOnPath(
          strokeOutlinePath, median.first);
      strokeEnd =
          getClosestPointOnPathAsDistanceOnPath(strokeOutlinePath, median.last);
    }

    var strokePaint = Paint()
      ..color = strokeColor
      ..style = PaintingStyle.fill;

    if (animate == true && median.isNotEmpty) {
      if (strokeStart >= 0 && strokeEnd >= 0) {
        // Split the original path into two paths that follow the outline
        // of the stroke from strokeStart to strokeEnd clockwise and counter-clockwise
        List<Path> contourPaths =
            extractContourPaths(strokeOutlinePath, strokeStart, strokeEnd);

        // Go on the first contourPath first, then jump over to the second path and go back to the start
        final lenFirstPath = contourPaths.first.computeMetrics().first.length;
        final lenSecondPath = contourPaths.last.computeMetrics().first.length;

        Path finalOutlinePath = contourPaths.first
            .computeMetrics()
            .first
            .extractPath(0, (animation?.value ?? 1) * lenFirstPath);
        finalOutlinePath.extendWithPath(
            contourPaths.last.computeMetrics().first.extractPath(
                lenSecondPath - (animation?.value ?? 1) * lenSecondPath,
                lenSecondPath),
            const Offset(0, 0));

        canvas.drawPath(finalOutlinePath, strokePaint);
      }
    } else if (showStroke) {
      canvas.drawPath(strokeOutlinePath, strokePaint);
    }

    if (showOutline) {
      var borderPaint = Paint()
        ..color = outlineColor
        ..strokeWidth = 2.0
        ..style = PaintingStyle.stroke;
      canvas.drawPath(strokeOutlinePath, borderPaint);
    }

    if (showMedian) {
      final medianPath = Path();
      medianPath.moveTo(median[0].dx.toDouble(), median[0].dy.toDouble());
      for (var point in median) {
        medianPath.lineTo(point.dx.toDouble(), point.dy.toDouble());
      }
      canvas.drawPath(
          medianPath,
          Paint()
            ..style = PaintingStyle.stroke
            ..strokeWidth = 2.0
            ..color = medianColor);
    }
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => true;
}

List<Path> extractContourPaths(
    Path strokeOutlinePath, double strokeStartLength, double strokeEndLength) {
  Path path1 = Path();
  Path path2 = Path();

  final metrics = strokeOutlinePath.computeMetrics().toList()[0];

  if (strokeEndLength > strokeStartLength) {
    path1 = metrics.extractPath(strokeStartLength, strokeEndLength);
    path2 = metrics.extractPath(strokeEndLength, metrics.length);
    path2.extendWithPath(
        metrics.extractPath(0, strokeStartLength), const Offset(0, 0));
  } else {
    path1 = metrics.extractPath(strokeStartLength, metrics.length);
    path1.extendWithPath(metrics.extractPath(0, strokeEndLength), const Offset(0, 0));
    path2 = metrics.extractPath(strokeEndLength, strokeStartLength);
  }

  // path1 leads from start to end, path2 continues from end to start
  return [path1, path2];
}

double getClosestPointOnPathAsDistanceOnPath(Path path, Offset queryPoint) {
  PathMetric metrics = path.computeMetrics().toList()[0];

  int nSteps = 100;
  double pathLength = metrics.length;
  double stepSize = pathLength / nSteps;

  List<Offset> pointsOnPath = [];

  double minDistance = double.infinity;

  // x, y, and length on the path where that point lies
  double closestPoint = -1;

  // Sample nSteps points on the path
  for (var step = 0.0; step < pathLength; step += stepSize) {
    final tangent = metrics.getTangentForOffset(step)!;
    pointsOnPath.add(tangent.position);
  }

  // Find the point on the path closest to the query
  for (var iPoint = 0; iPoint < pointsOnPath.length; iPoint++) {
    final point = pointsOnPath[iPoint];
    final distance = distance2D(point, queryPoint);
    if (distance < minDistance) {
      minDistance = distance;
      closestPoint = iPoint * stepSize;
    }
  }

  return closestPoint;
}

double distance2D(Offset p, Offset q) {
  return sqrt(pow(p.dx - q.dx, 2) + pow(p.dy - q.dy, 2));
}

class Brush extends CustomPainter {
  final List<Offset?> points;
  final Color brushColor;
  final double brushWidth;

  Brush(
    this.points, {
    this.brushColor = Colors.black,
    this.brushWidth = 8.0,
  });

  @override
  bool shouldRepaint(Brush oldDelegate) {
    return oldDelegate.points != points;
  }

  @override
  void paint(Canvas canvas, Size size) {
    Paint paint = Paint()
      ..color = brushColor
      ..strokeCap = StrokeCap.round
      ..strokeWidth = brushWidth;

    for (int i = 0; i < points.length - 1; i++) {
      if (points[i] != null && points[i + 1] != null) {
        canvas.drawLine(points[i]!, points[i + 1]!, paint);
      }
    }
  }
}

// End of file: ./lib/widgets/teach_word/stroke_order_animator.dart
//----------------------

// File: ./lib/widgets/teach_word/tab_bar_view.dart

// tab_bar_view.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';

class TeachWordTabBarView extends ConsumerWidget {
  final Widget content;
  const TeachWordTabBarView({
    super.key,
    required this.content,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    
    double deviceHeight = screenInfo.screenHeight;
    double deviceWidth = screenInfo.screenWidth;
    debugPrint('TeachWordTabBarView: H: $deviceHeight, W: $deviceWidth, F: $fontSize');

    return LayoutBuilder(
      builder: (context, constraints) {
        return Column(
          children: [
            Expanded(
              child: Container(
                width: deviceWidth,
                decoration: BoxDecoration(
                  color: darkBrown,
                  border: Border.all(color: mediumGray, width: 6),
                ),
                child: Column(
                  children: [
                    SizedBox(height: fontSize * 0.2),
                    Expanded(
                      // child: SingleChildScrollView( // sjf take out so that it won't scroll
                        child: content,
                      // ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        );
      },
    );
  }
}

// End of file: ./lib/widgets/teach_word/tab_bar_view.dart
//----------------------

// File: ./lib/widgets/teach_word/bpmf_vocab_content.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_tts/flutter_tts.dart';
import 'package:ltrc/providers.dart';
// import 'package:ltrc/providers.dart';
// import 'package:ltrc/views/view_utils.dart';
import 'package:ltrc/widgets/teach_word/zhuyin_processing.dart';

class BopomofoVocabContent extends ConsumerWidget {
  final String word;
  final String vocab;
  final String sentence;
  final FlutterTts ftts = FlutterTts(); // Initialize the TTS engine

  BopomofoVocabContent({
    super.key,
    required this.word,
    required this.vocab,
    required this.sentence,
  });

  Future<void> _speak(String text) async {
    int result = await ftts.speak(text); // Implement the TTS functionality
    if (result == 1) {
      // debugPrint('BopomofoVocabContent _speak succeeded!');
    } else {
      debugPrint('BopomofoVocabContent _speak failed!');
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    

    String subSentence = sentence;
    if (subSentence.length > 25) {
      subSentence = "${subSentence.substring(0, 25)}...。";
    }

    return Column(
      mainAxisAlignment: MainAxisAlignment.start,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Container(
          alignment: Alignment.center,
          child: Column(
            children: [
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  ZhuyinProcessing(
                    text: vocab,
                    fontSize: fontSize * 2.0, 
                    color: const Color.fromRGBO(228, 219, 124, 1),
                    highlightOn: true,
                  ),
                  IconButton(
                    icon: const Icon(Icons.volume_up),
                    iconSize: fontSize * 2.0,
                    color: const Color.fromRGBO(228, 219, 124, 1),
                    onPressed: () => _speak(vocab),
                  ),
                ],
              ),
              Image(
                height: fontSize * 8.5,
                image: AssetImage('lib/assets/img/bopomo/$word.png'),
              ),
              SizedBox(height: fontSize * 0.5),
              ZhuyinProcessing(
                text: subSentence,
                fontSize: fontSize * 1.3, 
                color: const Color.fromRGBO(245, 245, 220, 100),
                highlightOn: true,
              ),              
              IconButton(
                icon: const Icon(Icons.volume_up),
                iconSize: fontSize * 1.3,
                color: const Color.fromRGBO(245, 245, 220, 100),
                onPressed: () => _speak(subSentence),
              ),
            ],
          ),
        ),
      ],
    );
  }
}


// End of file: ./lib/widgets/teach_word/bpmf_vocab_content.dart
//----------------------

// File: ./lib/widgets/progress_bar.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/providers.dart';
// import 'package:ltrc/providers.dart';
import 'package:ltrc/views/view_utils.dart';

class ProgressBar extends ConsumerWidget {
  const ProgressBar({super.key, required this.maxCount, required this.value});
  final int value;
  final int maxCount;
  // final iconSize = 58.0;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    
    double deviceWidth = screenInfo.screenWidth;
    double iconSize = fontSize * 2.0;
    return Column(
      children: [
        SizedBox(
          width: 0.87 * deviceWidth,
          height: iconSize, // 58,
          child: Stack(clipBehavior: Clip.none, children: <Widget>[
            Align(
              alignment: Alignment.center,
              child: Container(
                width: 0.66 * deviceWidth,
                height: fontSize, // 24,
                decoration: BoxDecoration(
                    border: Border.all(color: beige, width: 3),
                    borderRadius: BorderRadius.circular(10)),
                child: LinearProgressIndicator(
                  backgroundColor: lightGray,
                  value: value/maxCount,
                  valueColor:
                      const AlwaysStoppedAnimation<Color>(warmOrange),
                ),
              ),
            ),
            Builder(builder: (context) {
              // double leftPadding = iconSize / 2 + 240 * value - iconSize / 2;
              double leftPadding = fontSize * 2 + 0.66 * deviceWidth * value / maxCount; // - iconSize / 2;
              double topPadding = iconSize / 2 - iconSize / 2;
              return Padding(
                  padding: EdgeInsets.only(left: leftPadding, top: topPadding),
                  child: Icon(Icons.star,
                      size: iconSize, color: beige));
            })
          ]),
        ),
        Container(
          width: 0.87 * deviceWidth,
          padding: const EdgeInsetsDirectional.only(start: 21, end: 11),
          child: Row(
            children: [
              Align(
                alignment: Alignment.centerLeft,
                child: Text(value.toString(),
                  style: TextStyle(
                    fontSize: fontSize, // 24,
                  )
                )
              ),
              Expanded(child: Container()),
              Text(
                maxCount.toString(),
                style: TextStyle(
                  fontSize: fontSize, // 24,
                )
              )
            ]
          ),
        )
      ],
    );
  }
}

// End of file: ./lib/widgets/progress_bar.dart
//----------------------

// File: ./lib/widgets/word_card.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/data/models/word_status_model.dart';
import 'package:ltrc/data/providers/word_status_provider.dart';
import 'package:ltrc/views/view_utils.dart';  // Make sure this import is correct

class WordCard extends ConsumerStatefulWidget {
  const WordCard({
    super.key,
    required this.unitId,
    required this.unitTitle,
    required this.wordsStatus,
    required this.wordsPhrase,
    required this.wordIndex,
    required this.sizedBoxWidth,
    required this.sizedBoxHeight,
    required this.fontSize,
    required this.isBpmf,
    required this.isVertical,
    required this.disable
  });

  final int unitId;
  final String unitTitle;
  final double sizedBoxWidth;
  final double sizedBoxHeight;
  final double fontSize;
  final bool isBpmf;
  final List<WordStatus> wordsStatus;
  final List<Map> wordsPhrase;
  final int wordIndex;
  final bool isVertical;
  final bool disable;
  
  @override
  WordCardState createState() => WordCardState();
}

class WordCardState extends ConsumerState<WordCard> {
  
  bool liked = false;

  @override void initState() {
    liked = widget.wordsStatus[widget.wordIndex].liked;
    super.initState();
  }

  void _toggleLiked() {
    setState(() {
      liked = !liked;
    });
    WordStatus newStatus = widget.wordsStatus[widget.wordIndex];
    newStatus.liked = liked;
    // Use WidgetsBinding to schedule the update after the current frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      WordStatusProvider.updateWordStatus(status: newStatus);
    });
  }

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: widget.disable ? null : () {
        debugPrint('WordCard tapped. Attempting to navigate to teachWord page');
        navigateWithProvider(
          context,
          '/teachWord',
          ref,
          arguments: {
            'unitId': widget.unitId,
            'unitTitle': widget.unitTitle,
            'wordsStatus': widget.wordsStatus,
            'wordsPhrase': widget.wordsPhrase,
            'wordIndex': widget.wordIndex,
          },
        );
        debugPrint('Navigation to teachWord page initiated');
      },      
      child: Container(
        width: widget.sizedBoxWidth,
        height: widget.sizedBoxHeight,
        decoration: BoxDecoration(
          color: widget.wordsStatus[widget.wordIndex].learned ? paleYellow : beige,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Wrap(
          direction: !widget.isVertical ? Axis.vertical : Axis.horizontal,
          alignment: WrapAlignment.center,
          crossAxisAlignment: WrapCrossAlignment.center,
          children: [
             Align(
              alignment: widget.isVertical ? Alignment.topRight : Alignment.topLeft,
              child: Padding(
                padding: EdgeInsets.fromLTRB(0, 0, widget.fontSize * 0.25, 0),
                child: 
                  Wrap(
                    direction: !widget.isVertical ? Axis.vertical : Axis.horizontal,
                    alignment: WrapAlignment.center,
                    crossAxisAlignment: WrapCrossAlignment.center,
                    children:[
                      IconButton(
                        icon: liked ? const Icon(Icons.favorite) : const Icon(Icons.favorite_border),
                        iconSize: widget.fontSize * 0.5,
                        color: liked ? brightRed  : mediumGray,
                        onPressed: _toggleLiked,
                      ),
                      Icon(
                        widget.wordsStatus[widget.wordIndex].learned ? Icons.check_circle : Icons.circle_outlined,
                        size: widget.fontSize * 0.5,
                        color: widget.wordsStatus[widget.wordIndex].learned ? vibrantOrange : mediumGray,
                      ),
                    ]
                  ),
              ),
            ),
            Text(
              widget.wordsStatus[widget.wordIndex].word, 
              style: TextStyle(
                fontSize: widget.fontSize,
                fontWeight: FontWeight.w900,
                color: Colors.black,
              ),
            ),
          ],
        )));
  }
}
// End of file: ./lib/widgets/word_card.dart
//----------------------

// File: ./lib/widgets/teach_word_widget.dart






import 'dart:math';

import 'package:flutter/material.dart';
import 'package:ltrc/views/view_utils.dart';
import 'package:ltrc/widgets/mainPage/left_right_switch.dart';
import 'package:ltrc/widgets/teach_word/bpmf_vocab_content.dart';
import 'package:ltrc/widgets/teach_word/card_title.dart';
import 'package:ltrc/widgets/teach_word/tab_bar_view.dart';
import 'package:ltrc/widgets/teach_word/word_vocab_content.dart';

typedef VoidCallback = void Function(); // Make sure VoidCallback is imported from material.dart

Widget buildTeachWordTabContent({
  required String sectionName,
  required String word,
  required bool isFirst,
  required bool isLast,
  required bool isBpmf,
  required bool wordIsLearned,
  required VoidCallback? onLeftClicked, // Ensure the type is VoidCallback?
  required VoidCallback? onRightClicked, // Ensure the type is VoidCallback?
  required Widget content,
  required double maxWidth,
  required double maxHeight,
  required double fontSize,
}) {
  return SingleChildScrollView(
    child: Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        ConstrainedBox(
          constraints: BoxConstraints(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              LeftRightSwitch(
                iconsColor: lightGray,
                iconsSize: max(fontSize * 2.0, 48.0),
                rightBorder: isLast,
                middleWidget: TeachWordCardTitle(
                  sectionName: sectionName,
                  iconsColor: lightGray,
                ),
                isFirst: isFirst,
                isLast: isLast,
                onLeftClicked: wordIsLearned ? onLeftClicked : null,  // VoidCallback? used here
                onRightClicked: wordIsLearned ? onRightClicked : null, // VoidCallback? used here
              ),
              SizedBox(height: fontSize * 0.3),
              content,
            ],
          ),
        ),
      ],
    ),
  );
}

// Common image builder
Widget buildWordImageOrText(String word, bool isBpmf, double fontSize, Color backgroundColor) {
  return LayoutBuilder(
    builder: (context, constraints) {
      return Container(
        decoration: const BoxDecoration(
          color: darkBrown,
        ),
        child: Center(
          child: Image(
            width: max(17.6 * fontSize, 300.0),
            image: isBpmf
                ? AssetImage('lib/assets/img/bopomo/$word.png')
                : AssetImage('lib/assets/img/oldWords/$word.webp'),
            errorBuilder: (BuildContext context, Object exception, StackTrace? stackTrace) {
              debugPrint('Error loading image: $exception');
              return Center(
                child: Text(
                  word,
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    fontSize: fontSize * 8.0,
                    color: backgroundColor,
                    fontWeight: FontWeight.w100,
                    fontFamily: isBpmf ? "BpmfOnly" : "BpmfIansui",
                  ),
                ),
              );
            },
          ),
        ),
      );
    },
  );
}

// Extract common functionality into a reusable method
Widget buildTeachWordTabView({
  required String word, 
  required Map<dynamic, dynamic> wordObj,  
  required String vocab,
  required String sentence,
  required String vocab2,
  required bool imgExist,
  required bool isFirst,
  required bool isLast,
  required bool isBpmf,
  required int vocabIndexValue,
  required int tabIndex,
  required VoidCallback? onLeftClicked,
  required VoidCallback? onRightClicked,
  required String countText,
  required double availableWidth,
  required double fontSize,
  required Color backgroundColor,
}) {
  return TeachWordTabBarView(
    content: Stack(
      children: [
        SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ConstrainedBox(
                constraints: BoxConstraints(maxWidth: availableWidth),
                child: Column(
                  mainAxisSize: MainAxisSize.max,
                  children: <Widget>[
                    LeftRightSwitch(
                      iconsColor: lightGray,
                      iconsSize: fontSize * 2.0,
                      rightBorder: onRightClicked != null,
                      middleWidget: const TeachWordCardTitle(
                        sectionName: '用一用',
                        iconsColor: lightGray,
                      ),
                      isFirst: isFirst,
                      isLast: isLast,
                      onLeftClicked: onLeftClicked,
                      onRightClicked: onRightClicked,
                    ),
                    isBpmf
                        ? BopomofoVocabContent(
                            word: word,
                            vocab: vocab,
                            sentence: sentence,
                          )
                        : WordVocabContent(
                            vocab: vocab,
                            meaning: wordObj['meaning$tabIndex'],
                            sentence: "$sentence\n",
                            vocab2: vocab2,
                          ),
                    SizedBox(height: fontSize * 0.2),
                    SizedBox(
                      height: fontSize * 3.0,
                      child: (imgExist && !isBpmf)
                          ? Image(
                              height: fontSize * 3.0,
                              image: AssetImage(
                                'lib/assets/img/vocabulary/$vocab.webp',
                              ),
                            )
                          : SizedBox(height: fontSize * 0.5),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
        Positioned(
          right: fontSize,
          bottom: fontSize,
          child: Text(
            countText,
            style: TextStyle(
              fontSize: fontSize * 0.75,
              fontWeight: FontWeight.normal,
              color: backgroundColor,
            ),
          ),
        ),
      ],
    ),
  );
}

// Function to build the TeachWordTabView with practice icons
Widget buildTeachWordTabViewWithPracticeIcons({
  required String word,
  required Map<String, dynamic> wordObj,
  required String vocab,
  required String sentence,
  required String vocab2,
  required bool imgExist,
  required bool isFirst,
  required bool isLast,
  required bool isBpmf,
  required int vocabIndexValue,
  required int tabIndex,
  required VoidCallback? onLeftClicked,
  required VoidCallback? onRightClicked,
  required String countText,
  required double availableWidth,
  required double fontSize,
  required Color backgroundColor,
  required int practiceTimeLeft, // To control the practice icons
}) {
  return TeachWordTabBarView(
    content: Stack(
      children: [
        SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ConstrainedBox(
                constraints: BoxConstraints(maxWidth: availableWidth),
                child: Column(
                  mainAxisSize: MainAxisSize.max,
                  children: <Widget>[
                    LeftRightSwitch(
                      iconsColor: lightGray,
                      iconsSize: fontSize * 2.0,
                      rightBorder: onRightClicked != null,
                      middleWidget: const TeachWordCardTitle(
                        sectionName: '用一用',
                        iconsColor: lightGray,
                      ),
                      isFirst: isFirst,
                      isLast: isLast,
                      onLeftClicked: onLeftClicked,
                      onRightClicked: onRightClicked,
                    ),
                    isBpmf
                        ? BopomofoVocabContent(
                            word: word,
                            vocab: vocab,
                            sentence: sentence,
                          )
                        : WordVocabContent(
                            vocab: vocab,
                            meaning: wordObj['meaning$tabIndex'],
                            sentence: "$sentence\n",
                            vocab2: vocab2,
                          ),
                    SizedBox(height: fontSize * 0.2),
                    // Add practice time icons here
                    _buildPracticeTimeIcons(practiceTimeLeft, fontSize),
                    SizedBox(
                      height: fontSize * 3.0,
                      child: (imgExist && !isBpmf)
                          ? Image(
                              height: fontSize * 3.0,
                              image: AssetImage(
                                'lib/assets/img/vocabulary/$vocab.webp',
                              ),
                            )
                          : SizedBox(height: fontSize * 0.5),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
        Positioned(
          right: fontSize,
          bottom: fontSize,
          child: Text(
            countText,
            style: TextStyle(
              fontSize: fontSize * 0.75,
              fontWeight: FontWeight.normal,
              color: backgroundColor,
            ),
          ),
        ),
      ],
    ),
  );
}

// Helper function to build practice time icons
Widget _buildPracticeTimeIcons(int practiceTimeLeft, double fontSize) {
  return Column(
    children: List.generate(
      4,
      (index) {
        return _buildPracticeTimeIcon(
          practiceTimeLeft >= (4 - index),  // Adjust according to the remaining practice time
          fontSize,
          mediumGray,  // Color for unused practice time
          warmOrange,  // Color for used practice time
        );
      },
    ),
  );
}

// The actual implementation of building a practice time icon
Widget _buildPracticeTimeIcon(bool isUsed, double fontSize, String unusedColor, String usedColor) {
  return Icon(
    Icons.circle,
    size: fontSize * 0.8,
    color: isUsed ? Color(int.parse(usedColor)) : Color(int.parse(unusedColor)),
  );
}

// Other helper widgets like buildWordImageOrText, etc., can go here...

// End of file: ./lib/widgets/teach_word_widget.dart
//----------------------

// File: ./lib/widgets/mainPage/left_right_switch.dart

import 'package:flutter/material.dart';
import 'package:ltrc/views/view_utils.dart';

class LeftRightSwitch extends StatelessWidget {
  final Color iconsColor;
  final double iconsSize;
  final bool rightBorder;
  final Widget middleWidget;
  final bool isFirst;
  final bool isLast;
  final VoidCallback? onLeftClicked;
  final VoidCallback? onRightClicked;

  const LeftRightSwitch({
    super.key,
    required this.iconsColor,
    required this.iconsSize,
    required this.rightBorder,
    required this.middleWidget,
    required this.isFirst,
    required this.isLast,
    this.onLeftClicked,
    this.onRightClicked,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        (!isFirst) ? IconButton(
          icon: Icon(
            Icons.chevron_left,
            shadows: const [
              Shadow(color: Colors.black, offset: Offset(0, 6), blurRadius: 4)
            ],
            color: iconsColor,
          ),
          iconSize: iconsSize,
          onPressed: onLeftClicked ?? ()=>{},
        ) : Container(width: 40,),
        middleWidget,
        (!isLast) ? Container(
          decoration: BoxDecoration(
            border: rightBorder ? Border.all(color: lightYellow, width: 1.5) : null,
          ),
          child: IconButton(
            icon: Icon(
              Icons.chevron_right,
              shadows: const [
                Shadow(color: Colors.black, offset: Offset(0, 6), blurRadius: 4)
              ],
              color: iconsColor,
            ),
            iconSize: iconsSize,
            onPressed: onRightClicked ?? ()=>{},
          )
        )
         : Container(width: 40,),
      ],
    );
  }
}

// End of file: ./lib/widgets/mainPage/left_right_switch.dart
//----------------------

// File: ./lib/widgets/setting/setting_divider.dart

import 'package:flutter/material.dart';

class SettingDivider extends StatelessWidget {
  const SettingDivider({super.key});

  @override
  Widget build(BuildContext context) {
    return Divider(
      color: Colors.grey.shade300,
      indent: 12,
      endIndent: 12,
      height: 4,
    );
  }
}
// End of file: ./lib/widgets/setting/setting_divider.dart
//----------------------

// File: ./lib/widgets/bopomo/bopomo_container.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ltrc/providers.dart';
// import 'package:ltrc/providers.dart';
// import 'package:ltrc/views/view_utils.dart';


class BopomoContainer extends ConsumerWidget {
  const BopomoContainer(
      {super.key,
      this.character,
      this.innerWidget,
      required this.color,
      required this.onPressed});

  final VoidCallback onPressed;
  final String? character;
  final Color color;
  final Widget? innerWidget;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // final screenInfo = ref.watch(screenInfoProvider);
    final screenInfo = ref.watch(screenInfoProvider);
    double fontSize = screenInfo.fontSize;    

    return InkWell(
      onTap: onPressed,
      child: Container(
        width: fontSize * 2.5, // was 44
        height: fontSize * 3.0, // was 50
        alignment: Alignment.center,
        decoration: BoxDecoration(
            color: color,
            borderRadius: BorderRadius.circular(fontSize), // 12
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.5),
                offset: const Offset(0, 6),
                blurRadius: 4,
              )
            ]),
        child: (character == null)
            ? innerWidget
            : Text(
                character!,
                style: TextStyle(fontSize: fontSize * 1.2), // was 30
                textAlign: TextAlign.center,
              ),
      ),
    );
  }
}

// End of file: ./lib/widgets/bopomo/bopomo_container.dart
//----------------------

// File: ./.dart_tool/flutter_build/dart_plugin_registrant.dart

//
// Generated file. Do not edit.
// This file is generated from template in file `flutter_tools/lib/src/flutter_plugins.dart`.
//

// @dart = 3.0

import 'dart:io'; // flutter_ignore: dart_io_import.
import 'package:file_picker/file_picker.dart';
import 'package:path_provider_android/path_provider_android.dart';
import 'package:shared_preferences_android/shared_preferences_android.dart';
import 'package:sqflite/sqflite.dart';
import 'package:file_picker/file_picker.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite/sqflite.dart';
import 'package:file_picker/file_picker.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:file_picker/file_picker.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite/sqflite.dart';
import 'package:file_picker/file_picker.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

@pragma('vm:entry-point')
class _PluginRegistrant {

  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        FilePickerIO.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderAndroid.registerWith();
      } catch (err) {
        print(
          '`path_provider_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesAndroid.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqflitePlugin.registerWith();
      } catch (err) {
        print(
          '`sqflite` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isIOS) {
      try {
        FilePickerIO.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqflitePlugin.registerWith();
      } catch (err) {
        print(
          '`sqflite` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isLinux) {
      try {
        FilePickerLinux.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PackageInfoPlusLinuxPlugin.registerWith();
      } catch (err) {
        print(
          '`package_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderLinux.registerWith();
      } catch (err) {
        print(
          '`path_provider_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesLinux.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isMacOS) {
      try {
        FilePickerMacOS.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqflitePlugin.registerWith();
      } catch (err) {
        print(
          '`sqflite` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isWindows) {
      try {
        FilePickerWindows.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PackageInfoPlusWindowsPlugin.registerWith();
      } catch (err) {
        print(
          '`package_info_plus` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderWindows.registerWith();
      } catch (err) {
        print(
          '`path_provider_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesWindows.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    }
  }
}

// End of file: ./.dart_tool/flutter_build/dart_plugin_registrant.dart
//----------------------

// File: ./.dart_tool/dartpad/web_plugin_registrant.dart

// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:audioplayers_web/audioplayers_web.dart';
import 'package:file_picker/_internal/file_picker_web.dart';
import 'package:flutter_tts/flutter_tts_web.dart';
import 'package:fluttertoast/fluttertoast_web.dart';
import 'package:package_info_plus/src/package_info_plus_web.dart';
import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  AudioplayersPlugin.registerWith(registrar);
  FilePickerWeb.registerWith(registrar);
  FlutterTtsPlugin.registerWith(registrar);
  FluttertoastWebPlugin.registerWith(registrar);
  PackageInfoPlusWebPlugin.registerWith(registrar);
  SharedPreferencesPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}

// End of file: ./.dart_tool/dartpad/web_plugin_registrant.dart
//----------------------

